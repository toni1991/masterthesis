\section{Programmablauf und Kontrollfluss}\label{programmablauf}
Durch die in \autoref{sec:functionsAndReturnValues} erläuterten Unterschiede ergeben sich auch im Programmablauf Diskrepanzen. Allerdings führen diese Unterschiede nicht zu einem gänzlich anderen Ablauf, sondern dazu, dass Gemeinsamkeiten nicht auf den ersten Blick erkennbar sind, obwohl der Ablauf im Grunde sehr ähnlich ist. Sowohl Java- als auch COBOL-Programme werden im Allgemeinen von oben nach unten durchlaufen. Beiden Programmiersprachen ist gemein, dass sie einen definierten Einstiegspunkt in ein Programm haben. Während jedes Java-Programm in der \jav{main}-Methode startet, wird ein COBOL-Programm stets sequenziell von oben nach unten abgearbeitet und durchlaufen und beginnt daher stets mit der ersten Zeile der \cob{PROCEDURE DIVISION}.

\subsection{Genereller Ablauf}

\autoref{javaMainMethod} demonstriert einen sehr simplen Programmablauf in Java. Der Startpunkt eines jeden Java-Programms ist die \jav{main}-Methode. Von dieser aus können weitere Methoden aufgerufen werden, und sobald das Ende dieser Methode erreicht ist, terminiert das Programm. Im vorliegenden Beispiel wird nach einer Ausgabe in \jav{main} die Methode \jav{otherMethod} aufgerufen, bevor der Ablauf wieder in der \jav{main}-Methode fortgesetzt wird. Daran soll folgendes Verhalten deutlich werden: Endet eine aufgerufene Methode wie geplant -- \dahe ohne eine \jav{Exception} -- wird stets mit der nächsten Anweisung nach dem Methodenaufruf fortgefahren. 

\begin{codeWithCaption}{Java main-Methode}{javaMainMethod}
\java{MainMethod.java}
\begin{shellwindow}
$ javac MainMethod.java 
$ java MainMethod
Running main method!
Running other method!
Running return value method!
Continue main method!
\end{shellwindow}
\end{codeWithCaption}

In COBOL gestaltet sich der Programmablauf ähnlich. Das Programm wird stets von oben nach unten durchlaufen, wobei dieser lineare Ablauf \zB durch die Verwendung von \cob{PERFORM}-, \cob{CALL}-, \cob{GO TO}- oder \cob{NEXT SENTENCE}-Anweisungen verändert werden kann.

Ein Unterprogramm wird mit \cob{CALL} aufgerufen und gibt mit \cob{GOBACK} die Kontrolle zurück an das aufrufende Programm. Die Ausführung eines COBOL-Programms endet beim Erreichen einer \cob{STOP RUN}-Anweisung oder mit dem Ende des Programms (\cob{END PROGRAM}). 

\begin{codeWithCaption}{Programmablauf in COBOL}{simpleControlFlowCobol}
\cobol{simpleControlFlow.cbl}
\begin{shellwindow}
$ ./simpleControlFlow 
Main paragraph
Enter some number: 0
Main paragraph again
$ ./simpleControlFlow 
Main paragraph
Enter some number: 1 
Main paragraph again
Enter some number: 2
\end{shellwindow}
\end{codeWithCaption}

Die beiden Ausführungen von \autoref{simpleControlFlowCobol} zeigen das angesprochene Verhalten eines COBOL-Programms. Beim ersten Durchlauf wird für die Variable \cob{INPUT-NUMBER} der Wert 0 eingegeben, was durch das Ausführen der \cob{STOP RUN}-Anweisung in Zeile 15, das Beenden des Programmes bewirkt. Beim zweiten Mal wird hingegen der Wert 1 eingegeben. Dieser Wert verhindert das Abschließen des Programms in Zeile 15, wodurch der Programmablauf in Zeile 17 fortgesetzt wird und somit erneut die Eingabeaufforderung erscheint.

Wie in \autoref{sec:structure} beschrieben besteht ein COBOL-Programm aus verschiedenen strukturellen Komponenten. \autoref{paragraphSecionControlFlowCobol} soll den Einfluss davon auf den Pro\-grammab\-lauf veranschaulichen.

\begin{codeWithCaption}{Programmablaufunterschiede in COBOL mit Sections und Paragraphs}{paragraphSecionControlFlowCobol}
\cobol{paragraphSecionControlFlow.cbl}
\begin{shellwindow}
$ ./paragraphSecionControlFlow 
Calling section:
123 
Calling paragraphs with PERFORM THRU:
123 
Calling paragraph:
1
\end{shellwindow}
\end{codeWithCaption}

Wird mittels \cob{PERFORM} eine Section aufgerufen, so werden alle Paragraphs innerhalb dieser Section der Reihe nach ausgeführt. Ruft man jedoch einen Paragraph auf, so wird nur dieser Paragraph ausgeführt. Eine weitere Möglichkeit ist die Kombination des \cob{PERFORM} mit dem \cob{THRU}-Schlüsselwort. Hierbei werden alle Paragraphs zwischen zwei festgelegten Paragraphs ausgeführt. Der Kontrollfluss geht bei jeder Variante stets an das Statement nach dem \cob{PERFORM}.

Um Verwirrungen vorzubeugen und lesbaren Code zu erhalten, sollten alle Paragraphs stets Teil einer Section sein und auch nur diese Ziel einer \cob{PERFORM}-Anweisung sein. Der letzte Paragraph einer Section sollte dabei immer ein \cob{EXIT}-Paragraph sein, der nur das Schlüsselwort \cob{EXIT} beinhaltet. So ist das Ende einer Section beim Lesen des Codes klar erkennbar. Außerdem stellt dieser \cob{EXIT}-Paragraph oftmals eine Ausnahme zur Verwendung des \cob{GO TO}-Befehls dar. Dies ist nötig, da COBOL keinen Befehl wie das \jav{return} in Java enthält, um die Ausführungskontrolle an die aufrufende Stelle zurückzugeben. Dieses Vorgehen wurde auch von \citeauthor{richards_enhancing_1984} bereits \citeyear{richards_enhancing_1984} als Best-Practice beschrieben  \cite{richards_enhancing_1984}. Die meisten Code-Beispiele dieser Arbeit enthalten bewusst keinen separaten \cob{EXIT}-Paragraph, um den Umfang und die Übersichtlichkeit der Listings so gering wie möglich zu halten. 

\subsection{Verzweigungen}
Eine wichtige Eigenschaft von Programmiersprachen ist bedingte Verzweigung, sprich die Ausführung von Programmteilen nur unter bestimmten Voraussetzungen. Sowohl Java als auch COBOL bieten hierfür die Schlüsselwörter \jav{if}-\jav{else} (Java) \bzw \cob{IF}-\cob{ELSE}-\cob{END-IF} (COBOL). Auch die Verwendung ist sehr ähnlich wie folgende Beispiele zeigen sollen.

\mintedJava{IfExample.java}{Verzweigung in Java}{ifJava}

In \autoref{ifJava} wird anhand einer Nutzereingabe eine Fallunterscheidung \bzw Verzweigung gemacht. Dabei soll gezeigt werden, dass es möglich ist sowohl mehrere Zeilen als auch nur eine Zeile konditionell auszuführen. Soll mehr als eine Zeile untergeordnet werden, ist eine Gruppierung als Block -- mit geschweiften Klammern -- nötig. Der \jav{else}-Zweig zeigt eine einzelne Anweisung als bedingt auszuführendes Statement. Das letzte Statement zeigt die Verwendung des konditionalen Operators \quotes{?}. Dabei handelt es sich um bedingte Expressions, während in \jav{if}-\jav{else}-Anweisungen Statements stehen.  

\mintedCobol{IF-EXAMPLE.cbl}{Verzweigung in COBOL}{ifCOBOL}

\autoref{ifCOBOL} bildet diese Logik in COBOL ab. Die beiden Sections \cob{END-IF-EXAMPLE} und \cob{PERIOD-IF-EXAMPLE} zeigen dabei zwei unterschiedliche Wege diese zu konstruieren. Während erstere eine \cob{ELSE}- und eine \cob{END-IF} Anweisung nutzt, um das Konstrukt aufzubauen und zu terminieren, verwendet letztere die Eigenschaft, dass ein \cob{IF} auch durch ein Sentence-Ende -- siehe \autoref{sec:structure} -- abgeschlossen werden kann. Dies erlaubt jedoch keine verschachtelten Verzweigungen und kann -- wie die befragten Experten anmerkten -- in der Praxis schnell zu Fehlern oder zumindest zu schwer durchschaubarem Verhalten führen. Herr Streit betonte, dass bestehende Programme teilweise solche Konstrukte beinhalten, ein \cob{IF} jedoch stets mit einem \cob{END-IF} terminiert werden sollte. Dies sorgt dafür, dass es dem Compiler möglich ist, Fehler in der Verzweigung zu erkennen und eine bessere Lesbarkeit zu erreichen.

\subsection{Schleifen}

Wie in vielen anderen Sprachen unterstützen Java und COBOL auch Schleifenkonstrukte. Während Java dafür dedizierte Schlüsselwörter bereitstellt, fungiert in COBOL auch dafür das \cob{PERFORM}-Statement. Dies kann für Unklarheiten sorgen, weil dieses Schlüsselwort wie später in der Arbeit beschrieben weitere Funktionen erfüllt. Jedoch soll an dieser Stelle lediglich auf die Verwendung als Schleifenkonstrukt eingegangen werden.

Java bietet mit \jav{while}-, \jav{do}-\jav{while}- und \jav{for}-Schleifen drei unterschiedliche Arten von Schleifen. \autoref{loopsJava} enthält alle drei Konstrukte. Während die ersten beiden kopf- und fußgesteuert eine Bedingung überprüfen wird eine \jav{for}-Schleife \idR dazu genutzt, um Werte einer bestimmten (Zahlen-)Menge zu durchlaufen.

\mintedJava{Loops.java}{Schleifen in Java}{loopsJava}

COBOL nutzt für alle Schleifen das \cob{PERFORM}-Schlüsselwort. In Verbindung mit weiteren Statements entstehen so unterschiedliche Schleifentypen. \autoref{loopsCOBOL} beschreibt die wichtigsten davon. Eine bedingte Schleifenausführung lässt sich mithilfe des \cob{UNTIL}-Schlüsselworts und einer nachfolgenden Bedingung erreichen. Eine Zählschleife, entsprechend eines \jav{for} in Java, kann durch \cob{VARYING}, \cob{FROM} und \cob{BY} konstruiert werden. Jede Schleife kann zusätzlich durch die Angabe von \cob{WITH TEST AFTER} von einer kopfgesteuerten zu einer fußgesteuerten Schleife gemacht werden, \dahe die Bedingung wird nach einem Schleifendurchlauf geprüft und nicht davor.

\mintedCobol{LOOP-EXAMPLE.cbl}{Schleifen in COBOL}{loopsCOBOL}

\subsection{Weitere Schlüsselwörter}

Weitere Schlüsselwörter, die den Kontrollfluss -- vor allem im Zusammenhang mit Verzeigungen und Schleifen -- in Java steuern können, sind außerdem \jav{break}, \jav{continue} und \jav{goto}. Zu beachten ist dabei, dass das \jav{goto}-Schlüsselwort zwar im Sprachstandard definiert, jedoch in keiner gängigen JVM implementiert ist. Die Verwendung führt zu Fehlern beim Kompilieren. In \autoref{javaBreakContinue} finden sich beispielhafte Verwendungen der beiden anderen Schlüsselwörter.

\begin{codeWithCaption}{Beispiele für die Verwendung von break und continue in Java}{javaBreakContinue}
\java{BreakContinueExample.java}
\begin{shellwindow}
$ javac BreakContinueExample.java 
$ java BreakContinueExample
== break example == 
(0)(1)
== continue example == 
(0)(1)(2)(8)(9)
\end{shellwindow}
\end{codeWithCaption}

Ein einfaches \jav{break} sorgt wie gezeigt dafür, dass die direkt umfassende Schleife verlassen wird. Auch ein simples \jav{continue} hat Auswirkungen auf die direkt beinhaltende Schleife. So sorgt es dafür, dass der aktuelle Schleifendurchlauf abgebrochen und mit dem nächsten fortgefahren wird. \autoref{mehrfachverzweigungen} zeigt eine weitere Verwendung des \jav{break}-Statements. Deutlich unüblicher -- jedoch nicht weniger relevant -- ist der Gebrauch eines Labels in Java. Dieses Label kann in der Verbindung mit einer \jav{break}- oder \jav{continue}-Anweisung genutzt werden, um mehrere umfassende Schleifen zu verlassen \bzw um mit dem nächsten Schleifendurchlauf einer weiter außen befindlichen fortzufahren. Die Anweisung betrifft dabei die Schleife, welche das Label trägt. 

In COBOL ist ebenfalls das Schlüsselwort \cob{CONTINUE} vorhanden. Allerdings ist hierbei Vorsicht geboten, da dieses abweichende Bedeutung vom gleichnamigen Java-Schlüsselwort hat. Während in Java zum nächsten Schleifendurchlauf gesprungen werden kann, entspricht dieses Schlüsselwort in COBOL lediglich einer Anweisung, bei der nichts ausgeführt wird. Dies ist in der Praxis häufig zu beobachten, um \zB Verzeigungsteile leer zu lassen ohne die Bedingung negieren zu müssen, da der Compiler keine leeren Teile akzeptiert.

Neben diesem ist \cob{NEXT SENTENCE} ein Schlüsselwort, das häufig in älterem Code zu finden sei, wie Herr Lamperstorfer bestätigte. Dieses kann dazu genutzt werden, um den aktuellen Sentence zu verlassen und mit der darauf folgenden Anweisung fortzufahren. Zu beobachten ist die Verwendung auch häufig zur Negation einer Bedingung, indem der \cob{IF}-Zweig lediglich dieses Statement enthält und der \cob{ELSE}-Zweig die Logik bei Nichtzutreffen der Bedingung enthält. Diese Konstrukte sollten jedoch vermieden werden und durch ein einfach Negieren mit \cob{NOT} geschrieben \bzw ersetzt werden. Aus Gründen der Unübersichtlichkeit ist dieses Schlüsselwort in GnuCOBOL standardmäßig verboten. 

Seltener zu finden ist dagegen die \cob{EXIT PERFORM}-Anweisung. Diese kann innerhalb von Schleifen dazu genutzt werden, um, wie mit einem \jav{break} in Java, die umgebende Schleife zu verlassen oder durch \cob{EXIT PERFORM CYCLE}, wie mit einem \jav{continue} in Java, mit dem nächsten Schleifendurchlauf fortzufahren. Dies soll \autoref{exitPerform} verdeutlichen.

\begin{codeWithCaption}{EXIT PERFORM in COBOL}{exitPerform}
\cobol{EXIT-PERFORM.cbl}
\begin{shellwindow}
00
10
\end{shellwindow}
\end{codeWithCaption}

Die Verwendung des \cob{GO TO}-Befehls -- abgesehen von oben genanntem Einsatz als \textit{return}-Ersatz innerhalb einer Section -- sollte in COBOL unterlassen werden und ist oftmals sogar durch projekt- oder unternehmensspezifische Vorgaben verboten ist, da ansonsten sehr schwer verständlicher und wartbarer Code entstehen kann. Leider findet man in der Praxis oftmals Code, der \cob{GO TO}-Befehle zur Steuerung des Ablaufs verwendet. Sogar Schleifenkonstrukte sind in älteren Programmen oft damit realisiert, worauf Herr Streit hinwies.

\subsection{Ausnahmebehandlung}

In modernen Sprachen sind Ausnahmebehandlungsmechanismen vorhanden, um die Steuerung des Kontrollflusses klar von der Fehlerbehandlung zu trennen. So wird zum einen eine übersichtlichere Implementierung erlaubt, aber auch erreicht, dass bereits der Compiler auf Fehler hinweisen kann, die bei der Ausführung auftreten können \bzw gänzlich das Kompilieren bei ungenügender Fehlerbehandlung verweigert.

Java bietet dabei das Konzept der \jav{Exception}s. Diese lassen sich in sogenannte \textit{checked} und \textit{unchecked}-\jav{Exception}s unterteilen. Während \textit{checked}-\jav{Exception} stets einer ausreichenden Fehlerbehandlung im Code bedürfen und ansonsten zu Fehlern des Kompiliervorgangs führen, können \textit{unchecked}-\jav{Exception}s unbehandelt gelassen werden. Zur genauen Verwendungserklärung kann beispielsweiseweiterführende Literatur wie \citeWithTitle{byrne_java_2009-1} von \citeauthor{byrne_java_2009-1} herangezogen werden.

COBOL bietet zur generellen Ausnahmebehandlung keine Methodik. Fehlerfälle müssen über Variablenwerte signalisiert, geprüft und entsprechend behandelt werden. Herr Streit wies darauf hin, dass eine ungenügende Prüfung hierbei zum kompletten Absturz des Programms führen kann. Jedoch ist es möglich, vordefinierte Fehler bei Berechnungen oder String-Zuweisungen abzufangen und darauf zu reagieren wie \autoref{exceptionsCobol} zeigt. Dazu können \cob{ON SIZE ERROR} und \cob{ON OVERFLOW} genutzt werden.

\mintedCobol{ON-SIZE-ERROR.cbl}{Rudimentäre Fehlerbehandlung in COBOL}{exceptionsCobol}

\subsection{Nebenläufigkeit}

Ein letzter wichtiger Punkt ist, dass es in Java möglich und auch üblich ist, Programme nebenläufig zu entwickeln. Das heißt, mehrere Threads arbeiten parallel und führen Verarbeitungen -- je nach Hardware nur scheinbar -- gleichzeitig aus. Dabei muss der Entwickler auf die Synchronisation von gemeinsam genutzten Speicherbereichen achten, um gültige Datenen zu gewehrleisten. Diese nebenläufige Programmierung birgt zwar ein gewisses Fehlerpotential bei der Implementierung, sorgt jedoch dafür, dass Logik tendenziell effizienter ausgeführt wird.

In COBOL ist diese nebenläufige Ausführung nicht möglich. Ein COBOL-Programm führt Verarbeitungsschritte stets sequenziell aus und erlaubt keine parallelen Ausführungen. Über einen Transaktionsmonitor ist es jedoch teilweise möglich, dass verschiedene Programme gleichzeitig ausgeführt werden. Jedoch haben diese keine Kenntnis von anderen ausgeführten Programmen. Teilweise können verschiedene Programme auch die gleichen Speicherbereiche reservieren und so quasi miteinander arbeiten. Jedoch gibt es in COBOL keine Möglichkeit zur Synchronisation, weshalb dieses Vorgehen nur sehr selten beobachtet werden kann. Bei einem Transaktionsmonitor handelt es sich um eine Art Middleware, vergleichbar zu Application-Servern in Java, welche Anfragen entgegennimmt, dafür sorgt, dass Ressourcen geöffnet und aufgeräumt werden, auf Host-Systemen Terminal-Masken zur Verfügung stellt und entscheidet, wie viele und welche Programme parallel ausgeführt werden. Ein Beispiel hierfür ist das \textit{Customer Information Control System} kurz \textit{CICS}. Um aus einem COBOL-Programm Teile des Transaktionsmonitors aufzurufen, gibt es Befehle wie \cob{EXEC CICS}. 