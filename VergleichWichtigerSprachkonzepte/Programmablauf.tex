\section{Programmablauf und Kontrollfluß}\label{programmablauf}
Durch die in \autoref{sec:functionsAndReturnValues} erläuterten Unterschiede ergeben sich auch im Programmablauf Diskrepanzen. Während Java einen definierten Einstiegspunkt in ein Programm hat (\mintinline{java}{main}-Methode) wird ein COBOL-Programm stets sequenziell von oben nach unten abgearbeitet und durchlaufen. Diese Abarbeitung beginnt am Anfang der \mintinline{cobolfree}{PROCEDURE DIVISION}.\\

\subsection*{Programmablauf in Java}

\java{MainMethod.java}
\sepCodeAndOutputCheck
\begin{shellwindow}
$ javac MainMethod.java 
$ java MainMethod
Running main method!
Running other method!
Continue main method!
\end{shellwindow}
\mintedCaption{Java main-Methode}{javaMainMethod}

\autoref{javaMainMethod} demonstriert einen sehr simplen Programmablauf in Java. Wie bereits erwähnt ist der Startpunkt eines jeden Java-Programms die \mintinline{java}{main}-Methode. Von dieser aus können weitere Methoden aufgerufen werden und sobald das Ende dieser Methode erreicht ist terminiert das Programm. Im vorliegenden Beispiel wird also nach einer Ausgabe in \mintinline{java}{main}, die Funktion \mintinline{java}{otherMethod} aufgerufen, bevor der Ablauf wieder in der \mintinline{java}{main}-Methode fortgesetzt wird. Daran soll folgendes Verhalten deutlich werden: Endet eine aufgerufene Funktion wie geplant -- d.h. ohne eine \mintinline{java}{Exception} \todo{reference exception section} -- wird stets mit der nächsten Anweisung nach dem Funktionsaufruf fortgefahren.\\

Weitere Schlüsselwörter die den Kontrollfluß steuern können sind außerdem \mintinline{java}{break}, \mintinline{java}{continue} und \mintinline{java}{goto}. Zu beachten ist dabei, dass das \mintinline{java}{goto}-Schlüsselwort zwar im Sprachstandard noch definiert ist, jedoch in keiner gängigen JVM implementiert ist. Die Verwendung führt zu Fehlern beim Kompilieren. In \autoref{javaBreakContinue} finden sich beispielhafte Verwendungen der beiden anderen Schlüsselwörter.

\java{BreakContinueExample.java}
\sepCodeAndOutputCheck
\begin{shellwindow}
$ javac BreakContinueExample.java 
$ java BreakContinueExample
== break example == 
(0)(1)
== continue example == 
(0)(1)(2)(8)(9)
\end{shellwindow}
\mintedCaption{Beispiele für die Verwendung von break und continue in Java}{javaBreakContinue}

Ein einfaches \mintinline{java}{break} sorgt wie gezeigt dafür, dass die direkt umfassende Schleife verlassen wird. Auch ein simples \mintinline{java}{continue} hat Auswirkungen auf die direkt beinhaltende Schleife. So sorgt es dafür, dass der aktuelle Schleifendurchlauf abgebrochen und mit dem nächsten fortgefahren wird. \autoref{mehrfachverzweigungen} zeigt eine weitere Verwendung des \mintinline{java}{break}-Statements.

\java{BreakContinueLabelExample.java}
\sepCodeAndOutputCheck
\begin{shellwindow}
$ javac BreakContinueLabelExample.java 
$ java BreakContinueLabelExample
== break label example == 
(0 0)(0 1)(0 2)
== continue label example == 
(0 0)(0 1)(0 2)(1 0)(1 1)(1 2)(2 0)(2 1)(2 2)
\end{shellwindow}
\mintedCaption{Verwendung von break und continue mit Label in Java}{javaBreakContinueLabel}

Deutlich unüblicher -- jedoch nicht weniger relevanter -- ist der Gebrauch eines Labels in Java. Dieses Label kann in der Verbindung mit einer \mintinline{java}{break}- oder \mintinline{java}{continue}-Anweisung genutzt werden, um mehrere umfassende Schleifen verlassen bzw. um mit dem nächsten Schleifendurchlauf einer weiter außen befindlichen Schleife fortgefahren zu werden. Die Anweisung betrifft dabei die Schleife, welche das Label trägt. Dies zeigt \autoref{javaBreakContinueLabel}.

\subsection*{Programmablauf in COBOL}

In COBOL gestaltet sich der Programmablauf gänzlich anders. Das Programm wird stets von oben nach unten durchlaufen. Wobei dieser lineare Ablauf z.B. durch die Verwendung von \mintinline{cobolfree}{PERFORM}-, \mintinline{cobolfree}{CALL}-, \mintinline{cobolfree}{GO TO}- oder \mintinline{cobolfree}{NEXT STATEMENT}-Anweisungen verändert werden kann. An dieser Stelle sei ausdrücklich erwähnt, dass die Verwendung des \mintinline{cobolfree}{GO TO}\index{GO TO}-Befehls unter allen Umständen unerlassen werden sollte, da ansonsten sehr schwer verständlicher und wartbarer Code entsteht! Leider findet man sich in der Praxis oftmals mit Code konfrontiert, der \mintinline{cobolfree}{GO TO}-Befehle zur Steuerung des Ablaufs verwendet.

Die Ausführung eines COBOL-Programms endet beim Erreichen einer \mintinline{cobolfree}{STOP RUN}-Anweisung oder mit dem Ende des Programms (\mintinline{cobolfree}{END PROGRAM}). Ein Unterprogramm gibt hingegen mit \mintinline{cobolfree}{GOBACK} die Kontrolle zurück an das aufrufende Programm.\\

\cobol{simpleControlFlow.cbl}
\sepCodeAndOutputCheck
\begin{shellwindow}
$ ./simpleControlFlow 
Main paragraph
Enter some number: 0
Main paragraph again
$ ./simpleControlFlow 
Main paragraph
Enter some number: 1 
Main paragraph again
Enter some number: 2
\end{shellwindow}
\mintedCaption{Programmablauf in COBOL}{simpleControlFlowCobol}

Die beiden Ausführungen von \autoref{simpleControlFlowCobol} zeigen das angesprochene Verhalten eines COBOL-Programms. Beim ersten Durchlauf wird für die Variable \mintinline{cobolfree}{INPUT-NUMBER} der Wert 0 eingegeben, was durch das Ausführen der \mintinline{cobolfree}{STOP RUN}-Anweisung in Zeile 15, das Beenden des Programmes bewirkt. Beim zweiten Mal wird hingegen der Wert 1 eingegeben. Dieser Wert verhindert das Abschließen des Programms in Zeile 15, wodurch der Programmablauf in Zeile 17 fortgesetzt wird und somit erneut die Eingabeaufforderung erscheint.\\

Wie in \autoref{sec:scope} beschrieben besteht ein COBOL-Programm aus verschiedenen strukturellen Komponenten. Diese haben auch einen gewissen Einfluss auf den Programmablauf. Dies soll das Beispiel in \autoref{paragraphSecionControlFlowCobol} veranschaulichen.\\

\cobol{paragraphSecionControlFlow.cbl}
\sepCodeAndOutputCheck
\begin{shellwindow}
$ ./paragraphSecionControlFlow 
Calling section:
123 
Calling paragraphs with PERFORM THRU:
123 
Calling paragraph:
1
\end{shellwindow}
\mintedCaption{Programmablaufunterschiede in COBOL mit Sections und Paragraphs}{paragraphSecionControlFlowCobol}

Wird mittels \mintinline{cobolfree}{PERFORM} eine \mintinline{cobolfree}{SECTION} aufgerufen, so werden alle Paragraphs innerhalb dieser \mintinline{cobolfree}{SECTION} der Reihe nach ausgeführt. Ruft man jedoch einen Paragraph auf, so wird nur dieser Paragraph ausgeführt. Eine weitere Möglichkeit ist die Kombination des \mintinline{cobolfree}{PERFORM} mit dem \mintinline{cobolfree}{THRU}-Schlüsselwort. Hierbei werden alle Paragraphs zwischen zwei festgelegten Paragraphs ausgeführt. Der Kontrollfluss geht bei jeder Variante stets an das Statement nach dem \mintinline{cobolfree}{PERFORM}. \todo{EXIT-Statement?}\\

Um Verwirrungen vorzubeugen und lesbaren Code zu erhalten sollten alle Paragraphs stets Teil einer \mintinline{cobolfree}{SECTION} sein und auch nur diese Ziel einer \mintinline{cobolfree}{PERFORM}-Anweisung sein. Der letzte Paragraph einer \mintinline{cobolfree}{SECTION} sollte dabei immer ein \mintinline{cobolfree}{EXIT}-Paragraph sein, also nur das Schlüsselwort \mintinline{cobolfree}{EXIT} beinhalten. So ist das Ende einer \mintinline{cobolfree}{SECTION} beim lesen des Codes klar erkennbar. Dieses Vorgehen wurde auch von \citeauthor{richards_enhancing_1984} bereits \citeyear{richards_enhancing_1984} als best-practice beschrieben  \cite{richards_enhancing_1984}.

Die meisten Code-Beispiele dieser Arbeit enthalten bewusst keinen separaten \mintinline{cobolfree}{EXIT}-Paragraph, um den Umfang und die Übersichtlichkeit der Listings so gering wie möglich zu halten. 