\section{Programmablauf und Kontrollfluß}\label{programmablauf}
Durch die in \autoref{sec:functionsAndReturnValues} erläuterten Unterschiede ergeben sich auch im Programmablauf Diskrepanzen. Allerdings bleibt hier zu erwähnen, dass diese Unterschiede nicht zu einem gänzlich anderen Ablauf führen, sondern eher dafür sorgen, dass Gemeinsamkeiten nicht auf den ersten Blick erkennbar sind, obwohl der Ablauf im Grunde sehr ähnlich ist. Sowohl Java- als auch COBOL-Programme werden im Allgemeinen von oben nach unten durchlaufen. Beiden Programmiersprachen ist gemein, dass sie einen definierten Einstiegspunkt in ein Programm haben. Während jedes Java-Programm in der \mintinline{java}{main}-Methode startet wird ein COBOL-Programm stets sequenziell von oben nach unten abgearbeitet und durchlaufen und beginnt daher stets mit der ersten Zeile der \mintinline{cobolfree}{PROCEDURE DIVISION}.

\subsection{Programmablauf}
\java{MainMethod.java}
\sepCodeAndOutputCheck
\begin{shellwindow}
$ javac MainMethod.java 
$ java MainMethod
Running main method!
Running other method!
Running return value method!
Continue main method!
\end{shellwindow}
\mintedCaption{Java main-Methode}{javaMainMethod}

\autoref{javaMainMethod} demonstriert einen sehr simplen Programmablauf in Java. Wie bereits erwähnt ist der Startpunkt eines jeden Java-Programms die \mintinline{java}{main}-Methode. Von dieser aus können weitere Methoden aufgerufen werden und sobald das Ende dieser Methode erreicht ist terminiert das Programm. Im vorliegenden Beispiel wird also nach einer Ausgabe in \mintinline{java}{main}, die Funktion \mintinline{java}{otherMethod} aufgerufen, bevor der Ablauf wieder in der \mintinline{java}{main}-Methode fortgesetzt wird. Daran soll folgendes Verhalten deutlich werden: Endet eine aufgerufene Funktion wie geplant -- d.h. ohne eine \mintinline{java}{Exception} -- wird stets mit der nächsten Anweisung nach dem Funktionsaufruf fortgefahren. 

In COBOL gestaltet sich der Programmablauf ähnlich. Das Programm wird stets von oben nach unten durchlaufen. Wobei dieser lineare Ablauf z.B. durch die Verwendung von \mintinline{cobolfree}{PERFORM}-, \mintinline{cobolfree}{CALL}-, \mintinline{cobolfree}{GO TO}- oder \mintinline{cobolfree}{NEXT} \mintinline{cobolfree}{SENTENCE}-Anweisungen verändert werden kann.

Ein Unterprogramm wird mit \mintinline{cobolfree}{CALL} aufgerufen und gibt hingegen mit \mintinline{cobolfree}{GOBACK} die Kontrolle zurück an das aufrufende Programm. Die Ausführung eines COBOL-Programms endet beim Erreichen einer \mintinline{cobolfree}{STOP RUN}-Anweisung oder mit dem Ende des Programms (\mintinline{cobolfree}{END PROGRAM}). 

\cobol{simpleControlFlow.cbl}
\sepCodeAndOutputCheck
\begin{shellwindow}
$ ./simpleControlFlow 
Main paragraph
Enter some number: 0
Main paragraph again
$ ./simpleControlFlow 
Main paragraph
Enter some number: 1 
Main paragraph again
Enter some number: 2
\end{shellwindow}
\mintedCaption{Programmablauf in COBOL}{simpleControlFlowCobol}

Die beiden Ausführungen von \autoref{simpleControlFlowCobol} zeigen das angesprochene Verhalten eines COBOL-Programms. Beim ersten Durchlauf wird für die Variable \mintinline{cobolfree}{INPUT-NUMBER} der Wert 0 eingegeben, was durch das Ausführen der \mintinline{cobolfree}{STOP RUN}-Anweisung in Zeile 15, das Beenden des Programmes bewirkt. Beim zweiten Mal wird hingegen der Wert 1 eingegeben. Dieser Wert verhindert das Abschließen des Programms in Zeile 15, wodurch der Programmablauf in Zeile 17 fortgesetzt wird und somit erneut die Eingabeaufforderung erscheint.

Wie in \autoref{sec:structure} beschrieben besteht ein COBOL-Programm aus verschiedenen strukturellen Komponenten. Diese haben auch einen gewissen Einfluss auf den Programmablauf. Dies soll das Beispiel in \autoref{paragraphSecionControlFlowCobol} veranschaulichen.

\cobol{paragraphSecionControlFlow.cbl}
\sepCodeAndOutputCheck
\begin{shellwindow}
$ ./paragraphSecionControlFlow 
Calling section:
123 
Calling paragraphs with PERFORM THRU:
123 
Calling paragraph:
1
\end{shellwindow}
\mintedCaption{Programmablaufunterschiede in COBOL mit Sections und Paragraphs}{paragraphSecionControlFlowCobol}

Wird mittels \mintinline{cobolfree}{PERFORM} eine Section aufgerufen, so werden alle Paragraphs innerhalb dieser Section der Reihe nach ausgeführt. Ruft man jedoch einen Paragraph auf, so wird nur dieser Paragraph ausgeführt. Eine weitere Möglichkeit ist die Kombination des \mintinline{cobolfree}{PERFORM} mit dem \mintinline{cobolfree}{THRU}-Schlüsselwort. Hierbei werden alle Paragraphs zwischen zwei festgelegten Paragraphs ausgeführt. Der Kontrollfluss geht bei jeder Variante stets an das Statement nach dem \mintinline{cobolfree}{PERFORM}.

Um Verwirrungen vorzubeugen und lesbaren Code zu erhalten sollten alle Paragraphs stets Teil einer Section sein und auch nur diese Ziel einer \mintinline{cobolfree}{PERFORM}-Anweisung sein. Der letzte Paragraph einer Section sollte dabei immer ein \mintinline{cobolfree}{EXIT}-Paragraph sein, also nur das Schlüsselwort \mintinline{cobolfree}{EXIT} beinhalten. So ist das Ende einer Section beim lesen des Codes klar erkennbar. Außerdem stellt dieser \mintinline{cobolfree}{EXIT}-Paragraph oftmals eine Ausnahme zur Verwendung des \mintinline{cobolfree}{GO TO}-Befehls dar. Dies ist nötig, da COBOL keinen Befehl wie das \mintinline{java}{return} in Java enthält, um die Ausführungskontrolle an die aufrufende Stelle zurückzugeben. Dieses Vorgehen wurde auch von \citeauthor{richards_enhancing_1984} bereits \citeyear{richards_enhancing_1984} als best-practice beschrieben  \cite{richards_enhancing_1984}. Die meisten Code-Beispiele dieser Arbeit enthalten bewusst keinen separaten \mintinline{cobolfree}{EXIT}-Paragraph, um den Umfang und die Übersichtlichkeit der Listings so gering wie möglich zu halten. 

\subsection{Verzweigungen}
Eine wichtige Eigenschaft von Programmiersprachen ist konditionelle Verzweigung, also die Ausführung von Programmteilen nur unter bestimmten Voraussetzungen. Sowohl Java als auch COBOL bieten hierfür die Schlüsselwörter \mintinline{java}{if}-\mintinline{java}{else} (Java) bzw. \mintinline{cobolfree}{IF}-\mintinline{cobolfree}{ELSE}-\mintinline{cobolfree}{END-IF} (COBOL). Auch die Verwendung ist sehr ähnlich wie folgende Beispiele zeigen sollen.

\mintedJava{IfExample.java}{Verzweigung in Java}{ifJava}

In \autoref{ifJava} wird anhand einer Nutzereingabe eine Fallunterscheidung bzw. Verzweigung gemacht. Dabei soll gezeigt werden, dass es möglich ist sowohl mehrere Zeilen als auch nur eine Zeile konditionell auszuführen. Soll mehr als eine Zeile untergeordnet werden, ist eine Gruppierung als Block -- mit geschweiften Klammern -- nötig. Der \mintinline{java}{else}-Zweig zeigt eine einzelne Anweisung als bedingt auszuführendes Statement.

\mintedCobol{IF-EXAMPLE.cbl}{Verzweigung in COBOL}{ifCOBOL}

\autoref{ifCOBOL} bildet selbige Logik in COBOL ab. Die beiden Sections \mintinline{cobolfree}{END-IF-EXAMPLE} und \mintinline{cobolfree}{PERIOD-IF-EXAMPLE} zeigen dabei zwei unterschiedliche Wege diese zu konstruieren. Während erstere eine \mintinline{cobolfree}{ELSE}- und eine \mintinline{cobolfree}{END-IF} Anweisung nutzt, um das Konstrukt aufzubauen und zu terminieren, verwendet letztere die Eigenschaft, dass ein \mintinline{cobolfree}{IF} auch durch ein Sentenceende -- siehe \autoref{sec:structure} -- abgeschlossen werden kann. Dies erlaubt jedoch keine verschachtelten Verzweigungen und kann -- wie die befragten Experten anmerkten -- in der Praxis schnell zu Fehlern oder zumindest zu schwer durchschaubarem Verhalten führen. Herr Streit betonte, dass bestehende Programme teilweise solche Konstrukte beinhalten, ein \mintinline{cobolfree}{IF} jedoch stets mit einem \mintinline{cobolfree}{END-IF} terminiert werden sollte. Dies sorgt dafür, dass es dem Compiler möglich ist Fehler in der Verzweigung zu erkennen und eine bessere Lesbarkeit zu erreichen.

\subsection{Schleifen}

Wie in vielen anderen Sprachen unterstützen Java und COBOL auch Schleifenkonstrukte. Während Java dafür dedizierte Schlüsselwörter bereitstellt fungiert in COBOL auch dafür das \mintinline{cobolfree}{PERFORM}-Statement. Dies kann für Unklarheiten sorgen weil dieses Schlüsselwort wie später in der Arbeit beschrieben weitere Funktionen erfüllt. Jedoch soll an dieser Stelle lediglich auf die Verwendung als Schleifenkonstrukt eingegangen werden.

Java bietet mit \mintinline{java}{while}-, \mintinline{java}{do}-\mintinline{java}{while}- und \mintinline{java}{for}-Schleifen drei unterschiedliche Arten von Schleifen. \autoref{loopsJava} enthält alle drei Konstrukte. Während die ersten beiden kopf- und fußgesteuert eine Bedingung überprüfen wird eine \mintinline{java}{for}-Schleife i.d.R. dazu genutzt um Werte einer bestimmten (Zahlen-)Menge zu durchlaufen.

\mintedJava{Loops.java}{Schleifen in Java}{loopsJava}

COBOL nutzt für alle Schleifen das \mintinline{cobolfree}{PERFORM}-Schlüsselwort. In Verbindung mit weiteren Statements entstehen so unterschiedliche Schleifentypen. \autoref{loopsCOBOL} beschreibt die wichtigsten davon. Eine bedingte Schleifenausführung lässt sich mithilfe des \mintinline{cobolfree}{UNTIL}-Schlüsselworts und einer nachfolgenden Bedingung erreichen. Eine Zählschleife, entsprechend eines \mintinline{java}{for} in Java, kann durch \mintinline{cobolfree}{VARYING}, \mintinline{cobolfree}{FROM} und \mintinline{cobolfree}{BY} konstruiert werden. Jede Schleife kann zusätzlich durch die Angabe von \mintinline{cobolfree}{WITH TEST AFTER} von einer kopfgesteuerten zu einer fußgesteuerten Schleife gemacht werden, d.h. die Bedingung wird nach einem Schleifendurchlauf geprüft und nicht davor.

\mintedCobol{LOOP-EXAMPLE.cbl}{Schleifen in COBOL}{loopsCOBOL}

\subsection{Weitere Schlüsselwörter}

Weitere Schlüsselwörter die den Kontrollfluß -- vor allem im Zusammenhang mit Verzeigungen und Schleifen -- in Java steuern können sind außerdem \mintinline{java}{break}, \mintinline{java}{continue} und \mintinline{java}{goto}. Zu beachten ist dabei, dass das \mintinline{java}{goto}-Schlüsselwort zwar im Sprachstandard noch definiert ist, jedoch in keiner gängigen JVM implementiert ist. Die Verwendung führt zu Fehlern beim Kompilieren. In \autoref{javaBreakContinue} finden sich beispielhafte Verwendungen der beiden anderen Schlüsselwörter.

\java{BreakContinueExample.java}
\sepCodeAndOutputCheck
\begin{shellwindow}
$ javac BreakContinueExample.java 
$ java BreakContinueExample
== break example == 
(0)(1)
== continue example == 
(0)(1)(2)(8)(9)
\end{shellwindow}
\mintedCaption{Beispiele für die Verwendung von break und continue in Java}{javaBreakContinue}

Ein einfaches \mintinline{java}{break} sorgt wie gezeigt dafür, dass die direkt umfassende Schleife verlassen wird. Auch ein simples \mintinline{java}{continue} hat Auswirkungen auf die direkt beinhaltende Schleife. So sorgt es dafür, dass der aktuelle Schleifendurchlauf abgebrochen und mit dem nächsten fortgefahren wird. \autoref{mehrfachverzweigungen} zeigt eine weitere Verwendung des \mintinline{java}{break}-Statements. Deutlich unüblicher -- jedoch nicht weniger relevant -- ist der Gebrauch eines Labels in Java. Dieses Label kann in der Verbindung mit einer \mintinline{java}{break}- oder \mintinline{java}{continue}-Anweisung genutzt werden, um mehrere umfassende Schleifen verlassen bzw. um mit dem nächsten Schleifendurchlauf einer weiter außen befindlichen Schleife fortgefahren zu werden. Die Anweisung betrifft dabei die Schleife, welche das Label trägt. 

In COBOL ist ebenfalls das Schlüsselwort \mintinline{cobolfree}{CONTINUE} vorhanden. Allerdings ist hierbei Vorsicht geboten, da dieses abweichende Bedeutung vom gleichnamigen Java-Schlüsselwort hat. Während in Java, wie erwähnt, zum nächsten Schleifendurchlauf gesprungen werden kann, entspricht dieses Schlüsselwort in COBOL lediglich einer Anweisung bei der nichts ausgeführt wird. Dies ist in der Praxis häufig zu beobachten, um z.B. Verzeigungsteile leer zu lassen ohne die Bedingung negieren zu müssen.

Neben diesem ist \mintinline{cobolfree}{NEXT SENTENCE} ist ein Schlüsselwort das häufig in älterem Code zu finden sei, wie Herr Lamperstorfer bestätigte. Dieses kann dazu genutzt werden, um den aktuellen Sentence zu verlassen und mit der Anweisung die darauf folgt fortzufahren. Zu beobachten sei die Verwendung auch häufig zur Negation einer Bedingung, indem der \mintinline{cobolfree}{IF}-Zweig lediglich dieses Statement enthält und der \mintinline{cobolfree}{ELSE}-Zweig die Logik bei nichtzutreffen der Bedingung enthält. Diese Konstrukte sollten jedoch vermieden werden und durch ein einfach Negieren mit \mintinline{cobolfree}{NOT} geschrieben bzw. ersetzt werden. Aus Gründen der Unübersichtlichkeit ist dieses Schlüsselwort in GnuCOBOL standardmäßig verboten. 

Seltener zu finden ist dagegen die \mintinline{cobolfree}{EXIT PERFORM}-Anweisung. Diese kann innerhalb von Schleifen dazu genutzt werden, um wie ein \mintinline{java}{break} die Schleife zu verlassen oder durch \mintinline{cobolfree}{EXIT PERFORM CYCLE} wie ein \mintinline{java}{continue} in Java mit dem nächten Schleifendurchlauf fortzufahren. Dies soll \autoref{exitPerform} verdeutlichen.

\cobol{EXIT-PERFORM.cbl}
\sepCodeAndOutputCheck
\begin{shellwindow}
00
10
\end{shellwindow}
\mintedCaption{\mintinline{cobolfree}{EXIT PERFORM} in COBOL}{exitPerform}

An dieser Stelle sei ausdrücklich erwähnt, dass die Verwendung des \mintinline{cobolfree}{GO TO}\index{GO TO}-Befehls -- abgesehen von oben genanntem Einsatz als \textit{return}-Ersatz innerhalb einer Section -- in COBOL unterlassen werden sollte, oftmals sogar durch projekt- oder unternehmensspezifische Vorgaben verboten ist, da ansonsten sehr schwer verständlicher und wartbarer Code entstehen kann. Leider findet man sich in der Praxis oftmals mit Code konfrontiert, der \mintinline{cobolfree}{GO TO}-Befehle zur Steuerung des Ablaufs verwendet. Sogar Schleifenkonstrukte sind in älteren Programmen oft damit realisiert, worauf Herr Streit hinwies.

\subsection{Ausnahmebehandlung}

In modernen Sprachen sind Ausnahmebehandlungsmechanismen vorhanden, um die Steuerung des Kontrollflußes klar von der Fehlerbehandlung zu trennen. So wird zum einen eine übersichtlichere Implementierung erlaubt, aber auch erreicht, dass bereits der Compiler auf Fehler hinweisen kann die bei der Ausführung auftreten können bzw. gänzlich das kompilieren bei ungenügender Fehlerbehandlung verweigert.

Java bietet dabei das Konzept der \mintinline{java}{Exception}s. Diese lassen sich in sogenannte \textit{checked} und \textit{unchecked}-\mintinline{java}{Exception}s unterteilen. Während \textit{checked}-\mintinline{java}{Exception} stets einer ausreichenden Fehlerbehandlung im Code bedürfen und ansonsten zu Fehlern des Kompiliervorgangs führen, können \textit{unchecked}-\mintinline{java}{Exception}s unbehandelt gelassen werden. Von der genauen Verwendungserklärung sei an dieser Stelle abgesehen und lediglich auf weiterführende Literatur wie \citeWithTitle{byrne_java_2009-1} von \citeauthor{byrne_java_2009-1} verwiesen.

COBOL bietet zur generellen Ausnahmebehandlung keine Methodik. Fehlerfälle müssen über Variablenwerte signalisiert, geprüft und entsprechend behandelt werden. Herr Streit wies darauf hin, dass eine ungenügende Prüfung hierbei zum kompletten Absturz des Programms führen kann. Jedoch ist es möglich vordefinierte Fehler bei Berechnungen oder String-Zuweisungen abzufangen und darauf zu reagieren wie \autoref{exceptionsCobol} zeigt. Dazu können \mintinline{cobolfree}{ON SIZE ERROR} und \mintinline{cobolfree}{ON OVERFLOW} genutzt werden.

\mintedCobol{ON-SIZE-ERROR.cbl}{Rudimentäre Fehlerbehandlung in COBOL}{exceptionsCobol}

\subsection{Nebenläufigkeit}

Als letzter wichtiger Punkt muss an dieser Stelle erwähnt werden, dass es in Java möglich und auch üblich ist, Programme nebenläufig zu entwickeln. Das heißt mehrere Threads arbeiten parallel und führen Verarbeitungen -- je nach Hardware nur scheinbar -- gleichzeitig aus. Dabei muss der Entwickler auf die Synchronisation von gemeinsam genutzten Speicherbereichen achten, um gültige Datenen zu gewehrleisten. Diese Nebenläufige Programmierung birgt zwar ein gewisses Fehlerpotential bei der Implementierung, sorgt jedoch dafür, dass Logik tendenziell effizienter ausgeführt wird.

In COBOL ist diese nebenläufige Ausführung nicht möglich. Ein COBOL-Programm führt Verarbeitungsschritte stets sequenziell aus und erlaubt keine parallelen Ausführungen. Über einen Transaktionsmonitor ist es jedoch teilweise möglich, dass verschiedene Programme gleichzeitig ausgeführt werden. Jedoch haben diese keine Kenntnis von anderen ausgeführten Programmen. Teilweise können verschiedene Programme auch die gleichen Speicherbereiche reservieren und so quasi miteinander arbeiten. Jedoch gibt es in COBOL keine Möglichkeit zur Synchronisation, weshalb dieses Vorgehen nur sehr selten beobachtet werden kann. Bei einem Transactionsmonitor handelt es sich um eine Art Middleware, vergleichbar zu Application-Servern in Java, welche Anfragen entgegennimmt, dafür sorgt, dass Ressourcen geöffnet und aufgeräumt werden, auf Hostsystemen Terminal-Masken zur Verfügung stellt und wie erwähnt entscheidet wie viele und welche Programme parallel ausgeführt werden. Ein Beispiel hierfür ist das \textit{Customer Information Control System} kurz \textit{CICS}. Um aus einem COBOL-Programm Teile des Transaktionsmonitor aufzurufen gibt es Befehle wie \mintinline{cobolfree}{EXEC CICS}. 