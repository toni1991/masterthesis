\section{Modularisierung, Wiederverwendbarkeit und Variabilität}\label{wiederverwendbarkeit}
\todo[inline,color=red]{3.3 Storyline}
Sehr wichtige Punkte bei der Entwicklung von betrieblichen Informationssystemen sind die Modularisierung und Wiederverwendbarkeit. Um ein System für die Zukunft wart- und erweiterbar zu machen ist eine gewisse Modularisierung anzustreben. Code muss somit nicht mehrmals geschrieben werden, was auch das spätere Einarbeiten in ein Projekt erleichtert, da der Projektumfang deutlich verringert werden kann. 

Zudem ist, sei es um \zB verschiedene Mandanten, Tarife oder Sparten abzubilden, die im Grunde selbige Logik beinhalten, in betrieblichen Informationssystemen häufig eine gewisse Variabilität gefordert. Auch diese kann durch Wiederverwendbarkeit und Modularisierung stark begünstigt werden.

\subsection*{Java}
Java ist eine hoch modulare Sprache. Alleine objektorientierte Paradigmen wie Kapselung, Polymorphie oder Aggregation/Komposition sorgen dafür, dass Code in hohem Maße wiederverwendet werden kann. Dabei ist vor allem die Gliederung in Klassen und Funktionen (siehe \autoref{sec:functionsAndReturnValues}) ausschlaggebend. Des weiteren können Bibliotheken als Java-Archive (kurz \jav{jar} genannt) dis­tri­bu­ie­rt und in anderen Projekten wiederverwendet werden. Dieses Konzept nutzt auch die Programmiersprache an sich bereits in hohem Maße aus und so werden viele Funktionalitäten über Packages (siehe \autoref{sec:structure}) bereitgestellt. Die am häufigsten gebrauchten Bibliotheken sind dabei \jav{java.util}, welche grundlegende Datenstrukturen wie \zB Listen (siehe \autoref{lists}) bereitstellt, \jav{java.io}, die Datenein- und -ausgabe ermöglicht und allen voran \jav{java.lang}, welche -- wie der Name bereits andeutet -- Ergänzungen zu programmiersprachlichen Mitteln liefert. 

Durch diese praktischen Modularisierungsmöglichkeiten ist es in Java auch gut möglich, Variabilität zu erreichen. So kann bestehende Logik wiederverwendet oder beispielsweise durch Vererbung minimal angepasst und nachträglich erweitert werden und sorgt dafür, dass Wartungen am System, die sich auf Erweiterungen des Umfangs beziehen -- \zB das Einführen eines neuen Tarifs -- mit verhältnismäßig geringem Aufwand umgesetzt werden können.

Ein weiterer Punkt, der Java dazu verhilft, dass Programme wiederverwendet werden können ist die Tatsache, dass Java-Code in plattformunabhängigen Byte-Code übersetzt wird. Die Java-Virtual-Machine (\textit{JVM}) führt dann diesen Byte-Code aus und sorgt so dafür, dass bereits kompilierte Programme auf allen Systemen mit JVM ausführbar sind und so weiterverteilt werden können, ohne neu kompiliert werden zu müssen. Diese JVM wiederum ist ein plattformabhängiges System, welches jedoch für -- nahezu -- alle gängigen Systeme und Plattformen verfügbar ist.

\subsection*{COBOL}
Im Gegensatz zu Java lässt COBOL ein Modularisierungskonzept vermissen. Wie in \autoref{sec:functionsAndReturnValues} nachzulesen ist, fehlen grundlegende Spracheigenschaften, um die Wiederverwendbarkeit von Code sicherzustellen. 

Wie ein Herr Lamperstorfer betonte, sieht man daher in der Praxis oftmals Code-Blöcke, die ein und die selbe Logik abbilden, aber durch die Verwendung von anderen Daten nochmals im Copy-Paste-Stil in den Code integriert wurden. Das sorgt für ein hohes Maß an Redundanz. Um diese Redundanz zu vermeiden, werden aber auch gängigerweise Datenstrukturen für mehr als nur einen Zweck im Programm \quotes{missbraucht}. Darunter leidet natürlich die Les- und Wartbarkeit von COBOL-Code sehr, da häufig nicht klar ist, welche Daten in welchem Kontext wie verwendet werden. Zu diesem Thema sei auf \autoref{affixCOBOL} verwiesen.

In COBOL kann Variabilität im Vergleich zu Java nur sehr schwer erreicht werden. Code muss oftmals in hohem Maße kopiert werden, um ähnliche Funktionalität abzubilden und so fallen Anpassungen in diesem Bereich unverhältnismäßig groß aus.

Auch ein Bibliothekskonzept ist in COBOL nicht vorhanden. So werden Programme und aufgerufene Unterprogramme beim Kompilieren statisch zu einer ausführbaren Einheit gelinkt. Um dieses Verhalten zumindest soweit zu beeinflussen, dass dynamisch geladene Unterprogramme entstehen, kann als \quotes{Trick} eine Variable eingeführt werden, welche den Namen des Unterprogramms enthält. Wird nun das Programm aufgerufen, welches in dieser Variable und nicht in einer festen Zeichkette definiert ist, nimmt der Compiler an, dass das geladene Unterprogramm variieren kann -- auch wenn der Inhalt der Variablen nicht verändert wird -- und vermeidet so ein statisches Linken.

Zwar unterstützt COBOL in neueren Standards und Compilern eine objektorientierte Entwickung, jedoch ist diese Spracherweiterung in der Praxis irrelevant. Die meisten gängigen Systeme, auf denen COBOL Programme betrieben werden, verfügen nicht über derartig neue Compiler und auch bei der Verwendung merkt man, dass diese Konzepte nachträglich hinzugefügt wurden und eigentlich nicht Bestandteil der Sprache sind. Hat man das Glück, ein System mit einem kompatiblen Compiler zu haben, so bleibt als weiterer Stolperstein der Fakt, dass die ohnehin raren COBOL-Entwickler in der Verwendung objektorientierter Konzepte nicht firm sind. Daher wird diese Spracherweiterung in der vorliegenden Arbeit nicht behandelt. 