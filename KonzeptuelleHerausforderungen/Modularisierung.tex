\section{Modularisierung, Wiederverwendbarkeit und Variabilität}\label{wiederverwendbarkeit}

Weitere wichtige Punkte bei der Entwicklung von betrieblichen Informationssystemen sind die Modularisierung und Wiederverwendbarkeit. Um ein System für die Zukunft wart- und erweiterbar zu machen ist eine gewisse Modularisierung anzustreben. Code muss somit nicht mehrmals geschrieben werden, was auch das spätere Einarbeiten in ein Projekt erleichtert, da der Projektumfang deutlich verringert werden kann. 

Zudem ist, sei es um \zB verschiedene Mandanten, Tarife oder Sparten abzubilden, die im Grunde selbige Logik beinhalten, in betrieblichen Informationssystemen häufig eine gewisse Variabilität gefordert. Auch diese kann durch Wiederverwendbarkeit und Modularisierung stark begünstigt werden.

\subsection*{Java}
Java ist eine hoch modulare Sprache. Objektorientierte Paradigmen wie Kapselung, Polymorphie oder Aggregation/Komposition tragen dazu bei, dass Code wiederverwendet werden kann. Dabei ist vor allem die Gliederung in Klassen und Methoden, wie Funktionen (siehe \autoref{sec:functionsAndReturnValues}) in Java gängigerweise genannte werden, ausschlaggebend. Des weiteren können Bibliotheken als Java-Archive (kurz \jav{jar} genannt) dis­tri­bu­ie­rt und in anderen Projekten wiederverwendet werden. Dieses Konzept nutzt auch die Programmiersprache aus und stellt viele Funktionalitäten über Packages (siehe \autoref{sec:structure}) bereit. Die am häufigsten gebrauchten Bibliotheken sind dabei \jav{java.util}, welche grundlegende Datenstrukturen wie \zB Listen (siehe \autoref{lists}) bereitstellt, \jav{java.io}, die Daten-Ein- und Ausgabe ermöglicht und allen voran \jav{java.lang}, mit -- wie der Name bereits andeutet -- Ergänzungen zu programmiersprachlichen Mitteln. 

Diese Modularisierungsmöglichkeiten sorgen auch dafür, dass Java-Code variabel eingesetzt und bestehende Logik wiederverwendet oder beispielsweise durch Vererbung minimal angepasst und nachträglich erweitert werden kann und führt dazu, dass Wartungen an Systemen, die sich auf Erweiterungen des Umfangs beziehen -- \zB das Einführen eines neuen Tarifs -- mit verhältnismäßig geringem Aufwand umgesetzt werden können.

Ein weiterer Punkt, der Java-Code wiederverwendbar macht ist die Tatsache, dass dieser in plattformunabhängigen Byte-Code übersetzt wird. Die Java-Virtual-Machine (\textit{JVM}) führt dann diesen Byte-Code aus und sorgt so dafür, dass bereits kompilierte Programme auf allen Systemen mit JVM ausführbar sind und weiterverteilt werden können, ohne neu kompiliert werden zu müssen.

\subsection*{COBOL}
Im Gegensatz zu Java lässt COBOL ein weitreichendes Modularisierungskonzept vermissen. Wie in \autoref{sec:functionsAndReturnValues} nachzulesen ist, fehlen grundlegende Spracheigenschaften, um die Wiederverwendbarkeit von Code sicherzustellen. 

Der typische Ansatz in COBOL ist Funktionalität über Schlüsselwörter bereitzustellen. Allerdings stößt dies unweigerlich an Grenzen, da logischerweise nicht jeder Anwendungsfall als Teil der Sprache implementiert werden kann. Die Sprache bietet also grundsätzlich mehr Funktionalität durch Schlüsselwörter als Java, lässt sich im Gegensatz dazu aber schwerer erweitern. 

Möglich wird dies beispielsweise durch Unterprogramme, die Logik und Daten kapseln und so wiederverwendbar machen. Eine genaue Erläuterung folgt in \autoref{sec:functionsAndReturnValues}. Auch denkbar sind sogenannte Copybooks. Dabei handelt es sich um ein ähnliches Konzept wie Headerdateien in C++, also Dateien, deren Inhalt durch den Compiler vor dem Übersetzen an andere Stellen kopiert wird. Diese werden in \autoref{copy} näher beschrieben.

Diese Konzepte sind jedoch nur begrenzt für die generelle Wiederverwendung von Code geeignet. Wie Herr Lamperstorfer betonte, sieht man daher in der Praxis oftmals Code-Blöcke, die ein und die selbe Logik abbilden, aber durch die Verwendung von anderen Daten nochmals im Copy-Paste-Stil in den Code integriert werden, was für viel Redundanz sorgt. 

Wie in \autoref{verlaesslichkeit} beschrieben findet man diesen Copy-Paste-Stil, wegen fehlender oder teurer Möglichkeiten zu testen. Weiter merkte Herr Lamperstorfer an, dass es womöglich an der fehlenden Erfahrung und Ausbildung der Entwickler lag, dass solche Vorgehensweisen häufig verwendet wurden. Außerdem sei der Wartungsaufwand zur Entstehungszeit vieler bestehender Systeme nicht in dem heute erforderlichen Ausmaß abzusehen gewesen.

Um diese Redundanzen zu vermeiden, werden teilweise Datenstrukturen für mehr als nur einen Zweck im Programm \quotes{missbraucht}. Darunter leidet die Les- und Wartbarkeit von COBOL-Code sehr, da häufig nicht klar ist, welche Daten in welchem Kontext wie verwendet werden. Zu diesem Thema sei auf \autoref{affixCOBOL} verwiesen.

Dies sorgt auch dafür, dass COBOL wenig Variabilität im Vergleich zu Java bietet. Code muss oftmals kopiert werden, um ähnliche Funktionalität abzubilden und so fallen Anpassungen in diesem Bereich unverhältnismäßig groß aus.

Auch ein Bibliothekskonzept ist in COBOL nicht vorhanden. So werden Programme und aufgerufene Unterprogramme beim Kompilieren statisch zu einer ausführbaren Einheit gelinkt. Um dieses Verhalten zumindest soweit zu beeinflussen, dass dynamisch geladene Unterprogramme entstehen, kann als \quotes{Trick} eine Variable eingeführt werden, welche den Namen des Unterprogramms enthält. Wird nun das Programm aufgerufen, welches in dieser Variable und nicht in einer festen Zeichenkette definiert ist, nimmt der Compiler an, dass das geladene Unterprogramm variieren kann -- auch wenn der Inhalt der Variablen nicht verändert wird -- und vermeidet so ein statisches Linken. Damit lässt sich erreichen, dass nur Teile von Programmen bei Änderungen neu übersetzt werden müssen.

Zwar unterstützt COBOL in neueren Standards eine objektorientierte Entwicklung, durch die Konzepte zur Modularisierung und Wiederverwendung bereitgestellt werden, jedoch ist diese Spracherweiterung in der Praxis irrelevant. Die meisten gängigen Systeme, auf denen COBOL Programme betrieben werden, verfügen nicht über derartig neue Compiler und auch bei der Verwendung merkt man, dass diese Konzepte nachträglich hinzugefügt wurden und eigentlich nicht Bestandteil der Sprache sind. Hat man das Glück, ein System mit einem kompatiblen Compiler zu haben, so bleibt als weiterer Stolperstein der Fakt, dass die ohnehin raren COBOL-Entwickler in der Verwendung objektorientierter Konzepte nicht firm sind. Daher wird diese Spracherweiterung in der vorliegenden Arbeit nicht behandelt. 