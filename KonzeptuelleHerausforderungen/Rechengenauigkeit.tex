\section{Rechengenauigkeit}
Vorallem in betrieblichen Informationssystemen, die oftmals an bestimmten Stellen Geldbeträge durch eine gewisse Anzahl von Rechenschritten errechnen sollen, ist es unerlässlich einen Blick auf die Rechengenauigkeit des Systems und der verwendeten Sprachen zu werfen.

\subsection*{Rechengenauigkeit in Java}
Java verwendet zur Speicherung von Fließkommazahlen, wie viele andere moderne Programmiersprachen, den \textit{IEEE 754}-Standard. Ohne näher auf diesen eingehen zu wollen, legt dieser einen Algorithmus fest, mit dessen Hilfe Variablen in einem Speicherbereich repräsentiert werden. Dieser Speicherbereich kann sich je nach Datentyp und Programmiersprache unterscheiden, ist jedoch an sich stets von fester Größe. Daher ist es nicht möglich beliebig genaue Werte abzubilden. 

\java{PrecisionExample.java}
\sepCodeAndOutputCheck
\begin{shellwindow}
$ javac PrecisionExample.java 
$ java PrecisionExample
Double addition: 199999.45
Float addition: 199999.44
BigDecimal addition: 199999.45
\end{shellwindow}
\mintedCaption{Addition von float und double Variablen in Java}{floatDoubleJava}

\autoref{floatDoubleJava} zeigt das bereits anhand eines sehr einfachen Beispiels. Bereits die Addition von zwei Zahlen mit einer bzw. zwei Dezimalstellen, welche zugegebenermaßen bewusst so gewählt wurden, legt die Problematik offen. So unterscheiden sich die Ergebnisse der Berechnung je nach Datentyp, was auf die Abbildung der Zahlen im Speicher zurückzuführen ist. Um Sicherheit bei der Berechnung zu erhalten ist es stets nötig den Datentyp \mintinline{java}{BigDecimal}, mitsamt des damit verbundenen Speicher- und Laufzeit-Overheads, wie im letzten Teil des Beispiels gezeigt, zu verwenden. Wichtig hierbei ist, dass die Definition wenn möglich über den Konstruktor erfolgt, der eine String-Repräsentation eines Wertes erhält. Andere Konstruktoren wie z.B. \mintinline{java}{BigDecimal(double)} können zu Problemen führen, da der übergebene Wert durch die Speicherung als z.B. \mintinline{java}{double} bereits an Genauigkeit verlieren kann.

\subsection*{Rechengenauigkeit in COBOL}
Wie später in \autoref{variables} noch genauer ausgeführt ist der Entwickler und nicht die Sprache in COBOL dafür zuständig genau festzulegen, wie viele Dezimalstellen eine Variable speichern soll. Diese Eigenschaft in Verbindung mit der Speicherrepräsentation der Daten in COBOL führt zu einer praktisch absolut exakten Genauigkeit. %COBOL speichert dabei Daten im sogennanten \textit{BCD}-Code (Binary Coded Decimals) \todo[inline]{https://www.bernd-leitenberger.de/genauigkeit-von-computern.shtml -> Weitere Quelle!} ab. 
Jedes Zeichen wird in COBOL separat gespeichert. Dies sorgt neben höherem Speicherbedarf, jedoch auch dafür, dass sofern Grundrechenarten für eine Ziffer implementiert sind, beliebig lange Ziffernfolgen nach dem gleichen Schema verarbeitet werden können. Die Ergebnisse werden dabei wieder auch zeichenweise gespeichert und lassen so keine Rundungsfehler oder Fehler aufgrund von unzureichendem Speicherplatz zur Abbildung zu.