\section{Jonathan Streit}
\toni{Ich habe angefangen die ersten Kapitel des Buches durchzuarbeiten. Allerdings ist dort viel theoretisches und wenig wirklicher Einstieg in COBOL. Ich habe mir mal den Compiler installiert und Hallo-Welt-Beispiele versucht.}
\jona{Fangen wir vielleicht mit dem ausführbaren Code an. Du hast ja diese vier DIVISIONs. Alles ab PROCEDURE DIVISION ist ausführbarer Code. Innerhalb einer PROCEDURE DIVISION hast du diese SECTIONS. Bei einer SECTION könnte man grob sagen, es ist etwas ähnliches wie eine Prozedur oder Methode, vom Granularitätsgrad her. Mit dem wichtigen Unterschied, dass du der SECTION keine lokalen Parameter geben kannst. Eigentlich gar keine Parameter und keine lokalen Variablen und keinen Rückgabewert. Es gibt also keine Funktionen im eigentlichen Sinne. Was natürlich ein gigantisches Problem ist, wenn du größere Programme schreibst. Man sieht auch immer wieder, dass SECTIONS quasi kopiert werden, weil sie die gleiche Operation auf einer anderen Datenstruktur nochmal machen sollen. Oder das andere Muster ist, dass man eine Variable hat, die quasi Parameter spielt. Dann wird da etwas rein-gemoved, dann wird die SECTION gerufen und dann gibt es zum Beispiel noch eine andere Variable, die den return-Wert der SECTION liefert.}
\toni{Ist es dann gängige Praxis diese zu kopieren und auf andere Datenstrukturen anzuwenden, oder gibt es Möglichkeiten das zu umgehen?}
\jona{Das ist das, was man oft sieht und was sich tatsächlich nicht zu 100 Prozent vermeiden lässt, weil dort einfach ein Sprachmittel fehlt. Was aus meiner Sicht eine gute best-practice ist, wenn man lesbaren COBOL-Code schreiben will: Variablen, die für dieses SECTION Parameter, lokale Variable oder Rückgabewert spielen sollen, einen geeigneten Präfix zu verpassen, der deutlich macht, wo dieses Variablen dazugehören. Bei vielen Firmen ist es zum Beispiel üblich, dass man die SECTION-Namen mit einer Nummer am Anfang versieht. Zum Beispiel ``P350'' und dann kommt der eigentliche Name. Dann kann man das ``P350'' als Präfix vor alle Variablen kleben, die nur für diese SECTION da sind. Das hilft zu verstehen, was einen Zustand zwischen einzelnen Aufrufen transportiert. Sonst passiert es nämlich gerne, dass es eine Variable gibt, die ``W01-irgendwas'' heißt und verschiedenen Zwecken dient, weil sie praktischer Weise schon da war. Es ist sehr schwer im Nachhinein herauszufinden, ob diese eine zusammenhängende Bedeutung hat oder ob sie einfach an zwei unterschiedlichen Stellen zu zwei unterschiedlichen Zwecken verwendet wird. Das ist tatsächlich ein Pattern, dass man bei der COBOL-Programmierung verbessern kann wenn man das man deutlich macht. Das Konzept des Parameters und lokaler Variablen, ist eigentlich jemandem der aus der Java-Welt kommt sehr geläufig. Was tatsächlich möglich ist, wenn man ein anderes Programm aufruft, dass man diesem Parameter übergibt. Ich bin mir momentan sogar nicht sicher, was den return-Code betrifft und wenn, dann ist das jedoch sehr unüblich. Aber vielleicht gibt das die Sprache sogar her. Auf jeden Fall kannst du Parameter übergeben. Das heißt da hast du durchaus die Möglichkeit ein anderes Programm zu rufen, welches die gleiche Operation auf unterschiedlichen Datenobjekten ausführt, welche alle die gleiche Struktur haben.}
\toni{Ist es dann nicht sinnvoll, Dinge die auf unterschiedlichen Datenobjekten arbeiten dann auch wirklich auszulagern?}
\jona{Ja, das ist in gewisser Weise sinnvoll. Aber der Overhead in COBOL, um ein neues Programm zu erstellen ist vergleichsweise hoch. Wenn man sich den leeren Programmrahmen ansieht, ist dieser schon ein bisschen länger. Und auch das Kompilieren auf einem Host benötigt in diesem Fall einen eigenen Job. Deshalb scheut man das traditioneller Weise eher und schreibt lieber längere Programme. Und man hat auch im Gegensatz zu Java-Klassen, die alle gemeinsame private Methoden oder Datenstrukturen nutzen können, in einem COBOL-Programm genau einen Einstiegspunkt. Das heißt man könnte zwar separate Programme erstellen, diese jedoch nichts gemeinsam haben. Ein Muster, das man auch häufig findet ist, dass es einen Funktionscode gibt, den man dem Programm übergibt. Abhängig davon tut das Programm dann unterschiedliche Dinge. Das ist so ein bisschen das Muster, wie COBOL-Programmierer traditionellerweise damit umgehen. Sie sagen, ich habe mehrer Operationen die gemeinsame Hilfsfunktionen brauchen und gemeinsame Daten haben und diese packe ich zusammen in ein Programm und steuere diese über den Funktionscode. Hat aber natürlich den Nachteil, dass nicht mehr transparent ist, für welchen Funktionscode, welche Parameter von Bedeutung sind.}
\toni{Kann man sich das dann in etwa vorstellen wie die Funktionsübergabe in Python?}
\jona{Nein, mein übergibt einfach ein Integer oder einen Character.}
\toni{Achso, dabei handelt es sich also nur um ein Flag.}
\jona{Ja, das ist einfach nur ein Flag, welches sagt, wenn ich da zum Beispiel eine eins übergebe dann wird ein neues Element hinzugefügt, wenn ich eine zwei übergebe, dann wird ein Element gesucht und wenn ich eine drei übergebe wird eines gelöscht. Das ist durchaus ein beliebtes Mittel. Und was noch dazu kommt ist, dass die Programme nur einen achtstelligen Namen haben. Eine SECTION kann noch einen halbwegs lesbaren Namen haben bei einem Programm wird das schon schwierig. Deshalb sind diese Programme traditionellerweise relativ groß. Aber im Sinne von Wiederverwendung ist es natürlich sinnvoll das aufzuteilen. Mit einer modernen Entwicklungsumgebung ist zumindest das Kompilieren auch nicht mehr so dramatisch. Bei den Übergabeparametern kann man sicherlich noch auf die genaue Semantik verweisen. Der Compiler überprüft allerdings nicht, ob das was, man dem Programm übergibt und das was es erwartet die gleiche Größe oder Struktur hat. Der Compiler betrachtet nur die Anzahl der Parameter. Das heißt, dort kann man auch sehr subtile Fehler reinbekommen. Was häufig gemacht wird ist, dass man diese Parameterobjekte in sogenannte Copy-Strukturen zieht. Das heißt man definiert in der Copy-Struktur die Daten und kann diese dann einmal in dem aufrufenden und einmal in dem aufgerufenen Programm einbinden. Somit hat man eine gewisse Sicherheit und unter Umständen sogar noch die Parameterleiste in der Copy-Struktur, damit man auch dort keine Reihenfolgen-Fehler einbaut. Was natürlich sehr sinnvoll ist, aber wiederum die Möglichkeit nimmt auch mal andere Objekte als Parameter zu übergeben. Das heißt man verwendet zwar die Copy-Struktur, benutzt aber nur einen Teil der Felder die man braucht. Oder man moved dann aus dem Feld, das man eigentlich in seinem Programm hat in dieses Übergabefeld und ruft dann damit das Programm. Daten hin- und herzuschieben ist ein sehr beliebtes Spiel. Eigentlich würde es die Sprach jedoch hergeben zu sagen ``CALL USING'' und dann einfach drei beliebige Variablen anzugeben. Das machen aber tatsächlich viele nicht so rigide, weil sie vermeiden wollen, dass es zu Übergabefehlern kommt. Die Möglichkeit wäre allerdings gegeben.}
\jona{Ein Muster welches einem auch noch oft begegnet: Man kann in COBOL einen Programmaufruf entweder mit der direkten Angabe des Programmnamens machen oder mit Hilfe einer Variable, in der der Programmname steht. Diese Variable hat jedoch oft nie einen anderen Wert als diesen einen Programmnamen. Das wird deshalb gemacht, weil der Linker, der alles zu einem ausführbaren Lademodul zusammenfügt, alles zusammenfügt was statisch angegeben ist. Das heißt aus einem großen System wird ein riesen Lademodul. Wenn ich allerdings einen pseudo-dynamischen Aufruf tätige wird alles erst zur Laufzeit gelinkt. Das ist quasi die Unterscheidung von einer großen Bibliothek (dll) und mehreren kleinen.}
\jona{Ich habe bereits gesagt, dass die SECTIONs quasi mit Prozeduren zu vergleichen sind. Was jedoch auch nicht möglich ist, ist Rekursion. Eine SECTION kann also nicht nocheinmal aufgerufen werden. Bei Programmen geht das. Ein Programm kann mehrfach im Call-Stack sein, eine SECTION nicht.}
\jona{Man kann degenerierten Programmfluß erzeugen, wenn man sich nicht an die SECTION-Grenzen hält. Ein Programm fängt ja quasi immer bei der PROCEDURE DIVISION an und dann folgt typischerweise ein PERFORM auf einzelne SECTIONs und irgendwann gelangt man zu einer Stelle, an der ein STOP RUN oder ähnliches steht und das Programm endet dort. Wenn man kein STOP RUN hat dann wird einfach von oben nach unten der Reihe nach ausgeführt. Unerheblich dabei ist, dass irgendwo eine SECTION beginnt. Er läuft also durch den ersten Block durch, dann folgt die erste SECTION, mit der einfach begonnen wird und läuft solange durch bis er ans Ende gelangt. Wie erwähnt ist das nicht das, was man normalerweise haben möchte oder macht. Der Compiler würde es allerdings hergeben. Genau so kann man mit einem GOTO von einer SECTION in eine andere springen.}
\toni{Also Spaghetticode produzieren.}
\jona{Ja, kann man machen. Ich kann auch ein PERFORM machen, was eigentlich der SECTION Aufruf ist, auf einem PRAGRAPH. Der PARAGRAPH ist sozusagen die nächstkleinere Einheit die einen Namen trägt (Ein Label vorne) und es wird nach diesem PARAGRAPH wieder zurück gesprungen, ohne, dass am Ende ein EXIT steht, im Gegensatz zu einer SECTION. Man kann also sehr fiese Sachen machen. Die allermeisten COBOL-Programme werden allerdings eine Struktur haben, wo eine SECTION auch wirklich mit dem Wort SECTION beginnt und mit einem EXIT endet und das ganze tatsächlich als Prozedur gehandhabt wird. Der Compiler gibt allerdings noch deutlich fiesere Sachen her.}
\toni{Ein STOP RUN steht also am Ende des ganzen Programms?}
\jona{Entweder es steht am Ende der ersten, nichtbenannten, SECTION. Dort wo die PROCEDURE DIVISION endet bzw. wo die erste SECTION beginnt. Manchmal gibt es auch eine End-SECTION die zum Schluss aufgerufen wird, welche dann dieses STOP RUN enthält. Das ist im Grunde jedoch ein ganz normaler Befehl, welcher auch zwischendrin aufgerufen werden könnte.}
\jona{Mit dem GOTO kann ansonsten beliebig Unfug getrieben werden. Das ist hinreichend belegt und inzwischen bei vielen COBOL-Programmierern angekommen, dass das GOTO nicht das Mittel der Wahl ist. Aber vor allem in alten Programmen findet sich das noch, um Schleifen zu bauen. Fies sind natürlich immer GOTOs, die nach oben springen.}
 \jona{Dann gibt es in COBOL die Gemeinheit mit den Punkten. Die Gliederung ist quasi: Man hat SECTIONs und in diesen können PARAGRAPHs stehen. Ein PARAGRAPH hat dabei ein Label. Ein PARAGRAPH ist dabei auch das Sprungziel eines GOTOs. Auf kleinere Einheiten kann nicht gesprungen werden. In einem PARAGRAPH steht dann die SENTENCE. Diese zeichnet sich dadurch aus, dass sie mit einem Punkt endet. } 
\toni{Ist diese SENTENCE auch benannt?}
\jona{Nein, die SENTENCE ist einfach ein Statement. Man kann jedoch in COBOL auch ohne diese Punkte programmieren. Man kann also zum Beispiel ein MOVE X ... machen und einen Punkt dahinter setzen. Man kann aber auch ohne den Punkt mit etwas anderem weiter machen. Wenn man einen Punkt ans Ende stellt dann ist es eine SENTENCE. Das ist dann von Bedeutung, wenn man zum Beispiel ein IF davor setzt, welches nicht mit END-IF endet. Dann gehört alles bis zum nächsten Punkt in den IF-Zweig. Das könnten durchaus mehrere Statements sein. Das ist aus gutem Grund eher verpönt, weil man sich natürlich höllische Semantische Fehler einhandeln kann.}
\toni{Man lässt also die Punkte weg und verwendet ein END-IF?}
\jona{Manche lassen diese Punkte tatsächlich weg, außer bei der PARAGRAPH- und SECTION-Deklaration. Dort müssen sie stehen. Manche machen sie, schreiben den Code allerdings so, dass dieser sich nicht darauf verlässt, dass eine bestimmte Semantik dadurch transportiert wird. Was man machen kann ist ein END-IF verwenden und der Compiler würde die Verwendung eines Punktes bemängeln. Man kann IFs ohne END-IF natürlich auch nicht sinnvoll verschachteln. Manche würden vielleicht hinter das END-IF einen Punkt setzen. Semantik durch die Punkte zu transportieren ist allerdings böse, jedoch mag es sein, dass man auch das in alten Programmen noch findet. Das ist ein wenig wie die Frage in Java ob man geschweifte Klammern bei einem if mit nur einem Statement verwendet oder nicht. Außerdem gibt es ein Statement welches NEXT SENTENCE heißt. Mit dem man zum nächsten SENTENCE springen kann. Das findet man auch manchmal, wenn man die IF-Bedingung nicht negieren will. Dann sagt man IF X = Y THEN NEXT SENTENCE. Ansonsten hat man die normalen Kontrollfluß-Statements. Man hat ein IF man hat ein switch, was in COBOL EVALUATE heißt, man hat Schleifen verschiedenster Arten. Die Schleife fängt mit dem Schlüsselwort PERFORM an. Was idiotisch ist, weil ein PERFORM auch für einen SECTION-Aufruf verwendet wird. Und es gibt ein PERFORM VARYING das ist im Prinzip die for-Schleife. Man kann aber auch ein PERFORM UNTIL machen. Dabei kann man glaube ich die Bedingung vorn oder hinten anstellen. Was auch geht, jedoch seltener gebraucht wird ist ein PERFORM <SECTION> UNTIL, dabei wird die SECTION solange aufgerufen bis die Bedingung erfüllt ist. Sollte man das sehen muss man ein wenig überlegen, da es doch eher selten gebraucht wird. Da gibt es auf jeden Fall Möglichkeiten für Schleifen. In einem EVALUATE  gibt es zum Beispiel auch die Möglichkeit mehrere Bedingungen drinstehen zu haben. Du kannst zum Beispiel ein EVALUATE X ALSO Y haben, dann sagst du wenn 1 ALSO 2. Was man auch manchmal findet ist das EVALUATE TRUE. Dann kann man im WHEN eine Bedingung angeben. Dann wird es quasi umgedreht.}
\toni{Wie wäre dann dort die best-practice?}
\jona{
	Es gibt sehr wenig Situationen in denen ein EVALUATE TRUE Sinn macht. Eventuell nur dann wenn man sagt man will von mehreren Bedingungen die erste auswählen die erfüllt ist. Dann könnte man aber auch ein IF ELSE-IF ELSE... schreiben. Das nimmt sich dann nicht viel. Wichtig ist einfach, dass die Möglichkeit, die mit einem switch gegeben ist auch in COBOL vorhanden ist.

	Was auch wichtig ist: Es gibt in COBOL kein wirkliches Bibliothekkonzept. Oder überhaupt eine Bibliothek an wiederverwendbaren Teilen. Das heißt, alles was man an Logik benutzt ist entweder Bestandteil der Sprache oder man hat es sich selbst geschrieben. Oder es sind irgendwelche Querschnittsprogramm die auf genau dem System auf dem man Entwickelt bereits vorhanden sind. Vielleicht gibt es da ein paar, die bei bestimmten Betriebssystemen immer vorhanden sind. Oder man weiß, das das ADABAS Datenbanksystem immer dieses und jenes hat. Aber so die Möglichkeit, dass man weiß, dass man mit java.util oder java.io riesen Bibliotheken hat, die gibt es nicht. Und aufgrund der fehlenden Wiederverwendung und Objektorientierung wäre das auch gar nicht einfach zu schreiben. Weil man eben nicht einfach etwas generisches Entwickeln kann und einfach beliebige Objekte reinstecken kann. Dazu müsste man erstmal wissen wir groß diese Daten sein werden. Das ist natürlich ein großer Nachteil, wenn man tatsächlich mit großen Systemen zu tun hat. Einfach weil viel neu implementiert werden muss. Und einfach sehr lokal gearbeitet wird. Das ist einfach eine andere Denkweise, als man es aus der moderneren Welt kennt, in der man einfach nachsieht welche Bibliothek man sich ziehen muss. Das ist wichtig zu verstehen, für jemanden der aus der Java-Welt kommt. COBOL hat dadurch jedoch viele Sachen direkt als Schlüsselwörter in der Sprache integriert. Da sieht man jedoch, dass das natürlich trotzdem schnell an seine Grenzen stößt. Man kann natürlich nicht die gesamte JDK in Schlüsselwörter packen.

	Es gibt dann ein paar Gemeinheiten, dass dann abhängig von der Version und des Compilers verschiedene SChlüsselwörter unter Umständen nicht vorhanden sind. In der CONFIGURATION SECITON kann man auch ein paar Flags setzen, die dann bestimmte Funktionalitäten einschalten oder eben nicht. Und man kann festlegen, ob das Komma oder der Punkt als Dezimaltrennzeichen verwendet wird. Was die moderneren Compiler integriert haben ist objektorientiertes COBOL. Das ist jedoch aus meiner Sicht eher Unfug und ich habe das jetzt auch noch nie wirklich gesehen.  Außer vielleicht wenn man eine Brückenfunktion zu Java hat oder so. Also es gibt ja durchaus Runtime dazwischen, mit der man Java- oder C\#-Code aufrufen kann. Und dann holt man sich halt das Objekt das man aufrufen möchte mit rein. Aber ansonsten eignet sich die Syntax einfach nicht, um feingranulare Objekte zu schreiben.

	23:29
}
\toni{Soll ich mir dieses objektorientierte COBOL dann auch ansehen?}
\jona{Ich würde eher reinschreiben, dass es das gibt, jedoch sehr selten verwendet wird und  anstatt das zu verwenden sollte man sich die Gedanken machen, das wirklich in einer objektorientierten Sprache nachzuimplementieren. Also wie gesagt, ich hab es noch nicht sinnvoll im Einsatz gesehen. Und es werden die wenigsten Leute mit COBOL-know-how kennen. Das funktioniert nicht gut, ist sehr Compiler-abhängig. Da eignet sich einfach die Sprach nicht dafür. Es gab zum Beispiel auch die Möglichkeit Programme zu schachteln, was der Versuch war soetwas wie lokale Variablen und Kapselung zu ermöglichen. Es ist jedoch unglaublich schwerfällig wenn man quasi in einem Programm nochmal den kompletten Programmrahmen drinstehen hat. Das habe ich glaube ich auch noch nie gesehen. Dann gibt es neue Schlüsselwörter die zum Beispiel für XML-Parsing verwendet werden. Das ist bei den Schnittstellen interessant. Aber eigentlich ist es ein relativ kläglicher Versuch noch Funktionalität in eine alte Sprache zu bringen. Was auch noch recht interessant ist, dass man oft sieht, dass es für bestimmte Sachen Schlüsselwörter gibt, die recht hilfreich sind. Sobald man jedoch die Möglichkeiten dieses Schlüsselwortes ausgeschöpft hat kommt man ziemlich ins rudern. Was zum Beispiel sehr schwierig ist sind Bit-Operationen. Zu sagen ich möchte jetzt das dritte Bit setzen z.B. Man hat nämlich keine binären Und- und Or-Operationen und muss das dann irgendwie nachbilden. Da wirds dann richtig kniffelig. String-Manipulation ist auch so ein Beispiel. Es gibt schon Befehle um zum Beispiel mehrere Sachen zusammen in einen String hintereinander zu packen oder Befehle um Sachen nach bestimmten Trennzeichen zu trennen. Man kommt jedoch trotzdem schnell an die Grenzen und das führt schnell zu wilden Dingen. Dass zum Beispiel künstlich Trennzeichen eingefügt werden, um sie im nächten Schritt wieder finden zu können. STRING-Befehl, INSPECT-Befehl, UNSTRING-Befehl sind dabei ein paar Beispiele.}

\toni{Was sind denn gängige Datenstrukturen in COBOL?}
\jona{Das ist jetzt das interessante. Ganz grundsätzlich gibt es alphanumerische und numerische. Deklariert wird immer <Variablenname> PIC <Typ> und der Punkt. Wichtig ist, dass in COBOL die Daten-Deklaration immer zugleich die Deklaration des Ausgabeformats. Meistens zumindest. Bei den numerischen Typen legt man also fest wie die interne Repräsentation aussehen soll, also ob es binär gespeichert werden soll oder einfach als String. Wenn man ein PIC X macht ist es zum Beispiel ein einzelner Character. Ein PIC 9(4) wäre eine vierstellige Zahl die als String gespeichert wird. Wir könnten auch allerdings auch ein PIC 9(4)V9(2) PACKED DECIMAL. Dann haben wir 4 Vorkommastellen und zwei Nachkommastellen und das ganze wird als BCD Codierte Zahl gespeichert. Bei dem immer 2 Ziffern in einem Byte landen. Manchmal gibt es auch noch die COMPUTATIONAL, welche meistens jedoch auch PACKED DECIMAL sind. Da hat der Compiler ein wenig die Wahl was er nimmt. Und BINARY gibt es auch. Das würde dann tatsächlich so gespeichert werden wie zum Beispiel ein Integer in Java. Man könnte allerdings auch ein PIC ZZZ9 definieren. Der hat auch vier Stellen, wird dieser allerdings ausgegeben, bekommt dieser Typ keine führenden Nullen. Da gibt es noch weitere Formatierungszeichen. Das ist also eine Kombination aus dem was man mit einem String.format machen würde und der eigentlichen Typdeklaration. COBOL-Leute würden behaupten das sei unglaublich praktische, weil Daten die Verarbeitet werden auch sehr oft ausgegeben werden sollen und man sich dann nicht um irgendwelche komischen Formate kümmern muss. Die Zahl weiß schon wie sie sich ausgeben soll. Man sieht jedoch dadurch auch oft Code der quasi Daten von einer Variable in eine andere MOVEd nur um sie in ein bestimmtes Ausgabeformat zu bringen. Oder man hat multiple Definitionen von einer Variablen mit REDEFINE. Das ist im Prinzip das gleiche wie ein Union in C. Das machen die extrem viel. Da kann man zum Beispiel sowas machen wie ``STR PIC X(4)''. Und dann z.B. ``NUM REDEFINES STR PIC 9(4)'' und dann könnte ich zum Beispiel Fragen ``IF STR NUMERIC -> ADD NUM TO SUMMER'' irgendwas. Das heißt man prüft ob in der String-Repräsentation etwas drinsteht, was wirklich als Zahl interpretierbar ist und greift dann auf den gleichen Speicherbereich zu, jedoch als numerische Repräsentation. Das findet man auch oft. Das heißt vor allem, dass man mit diesen REDEFINES extrem aufpassen muss, wenn man sucht ob und wo eine Variable verwendet wird, weil eben die Variable nicht verwendet wird jedoch der selbe Speicher. Oder, dass man nie eine Zuweisung auf eine Variable sehe, diese jedoch trotzdem einen Wert hat. Das wird wie gesagt sehr exzessiv verwendet. Eben für so Konvertierungen. Es gibt auch noch FILLER, also eine Variable ohne Namen.

Was auch sehr wichtig ist, dass man in COBOL keine benutzerdefinierten Typen hat. Diese Deklarationen muss man deshalb immer wiederholen. Die einzige Möglichkeit die man hat ist diese Daten in ein COPY-Element zu packen, aber dann habe ich auch immer die gleichen Namen. Allerdings gibt es das REPLACING-Keywort, mit dessen Hilfe bei einem COPY Textersetzung gemacht wird. Da könnte man theoretisch sogar Variablen umbenennen, typischerweise würde man hier den Präfix einer Variable verändern. Dies wird jedoch sehr selten verwendet. Und das ist auch nicht so einfach zu durchschauen, weil Variablennamen nicht klar zu finden sind. Dadurch wäre ich damit auch sehr vorsichtig. Aber das wäre quasi eine Möglichkeit um eine Datenstruktur wie eine Adresse mit vier Feldern auch an einer anderen Stelle mit anderem Namen nochmals verwenden zu können.

Nochmals einen Schritt zurück. Es gibt auch Levelnummer bei der Variablendeklaration. Das heißt man schachtelt seine Daten immer. Und da kann man zum einen 37:44 - 38:50
Man kann damit auch auf einer bestimmten Ebene ein Array deklarieren. Man macht ein OCCURS 5 TIMES und alle Felder darunter würden dann 5 mal vorkommen. Das ist das Sprachmittel, um zusammenhängende Strukturen oder einfache Datenklassen abbilden würde. Aber wie gesagt immer mit dem großen Problem, dass das immer wieder deklariert werden muss wenn es gebraucht wird oder in ein COPY-Element gepackt werden muss und man an einen festen Namen gebunden ist oder dabei das REPLACING nutzen muss. Es gibt theoretisch sogar die Möglichkeit zu sagen: ``MOVE C IN XYZ TO V'' wäre etwas ähnliches wie in Java der Punkt. Das wäre also quasi ``V=XYZ.C''. Da kann man also sogar qualifizieren welches du meinst. In 99\% der COBOL-Programme sind diese Namen immer eindeutig und haben ihre Namenskonventionen. Dabei wissen sie zum Beispiel, wenn ein ``COPY TACA'' heißt dann fangen alle Variablen darin mit ``TACA'' an und alle lokalen Variablen die ich mir dazudefiniere fangen irgendwie mit ``W'' an. Dadurch ist quasi sichergestellt, dass Namen eindeutig sind.  40:40 - 41:00 
Das wird jedoch erstaunlich selten genutzt. Aber das ist vielleicht ein feature welches für jemanden der aus der modernen Programmierwelt kommt sehr interessant sein kann. Damit kann man sagen du kannst diese Struktur in ein COPY-Element packen und wiederverwenden, musst sie jedoch immer qualifizieren. }
\toni{Ist das dann nur für einen Einsteiger interessant oder sollte man das in der Praxis auch wirklich verwenden?}
\jona{Es kommt darauf an in welchem Kontext man arbeitet. Für existierende Programme wird man das wenig brauchen, weil es sehr selten verwendet wird. Um es selbst zu schreiben hängt es ein wenig ab. Man arbeitet in der Regel ja an einem existierenden System, bei dem man vielleicht auch nicht den gesamten Stil auf den Kopf stellen will oder darf, aber eigentlich ist es sehr sinnvoll zu verwenden. Vor allem eben für so wiederkehrende Strukturen wie Adressen oder Datum zum Beispiel. Dadurch erreicht man ein wenig Kapselung und Wiederverwendung. Das ist natürlich auch ein großes Wartungsproblem. Beim Datum zum Beispiel, wenn man an das Jahr 2000 denkt. Früher gab es das C für century vielleicht nicht und plötzlich muss man nun an 10000 Stellen im Programm das C einfügen. In der Java Welt würde man einfach die Klasse erweitern. Da hast du in COBOL einfach keine Chance. Deshalb ist das schon eine sehr interessante Geschichte. Oder wir hatten mal einen Kunden, der hatte eine vierstellige Nummer für die Partnerunternehmen und irgendwann war sind einfach die vierstelligen Nummern ausgegangen. Gelöst wurde das dann witzigerweise durch das Zulassen von Buchstaben. Weil so der Speicherbedarf nicht erhöht wurde und sich Datenstrukturen im Speicher nicht verschoben haben. Das ist immer der GAU, weil der Compiler bei einem Programmaufruf nicht überprüft, was das andere Programm an Daten erwartet, kann man Programme unabhängig voneinander kompilieren. So lange man keine Daten dazwischen einfügt sondern nur hinten anhängt oder Speicherbereich umdefiniert, muss das andere Programm nicht neu kompiliert werden. Diese Übergabe funktioniert intern mithilfe eines Pointers. Man kann also Daten von einem Programm an ein anderes Programm übergeben, welches davon ausgeht, dass weniger Daten da sind als tatsächlich und dieses gibt diesen Pointer wiederum weiter an ein weiteres Unterprogramm, welches dann wieder von den zusätzlich Daten weiß. Die gerufenen Programme können durch diese Aufrufe by-reference auch z.B. etwas anhängen. Wenn man aber quasi Variablen in der Mitte einfügt und damit alles verschiebt muss man alles neu kompilieren. Es ist jedoch bei COBOL-Systemen nicht unüblich, dass über Jahre Teile nicht neu kompiliert werden.}
\toni{Welche Gründe hat das? Ist dabei die Laufzeit des Kompilierens ausschlaggebend dafür, dass das nicht gemacht wird?}
\jona{Ja, es würde unter Umständen einen Tag dauern um alles neu zu kompilieren. Aber auch die Rechenzeit auf einem Mainframe ist sehr teuer. Dort wird üblicherweise pro Rechenzeit bezahlt. Zudem ist es einfach sehr unpraktisch. Man hat einen compile-job für jeden Programm und müsste diese einzeln anstoßen. Es ist aber auch die übliche Art und Weise, dass Programme -- das ist ein wichtiger Punkt im Großrechner-Umfeld -- immer einzeln, bzw. einzelne Lademodule, deployed werden. Durch das dynamische Linken ist jedoch ein Programm in der Regel ein Lademodul für sich. Dabei muss man sich meistens manuell, seltener vielleicht durch Werkzeug-Unterstützung, überlegen, was mitkompiliert werden muss, damit die Teile zusammenpassen. Das ist ganz lustig, weil das was derzeit mit den Micro-Services propagiert wird, dort schon seit 50 Jahren gemacht wird. Das hat natürlich den Vorteil, dass man ein Feature mal schnell reinschieben kann, jedoch auch den Nachteil, dass man erst zur Laufzeit feststellt, dass Teile nicht mehr zusammenpassen. Dieses Vorgehen ist jedoch weniger ein Feature der Sprache, als mehr von dem Umfeld.

Die Datendeklarationen kann man natürlich beliebig ausnutzen. Zum Beispiel, dass ein Binary mit einem Character redefiniert wird und man sich dann die Binärwerte herausholt. Das wird teilweise in der Praxis auch wirklich gemacht. Was auch ein wenig gewöhnungsbedürftig ist, dass es für die viert Grundrechenarten eigene Befehle gibt. Und dann gibt es das COMPUTE-Statement. In diesem kann man wirklich dann einen Term aufschreiben. Und Zuweisungen werden eben mit dem MOVE bewerkstelligt. Das ist ein wenig komisch, weil es anders herum funktioniert. Man gibt also an welcher Wert wohin kopiert werden soll. Aber z.B. ein X=Y+1 müsste man bereits mit einem COMPUTE machen. ``ADD Y TO 1 GIVING X'' würde noch gehen. Aber das wäre auch sehr unintuitiv.

Das nächste ist ein Grund dafür weshalb COBOL noch immer so beliebt ist. Man hat eine absolute und vor allem klar festgelegte Präzision auf den Dezimalstellen. Das heißt für alles was mit Geld zu tun hat ist das genau das was man haben möchte. Float und Double in Java sind dafür gänzlich ungeeignet. Weil diese das nicht abbilden können. Es gibt einfach bestimmte Dezimalwerte, die nicht exakt in einem Double dargestellt werden können. Und der Umgang mit einem BigDecimal in Java ist auch sehr umständlich. Vor allem weil dieser Typ in Java auch besonders schlecht gebaut ist. COBOL schneidet Dezimalstellen standardmäßig immer ab, es sei denn man gibt ein ROUNDED an. Es ist aber einfach ganz klar festgelegt, wie viele Nachkommastellen eine Variable hat. C\# zum Beispiel kennt einen Decimal Typen der zumindest schon bequemer zu handhaben ist als der BigDecimal, aber auch das Problem hat, dass er keine festgelegte Anzahl an Nachkommastellen hat. Das ist tatsächlich ein immenser Vorteil von COBOL.

Ansonsten haben wir bereits über Arrays geredet. Man kann also irgendwo ein OCCURS machen. Das Array ist dabei immer mit 1 beginnend indiziert, anders als in Java. Und man kann durch die Stufennummern auch eine Unterstruktur haben die sich durch das OCCURS wiederholt. Also ein Array aus structs sozusagen. Man kann auch mehrdimensionale Arrays definieren. Das funktioniert auch gut. Allerdings haben diese alle immer eine feste Grenze. Es gibt in COBOL keine dynamischen Datenstrukturen. Es gibt keinen Heap und man hat einfach keine Möglichkeit dynamische Datenstrukturen zu bauen. Es gibt Systeme, die dann Betriebssystem-Module aufrufen um sich irgendwie einen unterschiedlich großen Speicherbereich zu holen. Aber das ist sehr sehr selten und auch nur Trickserei. Normalerweise hat man immer festdefinierte Grenzen. Was natürlich auch heißt, dass manchmal Speicherplatz verschwendet wird und dass man in der Wartung immer mal wieder Anpassungen hat, in denen einfach nur die Anzahl der Elemente in einer Datenstruktur erhöht werden soll. Damit stößt man natürlich auch mit anderen interessanten Datenstrukturen an seine Grenzen. Das ist wichtig zu verstehen für einen Java-Programmierer. Ich habe einfach kein ``new''. Das gibt es nicht. Was wiederum ganz interessant ist, ist das definieren eines Array-Indexes mit ``INDEXED BY <ARINDEX>''. Und ich kann dann sagen ``SET <ARINDEX> TO 5'' und dann greife ich auf des 5. Element zu. Diese Indexvariablen sind ein wenig ein eigenes Völkchen. Die kann man nämlich zum Beipiel nicht in Rechenoperationen benutzen. Bei einem SET ist es übrigens genau die andere Reichenfolge wie bei einem MOVE. Was man machen kann ist ein MOVE zwischen einer numerischen Variablen und einem Index. Ich bin mir gar nicht sicher, ob die numerische Variable jedoch ein BINARY sein muss. Und dieser Index gehört fest zu diesem Array. Ich kann den nicht für ein anderes Array benutzen. Auch wenn das auch 5 Elemente hätte. Das kann ganz schön lästig werden. Und es gibt viel Code der einfach nur dafür sorgt Indizes zu kopieren. Das ist allerdings meiner Meinung nach auch nur ein Stück Unwissen. Man kann nämlich durchaus ein BINARY PIC zum indizieren benutzen, zumindest in manchen Dialekten obwohl es total Sinn machen würde. Wenn ich zum Beispiel Strukturen habe die alle nach Monaten indiziert sind, dann habe ich einen Monatsindex und nicht 3 die ich synchron halten muss. Das ist für mich auch wieder eine Lektion für Leute die COBOL ausreizen wollen. Das man halt ein BINARY als Index benutzt. }
\toni{Den müsste ich aber vorher in den Index des Arrays moven oder?}
\jona{Nein, den kann man einfach als Index bei einem Zugriff verwenden. Mit dem BINARY geht es, mit einem normalen nicht. Es mag sein, dass der INDEXED BY Index minimal effizienter ist, aber das ist in den meisten Fällen egal. Da sind die Wartungskosten eigentlich relevanter. Wie gesagt, in dem Code, den wir gerade migrieren sieht man dauernd ``SET INDEX1 TO ÍNDEX2'' und so weiter. Was interessant ist: Man kann zwar mit dem Index keine Rechenoperationen machen, aber zum Beispiel INDEX+1 geht. Wird aber auch erstaunlich wenig verwendet. Oft sieht man ein kopieren des Index, dann ein ``SET INDEX UP BY 1'' vor dem Zugriff und danach wird wieder der Index kopiert. Dabei kann man definitiv effizienter werden. Erlaubt sind dabei nur Plus und Minus mit einer Konstanten. Aber das reicht für viele Sachen schon aus.

Was fehlt sind einfach effizientere Datenstrukturen. Was es gibt ist die Möglichkeit zu sortieren. Also es gibt diesen SORT Befehl. Der ist allerdings ein wenig schwerfällig. Da muss man dann zwei Prozeduren deklarieren, die die Datenelemente liefern. Und die sortierten wieder entgegennehmen. Da wird auch tatsächlich in der Regel eine Betriebssystem-Routine gerufen. Das ist vor allem bei größeren Mengen interessant. Für kleinere Strukturen findet man dann tatsächlich oft den Bubble-Sort. Dieser ist einfach zu implementieren und dadurch, dass man ihn nicht generisch nutzen kann muss er einfach immer wieder neu hingeschrieben werden. Da ist der Bubble-Sort wahrscheinlich noch der günstigste. Alle anderen effizienteren Algorithmen scheitern eigentlich daran, dass ich keine Rekursion habe. Da müsste man schon wirklich tricksen und sich künstlich einen Stack bauen in einem Array, welches nur eine bestimmte Größe haben kann und sich dann irgendwie einen Quick-Sort bauen. Das ist jedoch ziemlich groß. Der SORT Befehl ist schon sehr effizient und dann greift man auf diesen zurück.

Was es auch gibt ist der SEARCH Befehl. Dieser macht normalerweise eine lineare Suche nach einem bestimmten Element. Dieser hat auch eine wilde Syntax, bei der man sagt ``Wenn du etwas findest was passt dann mache folgendes, wenn nicht, dann mach jenes.'' Das liest sich auch nicht schön. Aber im Prinzip macht er eine lineare Suche. Wenn ich ein ``SEARCH ALL'' mache, dann macht er eine binäre Suche. Ist auch ein idiotisches Schlüsselwort. Weil er genau nicht alle durchsucht. Aber das heißt, wenn man eine vorsortierte Datenstruktur hat, kann man damit eine binäre Suche zumindest machen. Damit kommt man dann zumindest auf log(n). Das findet man schon auch in existierenden Programmen immer mal wieder. Für alles andere gibt es eigentlich keine eingebauten Möglichkeiten. Nichtsdestotrotz kann man sich schon etwas ähnliches bauen. Systeme mit größeren Datenmengen, die Performance-kritisch sind und an denen Leute gearbeitet haben die bisschen was von ihren Fach verstanden haben findet man schon auch so Sachen. Man erkennt sie allerdings womöglich nicht sofort, weil den damaligen Entwicklern auch einfach das Vokabular dafür gefehlt hat. Aber z.B. gibt es für eine große unsortierte Menge an Personen habe und man effizient eine Person nach Geburtsdatum wiederfinden möchte dann bauen die sich ein zweites Array auf, welches nach Geburtsdatum sortiert wird und in dem der Index des Elements in dem anderen Array gespeichert wird. Nach dem Prinzip könnte man sich sogar etwas wie eine Hashmap implementieren. Zumindest mit einer einfachen Hash-Funktion, für diesen einen Anwendungsfall. Das lohnt sich durchaus das zu erwähnen, dass man Möglichkeiten hat. Man muss sich halt Gedanken machen wo das wirklich nötig ist, weil man große Datenmengen hat und man muss natürlich die Algorithmen soweit kennen, dass man sie implementieren kann. Aber das ist durchaus ein sehr interessantes Feature, um effizient auf Sachen zugreifen zu können. Man kann sich natürlich alles -- wie ein Set oder eine verkettete Liste -- in diesen fixen Datenstrukturen basteln. Und das wird auch manchmal gemacht. Aber ist in der Regel nicht so bennant. Das ist wichtig zu wissen.

Ansonsten, der Ablauf, das ist jetzt wieder etwas was über COBOL an sich hinaus geht und von der Umgebung kommt. Viele Systeme arbeiten mit einem Pipeline-Mechanismus. Man liest eine Datei, macht irgendetwas mit den Sätzen und zwar einzeln, da natürlich nicht alle in den Speicher passen, und schreibe diese wieder raus. Dann läuft z.B. auf Betriebssystemebene in der Job-Kette ein Sortierprozess der die Daten wieder anders sortiert und dann läuft der nächste der dann vielleicht eine Summenbildung darauf macht. Gerade mit limitierten Speicherressourcen ist das ein sinnvolles Vorgehen und Großrechner sind auch brutal effizient was IO angeht. Trotzdem lohnt es sich manchmal zu hinterfragen was genau das gewünscthe Ergebnis ist. Manchmal ist es nämlich noch sinnvoller auf den Ursprungsdaten zu arbeiten und vielleicht einfach eine größere Datenstruktur vorzuhalten, damit man das gleich in einem Programm machen kann statt in drei. In Summe sind diese Job-Netze nämlich doch ganz schön teuer. Jedes einzelne Programm geht. Diese schubsen gigantisch Daten durch die Gegend und eigentlich interessiert sie nur ein ganz kleiner Ausschnitt. Oder wenn ich Daten in einer relationellen Datenbank habe habe ich natürlich auch schon Möglichkeiten mir Sachen gezielt geben zu lassen.

Man hat die Möglichkeit mit dem EXEC Befehl quasi einen Präprozessor aufzurufen der dann bestimmte Sachen einbindet. In der Regel wird das für EXEC SQL gemacht, es gibt aber auch noch EXEC CICS. Das ist auch so eine Mainframe Sache. Das ist quasi ein Transaktionsmonitor der letzendlich etwas ähnliches macht wie ein Application-Server oder Webcontainer macht. Er nimmt also quasi Serviceaufrufe oder beim Host auch so Terminal-Masken aufrufe entgegen und kümmert sich darum, dass eine Datenbanktransaktion geöffnet wird und das richtige Programm aufgerufen wird. Überlegt sich wie viele parallele Instanzen laufen können und am Ende räumt dieser auch wieder auf. Da gibt es dann manchmal die Notwenigkeit sich in einem Programm Daten davon zu holen und dafür wir dann eine EXEC CICS gemacht, damit der Präprozessor dort Code eingeneriert. In eine EXEC SQL kann man tatsächlich dann SQL hineinschreiben. Das wird in der Regel in den COBOL-Programmen statisch gebunden. Das heißt es ist dann eher unüblich, dass man sich dort mit einem String sein SQL-Statement zusammenbaut. Das sollte wie in Java mit einem Prepared-Statement eigentlich fix sein und man setzt dann einfach Parameter ein.

}
\toni{Das geht dann aber?}
\jona{Ja, sonst würde das ja gar keinen Sinn ergeben. Man kann mit einem Doppelpunkt Variablen des Programms einsetzen und in der Regel holt man sich dann immer einzelne result-Zeilen. Das macht man quasi in einem fetch und dann holt man sich eine Zeile in die Variablen rein. Das schöne daran ist, dass man im Gegensatz zu Java, wie in C\# so language-integrated-queries hat. Das ist echt ganz nett. So kann man bereits zur compile-Zeit überprüfen ob es gültiges SQL ist. Da könnte man jetzt viel zum Datenbankzugriff sagen, aber das ist glaub ich zu viel.}
\toni{Dieser EXEC Aufruf steht dabei dann wo genau? Am Anfang des Programms?}
\jona{Nein, der steht einfach im Ausführbaren Code.

Dateizugriffe kann man auch direkt bewerkstelligen. Da muss man sich dann oben bei den Daten quasi ein bestimmtes File-Muster definieren, also wie die einzelnen Records in einem File aussehen und kann dann Dateioperationen machen.

DISPLAY ist quasi die Konsolenausgabe. Das wird auch zum Logging benutzt. Da denkt natürlich der Java-Programmierer an ein log4j oder ähnliches.

Was auch noch wichtig ist bei den Daten ist, dass es zwei Bereiche in der ``DATA DIVISION'' gibt. Das sind die ``WORKING STORAGE SECTION'' und die ``LOCAL STORAGE SECTION''. Die ``WORKING STORAGE SECTION'' bleibt zwischen mehreren Programmaufrufen erhalten. Da habe ich auch Möglichkeiten mein Programm am Anfang zum Beispiel mit einer bestimmten Suchstruktur zu initialisieren und dann später z.B. mit einem anderen Funktionscode etwas darin suchen. Die ``LOCAL STORAGE SECTION'' wird bei jedem Programmaufruf neu gemacht. Der Unterschied ist glaube ich vielen COBOL-Programmierern auch nicht so bewusst, obwohl relativ interessant und wichtig. Meistens benutzen diese die ``WORKING STORAGE SECTION''. Dann gibt es noch die ``LINKAGE SECTION''. Darin wird definiert, was man als Parameter von dem aufrufenden Programm erwartet. Darin wird kein Speicher alloziert sondern definiert wie Parameter aussehen die man als Pointer übergeben bekommt.

Was natürlich so ein Muster ist in COBOL, die Programmnamen haben in der Regel sowieso nur 8 Zeichen, dass Variablennamen, dadurch, dass versucht wird diese auch global eindeutig zu halten und diese auch nur 30 oder 32 Zeichen lang sein dürfen, oftmals ganz schön kryptisch. Man hat im klassischen COBOL ja auch nur die Spalten 8-72 zur Verfügung. Das heißt, wenn man mit langen Variablennamen arbeitet muss man auch oft die Zeilen umbrechen. Da scheuen sich viele Leute davor und deshalb sind die Namen relativ kryptisch. Um so wichtiger ist es deshalb dort in einem Kommentar kenntlich zu machen was gemeint ist. Ich würde auch empfehlen wenn man jetzt modern COBOL programmiert eher lange Namen zu verwenden. Aus denen man etwas herauslesen kann. Wir arbeiten ja in der Regel nicht mehr mit einem Editor der in einem Terminal-Emulator läuft und haben dann auch bessere Möglichkeiten Zeilenumbrüche zu spendieren. Da kommt natürlich ein großer Teil dieser Unlesbarkeit von COBOL-Code her, weil Variablennamen einfach übermäßig abgekürzt werden. Möglichst sprechende Namen zu verwenden, ist das eine. Sich an Schemata zu halten bzw. diese zu verstehen ist natürlich das andere. Initial haben sich die Leute in der Regel natürlich schon Gedanken gemacht wie man Namensmuster wählt. Man kann das natürlich auch weitertreiben mit diesen ``lokalen Variablen''. Was COBOL Programmierer oft nicht auf dem Schirm haben, was aber finde ich sehr wichtig ist, ist zumindest in Kommentaren klar zu machen, welchen Gültigkeitsbereich Variablen haben und wie der Zustandsraum in dem Programm aussieht. Das ist einfach sehr schwer im Nachhinein zu verstehen, ob eine Variable nun eine Semantik von A nach B transportiert oder ob sie einfach nur frisch verwendet wird. Das ist definiv eine Sache, wo man sehr viel verständlicheren Code schreiben kann, wenn man das einfach klar macht. Sei es durch einen Kommentar oder durch die Namensgebung.

Ansonten, wenn wir schon bei Kommmentaren sind: Ein Muster, welches man in alten COBOL-Programmen oft findet sind Relikte aus der Zeit bevor es Versionsverwaltungsprogramme gab. Das heißt ich habe diese Spalten 73-80 für irgendwelchen Inhalt und viele schreiben dort das letzte Änderungsdatum, -kürzel oder z.B. eine Ticketnummer hinein. Das ist jedoch natürlich eine Versionsverwaltung für Arme. Eigentlich sollte man natürlich versuchen eine moderne Versionsverwaltung darunterzulegen und diese Sachen hinten komplett leere. Diese sind zum Vergleichen nämlich fürchterlich. Die muss man eigentlich weggschneiden, sonst erhält man natürlich jede Menge diffs. Es ist wichtig zu verstehen, wieso diese mal da waren, aber eigentlich ist es nicht mehr zeitgemäß es so zu machen und man kann natürlich daraus auch keine alten Versionen wiederherstellen. Manchmal werden dann dort gelöscthe Zeilen auskommentiert, damit man noch sieht, dass die dort war, aber das ist natürlich nicht sinnvoll. Genau so wie man oft vorne im Kopf des Programms noch die komplette Versionshistorie aller Änderungen hat. Das ist natürlich Unfug und Balast. Und da sind sie teilweise sehr sorgfältig, dass ein elaborierter Programmkopf hineinkopiert wird wo Angaben zu Gott und die Welt drinstehen und in welcher Umgebung das Programm läuft. Andere Sache wie die Beutung eines Indexes sind dann dort nicht drin. Da muss man einfach schauen, dass man sich von diesem Blabla trennt und nur Sachen dokumentiert, die man in einer modernen Sprache mit modernen Sprachmitteln übersichtlich abbilden oder kapseln könnte und dort nicht. Das man zum Beispiel sagt ``Diese Variable wird nur in dieser SECTION geändert. Ich würde sie gerne lokal oder private machen, aber das geht nicht. Aber sie ist als solche zu interpretieren.''.

Der 88-Level. Bei diesen Leveldeklarationen habe ich neben 66, 77 auch die 88 als besondere Nummern. 66 und 77 sind im Prinzip etwas wie eine 01. Das 88 Level ist quasi ein Enum für Arme. Wenn man zum Beispiel unter ``01 VAR PIC X'' eine ``88 OK VALUE 'o' ''. Jetzt ist diese OK Variable quasi eine boolsche Variable, die genau dann true ist, wenn in VAR ein `o' drinsteht. Wenn das ein eindeutiger Wert ist kann ich aber auch zum Beispiel diese auf true setzen und so den Wert von VAR setzen. Das wird schon immer wieder verwendet und im Prinzip ist die Intention dahinter die gleiche wie bei einem Enum. Man sagt, es gibt bestimmte Ausprägungen die das annehen kann. Natürlich wird man nicht daran gehintert in die Variable andere Werte zu schreiben. Das andere Problem ist, dass das natürlich, sofern es nicht in einem COPY steht, nur an einer Stelle verwendbar ist. Das führt natürlich dazu, dass ich das an vielen Stellen um System definiert habe und vergesse zu aktualisieren...Eigentlich ist es jedoch eine schöne Möglichkeit. Das würde ich auch tatsächlich empfehlen intensiv zu nutzen, für Sachen wo man eigentlich ein Enum verwenden würde. }  
\toni{Wäre es dann best-practice diese 88 auf TRUE und FALSE zu setzen oder direkt die Werte zu setzen?}
\jona{Wenn man die 88 Deklarationen schon hat, dann sollte man diese nach Möglichkeit auch zum Setzen nutzen. Auch hier kann man sich Überlegen einen Präfix zu spendieren, um kenntlich zu machen, dass diese zusammengehören. Sonst wundert man sich wieder warum dort irgendwelche Werte darinstehen. Aber eigentlich ist es ein schönes Feature, welches nur darunter leidet, dass man es nicht so einfach replizieren kann. Und es dokumentiert natürlich auch wieder durch den Namen ein wenig was genau darin passiert. Das ist auch ein riesen Problem beim Lesen von COBL-Programmen, dass wenn sowas drinsteht wie ``IF VAR='n' '', auch wenn man sich vielleicht bei n noch vorstellen kann was gemeint ist, ist es einfach schwierig zu verstehen. Und solche Status-Flags steuern dann massiv den Programmfluss, werden irgendwo umgesetzt und dann wird es sehr schwer. Das ist wirklich eine der größten Schwierigkeiten bei alten COBOL-Programmen, duruch diese Literalwerte durchzublicken. Und diese 88 Level lassen sich natürlich auch viel leichter in der Wartung anpassen. Dort sollte man aus meiner Sicht viel Sorgfalt investieren, entweder durch 88-Level und einen Präfix oder zumindest, indem man das bei einer Variable richtig dokumentiert. Die 88-Level lassen sich sogar mit mehreren Werten definieren. Für Leute aus der Java-Welt ist der Enum ein etabliertes Konzept und zumindest gedanklich sollte man mitnehmen, dass man bei einer Variable wissen möcthe, was ein Wert genau bedeutet.

Was man in COBOL leider nicht machen kann ist Konstanten deklarieren.  Jede Variable ist jedoch immer änderbar. Was man natürlich machen kann ist bei der Deklaration mit der VALUE-Clause einen Wert zuweisen und per Konvention festlegen, dass diese Variable nicht verändert werden darf. Oder noch besser auch wieder einen Namens-Präfix zu verwenden der das kenntlich macht. Namensschemata und Präfixe sind sehr wichtig! Und es ist natürlich für die Wartung ein großer Vorteil. Vielleicht packe ich mir das sogar noch in ein COPY-Element. Der Nachteil an dieser Stelle ist, dass diese Variable trotzdem Speicher in Anspruch nimmt. Ich denke aber, dass der Tradeoff in heutigen Zeiten eindeutig zugunsten dieser Konstanten ausfällt. Das wird traditionell eher selten gemacht, ich finde jedoch, dass das etwas ist, was man definiv aus der Java-Welt mitnehmen sollte. Dass man zumindest pseudo-Konstanten definiert und sich Namenspräfixe dafür überlegt.

Wiederverwendung ist wie gesagt ein Thema das man sich an der ein oder anderen Stelle anschauen kann. Und auch von dieser moverei wegkommen und einfach Programmaufrufe mit den Sachen machen die ich tatsächlich habe und tatsächlich übergeben will. Funktionen gibt es eben bis auf ganz wenige eingebaute nicht. Das heißt ich habe immer das Muster, dass ich in Variablen ein Ergebnis reinschreiben. Auch da ist es natürlich ein gutes Muster Präfixe zu verwenden, sodass man erkennt, dass ein Wert das Ergebnis einer bestimmten SECTION ist.

Das war es eigentlich. Wichtig ist finde ich, dass bei deiner Arbeit dieser Vergleichende Charakter rüberkommt. Und bevor man in die Detailsemantik von einem PERFORM mit Schleife oder einem EVALUATE einsteigt zu sagen, das EVALUATE entspricht im Grunde einem switch. Es hat noch eine ganze Reihe interessanter Spielarten und kurz aufzählen, welche das sind. Und dann aber ``Für Details siehe ...'' anzuführen. Das reicht. Wichtiger ist mir da tatsächlich diese Gegenüberstellung und dann eben so Themen wie ``Konstanten'' oder ``Kapselung'' transportieren.

Objektorientierung ist natürlich auch ein Thema. Es gibt erstmal in normalen COBOL keine objektorientierung. Das eine Problem daran ist natürlich, dass die Kapselung fehlt. Das kann man zumindest ein bisschen angehen. Das andere ist, dass man keine generischen Operationen definieren kann. Das kann ich in COBOL nicht sinnvoll angehen, dieses Problem. Das dritte ist dann natürlich etwas wie Polymorphie, was natürlich direkt auch nicht machen kann. Was man damit jedoch bezweckt kann man oft dann doch abbilden indem man zum Beispiel eine Variable hat die mir sagt welche Variante ich will. Also angenommen man hat eine Funktion die eine Reihe von Werten aufsummieren und eine Reihe von tollen Rechenoperationen darauf ausführen kann. In Java könnte man diese für den Bruttoverdienst, den Nettoverdienst oder den Krankenkassenbeitrag verwenden. Geht in COBOL natürlich nicht. Aber ich könnte in COBOL ein Flag setzen, welches angibt welchen Wert man summieren möcthe. Dann habe ich meine Logik und an einer ganz klar gekapselten Stelle vielleicht sogar in einer eigenen SECTION, welchen Wert hat denn jetzt dieses Flag und abhängig davon mache ich verschiedene Sachen. Das ist natürlich Polymorphie für Arme, aber es trägt einen doch erstaunlich weit, wenn man das diszipliniert macht. Dabei ist es auch wieder gut wenn man aus der modernen Welt kommt und sagt: ``Eigentlich würde ich jetzt hier Polimorphie einsetzen, aber nachdem ich das nicht habe mache ich das zumindest so und mache das sehr stringent.'' Man sagt also ganz klar, dass eine Variable nur den Zweck hat diese Steuerung zu machen und der generische Code kümmert sich nicht darum, was dort in den Einzelfällen drin ist. Dann gewinnt man dort auch schon wieder einiges an Möglichkeiten.

Nebenläufigkeit habe ich als solche in COBOL nicht drin. In der Regel bietet das Betriebssystem oder der Transaktionsmonitor die Möglichkeit, dass mehrere Prozesse parallel laufen. Diese wissen jedoch nichts voneinander und müssen sich dann wieder zurechtfinden wenn sie auf gemeinsame Ressourcen wie eine Datenbank zugreifen. Dort gibt es jedoch dann die bekannten Mechanismen. Theoretisch gibt es die Möglichkeit sich gemeinsamen Speicherbereich übers Betriebssystemen anzulegen. Ich habe schon mal solche Sachen gesehen, es ist jedoch sehr unüblich und auch sehr problematisch, weil man keinerlei vernünftige Synchronisationsmöglichkeit habe. Also in der Regel kann man immer davon ausgehen, dass ein COBOL-Programm immer Sequenziell ist. Ich kann auch keine Threads aufmachen. Es gibt auch keine Exceptions.}
\toni{Wie funktioniert Fehlerbehandlung dann in COBOL?}
\jona{
Es gibt ein paar Fehler die tatsächlich zum Abbruch führen. Also zum Beispiel eine Division durch 0 oder wenn man eine Variable nicht auf IS NUMERIC prüft und versucht den Inhalt als Zahl zu interpretieren. In der Regel geht dir dann der ganze Prozess auf die Bretter. Also man hat wirklich einen harten Abbruch. Einen Segmentation-Fault oder so. Man hat glaube ich die Möglichkeit in einem COBOL-Programm für bestimmte Sachen Error-Handler zu definieren, aber das ist eher unüblich. Aber es gibt diese Möglichkeit. Ich habe die nur so selten gesehen, dass ich die Semantik auch nicht kenne. Ansonsten läuft alles immer über Return-Codes mit den zugehörigen Problemen. Auch da kann man sich aber Mechanismen überlegen. Was dabei zum Beispiel teilweise gemacht wird ist, dass Programmaufrufe in einer eigenen SECTION gekapselt werden. In dieser können dann die Parameterleisten etc. untergebracht werden und zum Beispiel eine Return-Code Abfrage passieren. Also zum Beispiel wenn der Return-Code fehlerhaft ist, dann setze selbst einen und mache ein STOP RUN. Diese Grundidee von Exceptions, dass man quasi den Fehlerkontrollfluß vom normalen Kontrollfluß trenne kann ich damit zumindest auch so nachbauen, dass ich dort sehr klar bin und sage, ich prüfe nicht erst irgendwann drei SECTIONS später meinen Return-Code sondern genau dort wo er relevant ist. Aber dort ist man tatsächlich wie in C unterwegs.

Zeichenketten haben natürlich auch immer eine feste Länge und sind immer hinten mit Spaces aufgefüllt. Also genau, Standardinitialisierung ist immer 0 bzw. Spaces. Es gibt auch so ein INITIALIZE Statement mit dem man das zurücksetzen kann. Es wird ein bisschen tricky wenn man so geschachtelte Strukturen hat. Welcher Wert dann bei einem INITIALIZE darin landet. Und das kann auch sehr teuer in der Laufzeit sein. Es gibt dann auch bei den String-Operationen Möglichkeiten herauszufinden wie lange sie tatsächlich sind. Aber das ist so ein bisschen unüblich. Und man hat auch keine NULL-Semantik. Häufig würde man dann Space benutzen als nicht gesetzt.}