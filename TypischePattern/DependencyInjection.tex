\subsection{Dependency Injection}\label{depi}
In einer objektorientierten Programmierumgebung werden Funktionalitäten in Klassen gekapselt und so die Wiederverwendbarkeit erhöht. Dies wurde bereits in \autoref{wiederverwendbarkeit} dargestellt. Um damit komplexere Probleme zu lösen und Abhängigkeiten herzustellen werden Klassen oftmals komponiert \bzw aggregiert. Dabei gibt es zwei Möglichkeiten wie eine Aggregation aussehen kann:

\begin{itemize}
    \item Erzeugung aller nötigen Objekt-Instanzen innerhalb der Klasse die diese benötigt.
    \item Erzeugung der nötigen Objekt-Instanzen an zentraler Stelle und Injizieren in Objekte, welche diese benötigen (Dependency Injection). 
\end{itemize}

Die erste der angesprochenen Vorgehensweise verletzt allerdings -- je nach Ausnutzen und Implementierung -- mehr oder weniger die Eigenschaft, dass eine Klasse für genau eine Aufgabe zuständig ist. Außerdem werden so implizit Abhängigkeiten zwischen Komponenten hergestellt, die schwer zu durchschauen sind. Dependency Injection sorgt dafür, dass Abhängigkeiten explizit hergestellt werden. \citeauthor{martin_clean_2008} beschreibt in seinem Buch \citeWithTitle{martin_clean_2008} dieses Muster auch als \quotes{Inversion of Control}, da dabei die Kontrolle über die Instanziierung verlagert -- quasi invertiert -- wird. So entsteht eine losere Kopplung durch die Abhängigkeiten auch zur Laufzeit geändert und gesteuert werden können. Ein weiterer Vorteil zeigt sich beim Testen von Systemen. So lassen sich für Komponenten, welche Abhängigkeiten von Außen bekommen leichter Unit-Tests schreiben, da darunterliegende Strukturen extern gesteuert werden können.

\mintedJava{DependencyInjection.java}{Dependency Injection in Java}{diJava}

\autoref{diJava} beinhaltet eine einfache Dependency Injection. Der Code macht gleichzeitig Gebrauch von Interfaces, was einen Teil der Flexibilität der Dependency Injection verdeutlicht. Neben der gezeigten Möglichkeit der Übergabe an den Konstruktor einer Klasse, erwähnt \citeauthor{martin_clean_2008} \cite{martin_clean_2008} auch die Varianten diese Abhängigkeiten über Setter-Methoden oder Interfaces herzustellen.

Da Variablen, wie \autoref{sec:scope} beschreibt, in COBOL immer dem ganzen Programm zugänglich sind, ist die Dependency Injection hier nicht relevant.