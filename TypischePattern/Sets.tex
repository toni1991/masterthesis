\subsection{Sets}
Neben den in \autoref{lists} beschriebenen Listen bieten Sets in der Programmierung eine weitere häufig genutzte Datenstruktur. Die zwei wesentlichen Unterschiede im Gegensatz zu Listen sind zum einen eine fehlende Ordnung der Elemente und zum anderen die Eigenschaft, dass ein und das selbe Element nur genau einmal innerhalb eines Sets vorkommen darf. Das Set entspricht somit weitestgehend der mathematischen Definition einer Menge.

\subsubsection*{Sets in Java}
Wie für Listen bietet Java auch für Sets das \jav{Set}-Interface. Die wohl am häufigsten genutzte Implementierung dieses Interfaces stellt die \jav{HashSet}-Klasse dar, welche die \jav{hashCode}-Methode eines Objektes nutzt, um es pseudo-eindeutig identifizierbar zu machen. Dadurch wird vermieden, dass die gesamte Liste durchlaufen werden muss, um Duplikate zu finden.

In \autoref{javaHashSet} wird gezeigt, dass das Einfügen von Elementen, die bereits im Set enthalten sind, keine Auswirkung hat. Die Eigenschaft, dass ein Set ungeordnet ist, lässt sich leider nicht zeigen, da Java die Werte bei der gezeigten Ausgabe ordnet. Dieses Verhalten tritt auch auf, wenn die Werte in umgekehrter Reihenfolge dem Set hinzugefügt werden, was jedoch in keinem Fall bedeutet, dass es sich beim Set um eine stets sortierte Liste handelt, auch wenn es den Eindruck vermittelt.

\begin{codeWithCaption}{HashSet Beispiel in Java}{javaHashSet}
    \java{HashSetExample.java}
\begin{shellwindow}
0 1 2 3 4 5 6 7 8 9 
0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 
\end{shellwindow}
\end{codeWithCaption}

\subsubsection*{Sets in COBOL}
Analog zu Listen kann festgehalten werden, dass eine Implementierung von Sets in COBOL nicht ohne weiteres möglich ist. Die Einschränkung der Größe der Datenstruktur bestünde auch hier. 

\begin{codeWithCaption}{Einfache Set Implementierung in COBOL}{cobolSet}
    \cobol{Set.cbl}
\begin{shellwindow}
 SIZE: 000
002, SIZE: 001
002,004, SIZE: 002
002,004, SIZE: 002
002, SIZE: 001
\end{shellwindow}
\end{codeWithCaption}

\autoref{cobolSet} greift jedoch die Kernaspekte von Sets auf und zeigt eine mögliche Implementierung in COBOL. Wie auch in \autoref{cobolSet} sind nur Einfüge- und Löschoperationen realisiert. 

Wenngleich diese Implementierung beispielhaft zeigt, dass die Grundidee eines Sets auch in COBOL abbildbar ist, so hat sie gegenüber Java doch einige Nachteile. Zum einen ist sie ineffizient, da -- anders als \zB bei \jav{HashSet}s -- stets alle Werte der Liste durchlaufen werden müssen, um Redundanz zu vermeiden. Zum anderen liegt die große Stärke von Datenstrukturen in Java in der Generizität (siehe \autoref{generics}). Diese kann in COBOL nicht erreicht werden, wodurch ein Set stets neu für die zugrundeliegenden Datentypen implementiert werden muss.