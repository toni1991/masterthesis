Universität Augsburg
Fakultät für angewandte Informatik
Institute for Software & Systems Engineering

Masterarbeit
von
Antonio Grieco
Matrikelnummer 1408410

Programmiersprachliche Konzepte von COBOL im
Vergleich mit Java – Eine praxisorientierte
Einführung

Erstgutachter: Prof. Dr. Alexander Knapp
Zweitgutachter: Prof. Dr. Bernhard Bauer
Betreuer: Prof. Dr. Alexander Knapp & Jonathan Streit

24. Mai 2018

Lizenzen

»Programmiersprachliche Konzepte von COBOL im Vergleich mit Java – Eine
praxisorientierte Einführung« von Antonio Grieco ist lizenziert unter einer Creative
Commons Namensnennung - Nicht-kommerziell - Weitergabe unter gleichen
Bedingungen 4.0 International Lizenz (CC BY-NC-SA 4.0).

http://creativecommons.org/licenses/by-nc-sa/4.0/
(besucht am 19.05.2018)

Sämtliche in der Arbeit beschriebenen und auf eventuell beigelegten Datenträgern
vorhandenen Ergebnisse dieser Arbeit in Form von Quelltexten, Software und
Konzeptentwürfen sind, sofern nicht anders angegeben, lizenziert unter »The MIT
License (MIT)«.

https://opensource.org/licenses/MIT
(besucht am 19.05.2018)

Die LaTeX-Vorlage beruht auf den Inhalten unter
http://f.macke.it/MasterarbeitZIP
(besucht am 19.05.2018)

I

Zusammenfassung
Da die »Common Business Oriented Language«, kurz COBOL genannt, bereits Ende
der 1950er Jahre entstand und daher nur wenige moderne Sprachkonzepte bietet, wird
der Fokus in der Ausbildung neuer Informatiker immer mehr auf Programmiersprachen
mit moderneren objektorientierten Konzepten gelegt. Dem steht gegenüber, dass COBOL
immer noch wichtiger Bestandteil bestehender betrieblicher Informationssysteme ist,
die es zu warten, zu erweitern und zu migrieren gilt. Während diese Sprache heutzutage
also zunehmend seltener Teil der Ausbildung von Programmierern ist, besteht, durch die
Vielzahl vorhandener COBOL-Systeme, weiterhin eine hohe Nachfrage nach Experten.
Diese Arbeit gibt einen generellen Überblick über Herausforderungen, die sich in
Verbindung mit betrieblichen Informationssystemen ergeben, und zeigt, wie COBOL
und Java diesen Problemen begegnen. Ferner wird COBOL konzeptuell erfasst und
mit Java, als Vertreter moderner Sprachen, verglichen. Dabei steht stets die praktische
Anwendung der Sprachen im Vordergrund, weshalb Experteninterviews geführt wurden,
um neben bestehender Fachliteratur bestmögliche Einsicht in die Entwicklung und
Wartung angesprochener Systeme zu erhalten. Damit entstand ein Leitfaden, der es
Programmierern mit Java-Kenntnissen erlaubt, sich mit COBOL vertraut zu machen,
indem bekannte Konzepte, Muster und Konstrukte gegenübergestellt werden. Zusätzlich
wird, als Ergebnis der Experteninterviews, darauf hingewiesen, wie sich der Umgang
mit diesen Konzepten in der Praxis gestaltet und gestalten sollte.

II

Abstract
COBOL, which stands for the »Common Business Oriented Language«, began to rise in
the late 1950s and therefore offers just a few modern language concepts. Because of that
education tends to focus on teaching programming languages that provide more modern
object-oriented concepts. In contrast, COBOL is still used in many existing operational
information systems, which have to be maintained, extended and migrated. So, whilst
COBOL is getting less and less attention in the education of new programmers, the
demand for highly trained and experienced professionals is still high.
This thesis outlines key challenges in terms of those operational information systems
and reveals how COBOL copes with them. Furthermore, COBOL gets surveyed and
conceptually compared to Java, which represents state of the art programming languages.
The practical approach is always on focus in this comparison, and therefore, along
with available literature, experts were interviewed to get the best possible insight of
development and maintenance of those systems. The purpose was to devise a guide
for Java developers, which enables them to familiarize with COBOL by contrasting
known concepts, pattern and constructs. The interviews led to best practice advice
in combination with those concept descriptions and hints on how those are used in
practice and how they should be used.

III

Inhaltsverzeichnis

Lizenzen

I

Zusammenfassung

II

Abstract

III

Inhaltsverzeichnis

IV

Abbildungsverzeichnis

VI

Listings

VII

1 COBOL und seine Bedeutung
1.1 Problemstellung . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1.2 Ziel der Arbeit . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1.3 Aufbau der Arbeit . . . . . . . . . . . . . . . . . . . . . . . . . . .

1
1
5
6

2 Methodik der Arbeit
2.1 Vorhandene Literatur . . . . . . . . . . . . . . . . . . . . . . . . . .
2.2 Experten-Interviews . . . . . . . . . . . . . . . . . . . . . . . . . .
2.3 Entwicklungsumgebungen . . . . . . . . . . . . . . . . . . . . . . .

7
7
8
9

3 Herausforderungen in betrieblichen Informationssystemen
3.1 Datenmengen und Dimensionierung . . . . . . . . . . . . . . . . .
3.2 Langlebigkeit, Wartbarkeit und Verlässlichkeit . . . . . . . . . . .
3.3 Modularisierung, Wiederverwendbarkeit und Variabilität . . . . .
3.4 Darstellungsgenauigkeit – Binäre und dezimale Kommaarithmetik
3.5 Datenquellen . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3.6 Schnittstellen . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

.
.
.
.
.
.

12
12
13
14
17
21
22

4 Vergleich wichtiger Sprachkonzepte
4.1 Programmstruktur . . . . . . . . . . . . . . . . . . . . . . . . . . .
4.2 Variablen und Datentypen . . . . . . . . . . . . . . . . . . . . . . .
4.3 Arrays . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

24
24
30
37

IV

Inhaltsverzeichnis
4.4

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

38
39
43
48
50
52
56
57
57
62
64
67
67
71
75
76
77
80
80

.
.
.
.
.
.
.
.
.
.
.

84
84
87
87
90
94
94
98
98
103
104
106

6 COBOL bleibt von Bedeutung
6.1 Fazit . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
6.2 Ausblick . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

108
108
108

4.5
4.6
4.7
4.8

Programmablauf und Kontrollfluss . . .
4.4.1 Genereller Ablauf . . . . . . . . .
4.4.2 Funktionen, Unterprogramme und
4.4.3 Verzweigungen . . . . . . . . . .
4.4.4 Schleifen . . . . . . . . . . . . . .
4.4.5 Weitere Schlüsselwörter . . . . . .
4.4.6 Ausnahmebehandlung . . . . . .
4.4.7 Nebenläufigkeit . . . . . . . . . .
Dateien . . . . . . . . . . . . . . . . . .
Generische Programmierung . . . . . . .
Konventionen . . . . . . . . . . . . . . .
Weitere Sprachkonzepte . . . . . . . . .
4.8.1 Benannte Bedingungen . . . . . .
4.8.2 Mehrfachverzweigungen . . . . .
4.8.3 Speicherausrichtung . . . . . . . .
4.8.4 Reorganisation von Daten . . . .
4.8.5 Implizierte Variablennamen . . .
4.8.6 Modifier . . . . . . . . . . . . . .
4.8.7 Assoziation von Entitäten . . . .

5 Typische Pattern in COBOL und Java
5.1 Externe Deklaration von Daten . .
5.2 Komplexe Datenstrukturen . . . . .
5.2.1 Listen . . . . . . . . . . . .
5.2.2 Sets . . . . . . . . . . . . .
5.2.3 Maps . . . . . . . . . . . . .
5.2.4 Verbunddatenstrukturen . .
5.3 Entwurfsmuster . . . . . . . . . . .
5.3.1 Callback-Muster . . . . . .
5.3.2 Singleton-Muster . . . . . .
5.3.3 Dependency Injection . . . .
5.4 Redundanz durch Wertekopien . . .

Literatur

.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.

. . . . . . . . .
. . . . . . . . .
Rückgabewerte
. . . . . . . . .
. . . . . . . . .
. . . . . . . . .
. . . . . . . . .
. . . . . . . . .
. . . . . . . . .
. . . . . . . . .
. . . . . . . . .
. . . . . . . . .
. . . . . . . . .
. . . . . . . . .
. . . . . . . . .
. . . . . . . . .
. . . . . . . . .
. . . . . . . . .
. . . . . . . . .

.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.

IX

V

Abbildungsverzeichnis

4.1
4.2
4.3

Strukturelle Bestandteile eines Java-Programms . . . . . . . . . . .
Strukturelle Bestandteile eines COBOL-Programms . . . . . . . . .
UML-Diagramm einer Aggregation . . . . . . . . . . . . . . . . . .

VI

24
27
77

Listings

2.1
2.2

Erstellen eines neuen COBOL Programms . . . . . . . . . . . . . .
Erstes COBOL-Programm in der Kommandozeile . . . . . . . . . .

10
11

3.1
3.2

Ungenauigkeit am Beispiel einer float-Variable . . . . . . . . . . . .
Dezimalzahlen in COBOL . . . . . . . . . . . . . . . . . . . . . . .

18
20

4.1
4.2
4.3
4.4
4.5
4.6
4.7
4.8
4.9
4.10
4.11
4.12
4.13
4.14
4.15
4.16
4.17
4.18
4.19
4.20
4.21
4.22
4.23
4.24
4.25
4.26

Initializer in Java . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Anonyme Klassen und Funktion in Java . . . . . . . . . . . . . . .
SPECIAL-NAMES Paragraph in COBOL . . . . . . . . . . . . . .
Variablendeklarationen in Java . . . . . . . . . . . . . . . . . . . . .
Variablendeklarationen mit verschiedenen Scopes . . . . . . . . . .
Variablendeklarationen in COBOL . . . . . . . . . . . . . . . . . .
Mehrdeutige Variablennamen in COBOL . . . . . . . . . . . . . . .
Felder in Java . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Felder in COBOL . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Java main-Methode . . . . . . . . . . . . . . . . . . . . . . . . . . .
Programmablauf in COBOL . . . . . . . . . . . . . . . . . . . . . .
Programmablaufunterschiede in COBOL mit Sections und Paragraphs
Methoden in Java . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Rekursion in Java . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Rekursion in COBOL . . . . . . . . . . . . . . . . . . . . . . . . . .
Unterprogramme in COBOL . . . . . . . . . . . . . . . . . . . . . .
Verzweigung in Java . . . . . . . . . . . . . . . . . . . . . . . . . .
Verzweigung in COBOL . . . . . . . . . . . . . . . . . . . . . . . .
Schleifen in Java . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Schleifen in COBOL . . . . . . . . . . . . . . . . . . . . . . . . . .
Beispiele für die Verwendung von break und continue in Java . . . .
EXIT PERFORM in COBOL . . . . . . . . . . . . . . . . . . . . .
Rudimentäre Fehlerbehandlung in COBOL . . . . . . . . . . . . . .
Datei-Ein- und Ausgabe in Java [18] . . . . . . . . . . . . . . . . .
Ein- bzw. Ausgabedatei recordFile.txt . . . . . . . . . . . . . . . . .
Personendaten Copybook . . . . . . . . . . . . . . . . . . . . . . . .

25
26
28
31
33
34
35
37
38
39
41
42
44
45
46
48
49
50
51
52
53
55
56
59
59
60

VII

Listings
4.27
4.28
4.29
4.30
4.31
4.32
4.33
4.34
4.35
4.36
4.37
4.38
4.39
4.40
4.41
4.42
4.43

Dateien schreiben in COBOL (vgl. [28]) . . . . . . . . . . . . . . . .
Dateien lesen in COBOL (vgl. [28]) . . . . . . . . . . . . . . . . . .
Datei-Ein- und Ausgabe in COBOL (vgl. [28]) . . . . . . . . . . . .
Generics in Java . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Beispiel für COBOL Stufennummer 88 . . . . . . . . . . . . . . . .
Setzen von Werten mithilfe benannter Bedingungen . . . . . . . . .
Bedingte Werte in Java . . . . . . . . . . . . . . . . . . . . . . . . .
Setzen eines konstanten Wertes mit einem Enum in Java . . . . . .
Mehrfachverzweigungen in Java . . . . . . . . . . . . . . . . . . . .
Mehrfachverzweigungen in COBOL mit ALSO . . . . . . . . . . . .
Mehrfachverzweigungen in COBOL als EVALUATE TRUE . . . . .
Stufennummer 66 und RENAMES-Befehl . . . . . . . . . . . . . . .
Keine implizierten Variablennamen in logischen Ausdrücken in Java
Verwendung von Variablennamen in logischen Ausdrücken in Java .
Implizierte Variablennamen in COBOL . . . . . . . . . . . . . . . .
Assoziationen in Java . . . . . . . . . . . . . . . . . . . . . . . . . .
Assoziationen in COBOL . . . . . . . . . . . . . . . . . . . . . . . .

5.1
5.2
5.3
5.4
5.5
5.6
5.7
5.8
5.9
5.10
5.11
5.12
5.13
5.14
5.15
5.16
5.17

Import in Java . . . . . . . . . . . . . . . . . . . . . . . .
COBOL-Copybook Datei (COPYBOOK.cpy) . . . . . . .
Nutzung eines COBOL-Copybook . . . . . . . . . . . . . .
COBOL-Copybook Datei (COPYBOOK-EVALUATE.cpy)
Nutzung von COPYBOOK-EVALUATE.cpy . . . . . . . .
ArrayList Beispiel in Java . . . . . . . . . . . . . . . . . .
Einfache Listen Implementierung in COBOL . . . . . . . .
HashSet Beispiel in Java . . . . . . . . . . . . . . . . . . .
Einfache Set Implementierung in COBOL . . . . . . . . .
Structs und Unions in COBOL . . . . . . . . . . . . . . .
Struct in Java (JavaBean) . . . . . . . . . . . . . . . . . .
Union in Java . . . . . . . . . . . . . . . . . . . . . . . . .
Observer und Observable in Java . . . . . . . . . . . . . .
Listener in Java . . . . . . . . . . . . . . . . . . . . . . . .
Ausgabe der Callback-Beispiele in Java . . . . . . . . . . .
Singleton in Java . . . . . . . . . . . . . . . . . . . . . . .
Dependency Injection in Java . . . . . . . . . . . . . . . .

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

84
85
85
86
86
88
90
91
93
96
96
97
100
102
102
103
105

6.1
6.2

Ursprünglicher COBOL-Code . . . . . . . . . . . . . . . . . . . . .
Generierter Java-Code . . . . . . . . . . . . . . . . . . . . . . . . .

109
109

VIII

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

60
61
62
63
68
69
70
71
72
74
75
76
78
79
80
81
82

1 COBOL und seine Bedeutung

1 COBOL und seine Bedeutung
Um die Problemstellung dieser Arbeit zu verdeutlichen, wird erläutert, welche Wichtigkeit die »Common Business Oriented Language«, kurz COBOL genannt, auch heute
noch innehat und anschließend mit der Bedeutung, die der Sprache in der Ausbildung
beigemessen wird, gegenübergestellt. Anhand dessen werden Schwierigkeiten für den
Arbeitsmarkt analysiert und beschrieben.

1.1 Problemstellung
COBOL ist eine prozedurale Programmiersprache, die im Laufe der 1950er Jahre von
der US Regierung entwickelt wurde. Dabei wurde das Ziel verfolgt, eine Sprache zu
schaffen, die, durch ihre Anlehnung an die natürliche Sprache, auch von Personen ohne
informationstechnische Ausbildung angewendet werden kann. Dies verhalf COBOL zu
großer Beliebtheit.

Wichtigkeit von COBOL
»Viele Millionen Cobol-Programme existieren weltweit und müssen laufend gepflegt
werden. Es ist bei dieser Situation undenkbar und unter wirtschaftlichen Gesichtspunkten
unvertretbar in den nächsten Jahren eine Umstellung dieser Programme auf eine andere
Sprache durchzuführen.« [13]
Was Herr Dr. Strunz neben vielen anderen Experten bereits 1979 prophezeite, hat
auch heute noch Gültigkeit. Obwohl COBOL zum Ende der 50er Jahre entstand, 1959
veröffentlicht wurde und damit fast 60 Jahre alt ist, trifft man es auch heute noch häufig
in betrieblichen Informationssystemen an. In der britischen Tageszeitung The Guardian
zitiert der Autor Scott Colvey in seinem Artikel [5] anlässlich des 50. Geburtstages von
COBOL den Micro Focus Manager David Stephenson: »some 70% to 80% of UK plc

1

1 COBOL und seine Bedeutung
business transactions are still based on Cobol«. Weiter führt er darin Aussagen von
IBM Software-Leiter Charles Chu an, welcher die Äußerungen von Stephenson bestätigt:
»[. . .] there are 250bn lines of Cobol code working well worldwide. Why would companies
replace systems that are working well?«. Stephen Kelly, Geschäftsführer von Micro
Focus, betont zudem, dass sich Stand 2009 über 220 Milliarden COBOL-Codezeilen im
produktiven Einsatz befanden, welche vermutlich 80% der insgesamt weltweit aktiven
Codezeilen ausmachten. Außerdem wurden zum damaligen Zeitpunkt, Schätzungen
zufolge, 200-mal mehr COBOL-Transaktionen ausgeführt als Google Suchanfragen
verzeichnen konnte [15]. Diese Aussagen decken sich mit den Angaben in COBOL
programmers swing with Java [8]. Auch darin betonen Doke u. a., dass, Stand 2005,
mit 225 Milliarden Codezeilen, etwa 70% des weltweiten Codes in COBOL geschrieben
sind.
Daran wird nicht nur deutlich, dass COBOL in den vergangenen Jahren einen enormen
Marktanteil ausmachte, sondern auch die weiterhin bestehende Bedeutung der Sprache
für die Zukunft.
COBOL-Systeme sollten dennoch aus verschiedenen Gründen sukzessive durch neue
Systeme abgelöst werden. Die Programme werden oft auf Mainframe Computern ausgeführt oder gar entwickelt, deren Betrieb um ein vielfaches höhere Kosten verursacht
als moderne IT-Landschaften mit konventionellen Computern. Außerdem sind die
verfügbaren Entwicklungswerkzeuge teilweise veraltet und teuer, da diese nur unter
kommerziellen Lizenzen verfügbar sind. Doch auch die prozeduralen Spracheigenschaften
von COBOL haben vor allem in puncto Wiederverwendung und Kapselung deutliche
Nachteile gegenüber neueren Sprachkonzepten und machen so den Umstieg zu modernen
Programmiersprachen und Infrastrukturen attraktiv.
Allerdings gibt es bei der Migration auch Risiken, die nicht vernachlässigt werden
dürfen. Denn »[t]äglich werden Transaktionen mit einem Volumen von schätzungsweise
drei Billionen Dollar über Cobol-Systeme abgewickelt. Dabei geht es um Girokonten,
Kartennetze, Geldautomaten und die Abwicklung von Immobilienkrediten. Weil die
Banken aggressiv auf eine Digitalisierung ihres Geschäftes setzen, wird Cobol sogar noch
wichtiger. Denn Apps für Smartphones etwa sind in modernen Sprachen geschrieben,
müssen aber mit den alten Systemen harmonieren« [2]. Außerdem besteht »ein signifikantes Risiko [...] vor allem dann, wenn das neue System Unternehmens-Know-how
integrieren soll, das über die gesamte bisherige Betriebszeit eingeflossen und sonst
nirgendwo außerhalb der alten Systeme dokumentiert ist.« [23] Dadurch ergibt sich
die Gefahr, dass Funktionalität in Neusystemen nicht Eins-zu-eins umgesetzt ist [23],
was mit den angesprochenen hohen Transaktionssummen von COBOL-Systemen zu

2

1 COBOL und seine Bedeutung
empfindlichen und teuren Problemen in Betriebsabläufen führen kann. Die Zahl des
weltweit betriebenen COBOL-Codes stieg daher über die vergangenen Jahre sogar
noch weiter an, da neue Funktionen weiterhin in bestehende Projekte integriert werden
mussten.
Im TIOBE-Index [27] für April 2018 belegt COBOL den 25. Platz mit einem Rating
von 0,541%. Dieser Index wird auf Basis von Suchanfragen nach den entsprechenden
Programmiersprachen auf den frequentiertesten Internetseiten erstellt. COBOL ist somit
zwar nur Teil jeder 200. Suchanfrage, rangiert damit jedoch vor anderen etablierten
oder aufstrebenden Sprachen wie Kotlin, Scala oder Haskell. Außerdem gilt es hier
zu beachten, dass COBOL zu einer Zeit entstand, in der das Internet noch lange
nicht existierte und Informationen über die Sprache mittels Büchern verbreitet und
vermittelt wurden. Daher ist auch heute noch das Internet nicht die vorrangige Quelle,
um Wissen über COBOL zu akquirieren und COBOL im TIOBE-Rating noch zu niedrig
eingeschätzt.

Bedeutung in der Ausbildung
Da COBOL bereits 60 Jahre alt ist, haben heutzutage bereits viele einstige COBOLEntwickler das Rentenalter erreicht. Im Artikel Cobol-Programmierer gesucht [2] beschreibt der Autor exemplarisch den Fall eines 75-Jährigen Entwicklers, der wegen seiner
Erfahrung trotz seines Alters immer noch in der Branche tätig ist.
Junge COBOL-Entwickler sind rar, da COBOL nur noch selten Teil der Ausbildung ist.
Doke u. a. führen in COBOL programmers swing with Java [8] an, dass im Jahr 2002
lediglich für 36,2% der Studenten COBOL Teil des Grundstudiums war, obwohl im
Jahr 1995 noch 89,7% der befragten Bildungseinrichtungen angaben, COBOL-Kurse als
festen Bestandteil der Ausbildung zu haben. Sieht man sich dagegen die Zahlen zu Java
als Vertreter moderner Programmiersprachen an, lässt sich ein klarer Trend erkennen.
Erst 1995 entstanden, stieg die Zahl der Universitäten und Fachhochschulen, die Java
lehrten, von 42,5% im Jahr 1998 auf 90,0% im Jahr 2002. Spinnt man diesen Wandel,
zu dem sich in der Zwischenzeit noch eine Fülle neuerer Sprachen hinzugesellt hat,
ins heutige Jahr weiter, lässt sich erahnen, wie selten Lehrveranstaltung zum Thema
COBOL inzwischen geworden sind.
Auch eine Befragung an Berufsschulen brachte ähnliche Ergebnisse. Herr Blanke, Oberstudienrat und Fachbetreuer im Fachbereich Informationstechnik der Berufsschule I in

3

1 COBOL und seine Bedeutung
Kempten, gab an, dass COBOL kein Teil der betrieblichen Lehre für Anwendungsentwickler sei. Obwohl Auszubildende zwar teilweise in ihren Betrieben damit in Kontakt
kämen und die Lehrpläne mit den örtlichen Unternehmen abgestimmt werden, gäbe
es seit Langem keine Gründe, COBOL zu unterrichten. Daher wurden die Lehrinhalte
erst vor 4 Jahren weiter auf Java fokussiert. Der Leiter einer anderen, von der IHK
gelisteten Berufsschule sagte übereinstimmend, dass »COBOL seit Schulgründung 1997
kein Thema« sei.
Man sieht daran, dass der Fokus von Ausbildung und Lehre, obwohl der Bedarf an
COBOL-Programmierern weiterhin immens ist, bei anderen Programmiersprachen
liegt, was die Wirtschaft zusammen mit dem zunehmenden Alter erfahrener COBOLEntwickler vor Probleme beim Stillen der Nachfrage an Arbeitskräften stellt. Das liegt
insbesondere daran, dass vorrangig die Konzepte und Grundlagen vermittelt werden,
die COBOL nur eingeschränkt bzw. gar nicht enthält, weshalb sich moderne Sprachen
dafür weitaus besser eignen.

Kontroverse Beurteilungen von COBOL
Die bereits angeführten Aussagen und Meinungen stammen oftmals von Personen aus
dem Umfeld von Unternehmen, die teils stark vom Weiterbestehen COBOLs profitieren.
Diese Aussagen sind daher, wenn auch sicherlich nicht falsch, vorsichtig und vor allem
sehr differenziert zu betrachten.
Der mehrfach prämierte Informatiker Edsger Wybe Dijkstra z. B. findet sehr klare,
andere Worte zu COBOL: »The use of COBOL cripples the mind; its teaching should,
therefore, be regarded as a criminal offence.« [9]
Florian Hamann nennt in seinem Artikel In Banken leben Dinosaurier [10] die bereits
erwähnte zunehmende Knappheit von Arbeitskräften auch als einen wichtigen Faktor
dafür, weshalb COBOL über kurz oder lang von moderneren Systemen und Sprachen
verdrängt und abgelöst wird.
Trotz dieser Kontroversen kann festgehalten werden, dass es nach wie vor einen gleichbleibend hohen Bedarf an Entwicklern gibt, den es zu decken gilt. Allerdings entstand
die Sprache weit vor wichtigen Entwicklungen und Innovationen in der Informatik und
bildet so keine zeitgemäße Grundlage für umfangreiche und noch weniger für neue
Systeme.

4

1 COBOL und seine Bedeutung

1.2 Ziel der Arbeit
Die vorliegende Arbeit leistet einen Beitrag zur Lösung der in Abschnitt 1.1 beschriebenen Probleme. Dies geschieht mithilfe eines Leitfadens, der fachkundigen
Java-Entwicklern den Einstieg in COBOL erleichtert, indem gängige Sprachkonzepte
gegenübergestellt und verglichen werden.
Das ermöglicht es, vorhandenes Wissen über Softwareentwicklung, im speziellen mit
Java, in einen COBOL-Kontext zu bringen und passende Sprachkonzepte nutzen zu
lernen. Des Weiteren wird aufgezeigt, welche konzeptuellen Herausforderungen sich bei
der COBOL-Entwicklung und Migration ergeben.
Im Fokus steht hierbei neben der Einführung in relevante Sprachkonstrukte stets auch
die Experteneinschätzung zur Nutzung der verschiedenen Konzepte. Daher wird, wenn
möglich, zusätzlich zu den erklärten Paradigmen erläutert, wie die Verwendung in der
Praxis aussehen bzw. nicht aussehen sollte und je nach Sprachmittel gegebenenfalls in
der Praxis zu verwendende Alternativen aufgezeigt.
Es ist nicht Ziel der Arbeit, vorhandene Java-Entwickler zu Neuentwicklungen mit
COBOL zu animieren oder diese gar zu COBOL-Entwicklern umzuschulen. Wichtig
ist in diesem Zusammenhang vielmehr, ihr Wissensspektrum so zu erweitern, dass es
ihnen möglich wird, komplexe fachliche Zusammenhänge, vor allem die »business logic«,
bestehender COBOL-Architekturen zu erkennen und zu verstehen. Dadurch sind diese
Entwickler flexibler einsetzbar und geschult, um mit Migrations-, Renovierungs- und
Wartungsaufgaben von COBOL-Systemen betraut werden zu können.
Neben den praxisrelevanten Aspekten erfasst diese Arbeit Java und COBOL konzeptuell
und bringt die Sprachen so in einen universitären Kontext. Dies dient dem Zweck, die
zugrunde liegenden Ansätze statt deren syntaktischer Schreibweisen zu untersuchen.
Außerdem werden dabei bekannte, in der Praxis häufig zu findende Muster beleuchtet
und mit den zutage geförderten Kernkonzepten der Sprachen verglichen, um Aufschluss
darüber zu geben, wie die Sprachkonzepte in der Praxis angewendet bzw. genutzt
werden.

5

1 COBOL und seine Bedeutung

1.3 Aufbau der Arbeit
Die vorhandene Literatur und das Vorgehen bei der Erstellung der Arbeit werden in
Kapitel 2 erläutert.
Kapitel 3 behandelt die grundlegenden Herausforderungen bei der Entwicklung betrieblicher Informationssysteme und zeigt, wie sich diese Problemstellungen in COBOL und
Java adressieren lassen. Die wichtigsten Sprachmittel und Konzepte werden in Kapitel 4
aufgezeigt und gegenübergestellt. Kapitel 5 veranschaulicht häufig auftretende Muster
der Sprachen und beschreibt, wie und ob diese in der jeweils anderen abgebildet werden
können.
Das Kapitel 6 beinhaltet eine Zusammenfassung und Interpretation der Thematik und
gibt ein Resümee der Arbeit.

6

2 Methodik der Arbeit

2 Methodik der Arbeit

2.1 Vorhandene Literatur
Die aufgeführte Literatur gibt oftmals einen sehr detaillierten Einblick in COBOL und
bietet Hilfestellungen mit »Nachschlage-Charakter«. So wie beispielsweise in Teach
yourself Cobol in 21 days [3] oder COBOL programming - tutorials, lectures, exercises,
examples [28] werden häufig möglichst viele der vorhandenen COBOL-Konstrukte
vorgestellt, mit Beispielen beschrieben und so ihre Verwendung gezeigt.
Neuere Literatur wie COBOL for the 21st century [24] betrachtet häufig zusätzliche
Neuerungen wie die objektorientierte Verwendung von COBOL. Cobol 2002 ge-packt
[21] hingegen stellt mehr ein Syntax-Wörterbuch dar als eine wirkliche Beschreibung
oder Einführung in COBOL.
Beginning COBOL for programmers [6] bietet den wohl umfassendsten Überblick, sowie
ausführliche Beispiele und Erklärungen zur Verwendung und wirkt dabei nicht wie ein
klassisches Nachschlagewerk, sondern wie ein klar strukturiertes Fachbuch, das mit
einem klaren roten Faden durch die Bestandteile von COBOL führt. Dabei zieht es vor
allem in der Einführung an einigen, wenigen Stellen Parallelen zu Java.
Alle diese Werke setzen ein gewisses generelles Vorwissen im Bereich der Programmierung
und Informatik voraus, was auch in dieser Arbeit der Fall ist. Jedoch ist an nur wenigen
Stellen ein vergleichender Charakter zu anderen Sprachen zu erkennen und sehr selten
die Erwähnung der jeweiligen Praxisrelevanz oder der besten Einsatzmöglichkeiten
entsprechender Konstrukte zu finden.
In dieser Arbeit wird dagegen bewusst nur selten in die Tiefe der einzelnen Bestandteile
gegangen und alle möglichen Verwendungsarten beschrieben, sondern die praktisch relevanten Aspekte beleuchtet. Für einen tieferen Einblick in die gesamten Sprachfeinheiten
bietet sich die genannte Literatur an, welche auch bei der Erstellung der Inhalte als
Informationsquelle genutzt wurde.

7

2 Methodik der Arbeit
COBOL programmers swing with Java [8] basiert auf den gleichen Ideen, versucht jedoch,
Personen mit fundierten COBOL-Kenntnissen die Entwicklung in Java beizubringen,
indem Konzepte gegenübergestellt werden. Teilweise wichtige Details werden dabei
ausgelassen oder an manchen Stellen missverständlich beschrieben, weshalb dieses Buch
aus fachlicher Sicht zwar als eine gute Brücke von COBOL zu Java einzuschätzen ist,
aber nicht als einzige Quelle dienen sollte. Den Brückenschlag in die andere Richtung –
von Java zu COBOL – lässt es hingegen nicht ohne weiteres zu, was nicht zuletzt daran
liegt, dass – wie der Name bereits andeutet – ein großer Teil des Buches grafischen
Oberflächen mit Swing gewidmet ist.
Im Gegensatz zu vorherigem steigt Java for COBOL programmers [4] tiefer in die
syntaktischen Konstrukte von Java ein und behandelt die JavaEE (Enterprise Edition).
Außerdem zielt es weniger auf grafische Systeme ab als auf solche, die Daten verarbeiten.
So werden verschiedene Ein- und Ausgabe-Mechanismen erklärt, der Umgang mit XMLFormaten beschrieben und – als Teil der Java EE – die Verwendung von Datenbanken
erläutert.
COBOL programmers swing with Java [8] und Java for COBOL programmers [4]
ermöglichen COBOL-Entwicklern den schnellen Einstieg in Java und bieten durch die
jeweils unterschiedlichen Schwerpunkte einen guten Überblick. Nicht nur, dass in diesen
beiden Quellen die Sicht – Java lernen als COBOL-Entwickler – eine andere als in
dieser Arbeit ist, auch wird nur selten bzw. gar nicht auf die praktische Relevanz der
beschriebenen Konstrukte eingegangen. Dadurch fehlt der Charakter eines Leitfadens,
welcher diese Arbeit prägt.

2.2 Experten-Interviews
Die vorliegende Arbeit nutzt vorhandenes Expertenwissen, um, statt eines Nachschlagewerks für syntaktische Zwecke, einen Leitfaden zu erarbeiten – der von praktischer
Relevanz getrieben – die wichtigsten Eigenschaften von COBOL und Java beleuchtet
und gegenüberstellt. Daher stellen neben den angesprochenen literarischen Quellen,
vor allem Experteninterviews einen Kernpunkt dieser Arbeit dar. Um den Praxisbezug
zu gewährleisten, wurden diese geführt, transkribiert und darauf aufbauend relevante
Themenbereiche und Praktiken ausgemacht und analysiert.
Interviewt wurden Experten aus dem Hause der itestra GmbH. Diese »Mitarbeiter
kombinieren eine exzellente Informatik-Ausbildung mit Branchen-Know-how«1 , »kennen

8

2 Methodik der Arbeit
sowohl Legacy-Technologien wie Assembler, RPG und COBOL als auch Java, JS,
C# und iOS«1 und »verstehen alte Systeme und setzen moderne Technologien ein«1 .
Die Mitglieder der Entwicklerteams können dabei auf mehrjährige Erfahrungen im
Bereich der Renovierung und dem Reengineering von COBOL-Systemen blicken, was
die befragten Personen zur wohl wichtigsten Quelle dieser Arbeit macht.
Befragt wurden die drei kundigen COBOL-Entwickler Ivaylo Bonev, Jonathan Streit
und Thomas Lamperstorfer. Dabei ging es nicht darum, eine repräsentative Stichprobe
nach statistischem Vorgehen zu erheben, sondern darum eine individuelle Bewertung der
Schwierigkeiten und Stolpersteine bei der Entwicklung, Wartung und dem Verständnis
von bestehenden und neuen COBOL-Systemen sowie eine Einschätzung zu Parallelen
und Diskrepanzen mit Java zu erhalten. Daher wurde kein Fragenkatalog ausgearbeitet, sondern offener Input gefordert, um die gewünschten subjektiven Meinungen zu
bekommen.
Der Umfang der Interviews beläuft sich auf 3 Stunden Audiomaterial bzw. 30 A4-Seiten
Transkription in der ersten Phase und zusätzlichem Feedback in der Zwischenphase, bei
dem die Experten diese Arbeit beurteilt und weitere Anregungen gegeben haben.

2.3 Entwicklungsumgebungen
Um Codebeispiele für diese Arbeit zu erstellen, zu kompilieren und auszuführen, wurden
jeweils für Java und COBOL IDEs verwendet.
Für Java-Code wurde die bekannte Eclipse2 Umgebung verwendet. Dabei handelt es
sich um einen etablierte IDE, welche eine Vielzahl von Funktionen zur Entwicklung und
zum Debugging liefert.
Der COBOL-Code dieser Arbeit wurde in der OpenCobolIDE3 entwickelt. Dabei handelt
es sich um eine minimalistische IDE, welche zum Beispiel Syntax-Highlighting oder eine
übersichtliche Darstellung von Fehlern bietet. Der darunterliegende Compiler GnuCOBOL4 wurde jedoch auch teilweise direkt als Kommandozeilenwerkzeug ausgeführt. Im
Gegensatz zur sonst üblichen COBOL-Entwicklung auf einem Hostsystem ermöglicht
dieser Compiler das Erzeugen von ausführbaren Dateien für gängige Linuxsysteme.
https://itestra.com/leistungen/software-renovation/ (besucht am 19.05.2018)
http://www.eclipse.org/ (besucht am 19.05.2018)
3
https://github.com/OpenCobolIDE/OpenCobolIDE (besucht am 19.05.2018)
4
https://sourceforge.net/projects/open-cobol/ (besucht am 19.05.2018)
1

2

9

2 Methodik der Arbeit
Dies war in dieser Arbeit sehr wichtig, um nicht auf ein System angewiesen zu sein,
welches meist nur in Produktivumgebungen betrieben wird und zu dem der Zugriff oft
beschränkt und, durch die verschiedenen Abrechnungsmodelle dieser Hostrechner, teuer
oder schlichtweg nicht möglich ist.

Das erste COBOL-Programm
Um bereits an dieser Stelle einen kleinen Einblick in COBOL, die Programmierung
und die Ausführung mit der OpenCobolIDE zu bekommen, wird ein kurzes COBOLProgramm implementiert. Die einzelnen Bestandteile davon werden im Laufe der Arbeit
genauer beschrieben.
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16

IDENTIFICATION DIVISION.
PROGRAM-ID. HELLO_USER.
DATA DIVISION.
FILE SECTION.
WORKING-STORAGE SECTION.
01 USERNAME PIC X(20) VALUE SPACES.
PROCEDURE DIVISION.
MAIN-PROCEDURE.
DISPLAY "Your name: " WITH NO ADVANCING.
ACCEPT USERNAME.
IF USERNAME EQUALS SPACES
MOVE "world" TO USERNAME
END-IF.
DISPLAY "Hello " USERNAME.
STOP RUN.
END PROGRAM HELLO_USER.

Listing 2.1: Erstellen eines neuen COBOL Programms

Legt man in der OpenCobolIDE ein neues Programm an, so enthält die Datei das
bekannte »Hello world« als Beispielprogramm. Wir haben dieses Programm nun so
erweitert, dass es die Eingabe eines Benutzernamens erwartet und eine persönliche
Begrüßung ausgibt. Listing 2.1 zeigt das fertige Programm.
Als erstes wird die PROGRAM-ID festgelegt. Dies ist der Programmname, wie er auch nach
außen – für eventuelle andere Programme – sichtbar wird, und sollte daher eindeutig
sein. Wichtig hierbei ist auch das Setzen des Namens in der letzten Zeile, die das END

10

2 Methodik der Arbeit
PROGRAM enthält. Diese Zeile kann entfallen, muss aber den richtigen Programmnamen
enthalten wenn sie verwendet wird.
Anschließend wurde eine Variable mit dem Namen USERNAME angelegt, die aus 20
alphanumerischen Zeichen (PIC X(20)) besteht und mit Leerzeichen (VALUE SPACES)
initialisiert wird.
Mittels DISPLAY wird der Nutzer aufgefordert, seinen Namen einzugeben, den das
ACCEPT-Schlüsselwort dann in die angesprochene Variable schreibt.

1

$ cobc -x HELLO_USER.cbl

2

$ ./HELLO_USER

3

Your name: Toni

4

Hello Toni

Listing 2.2: Erstes COBOL-Programm in der Kommandozeile

Anschließend wird geprüft, ob der Nutzer eine Eingabe gemacht hat. Ist dies der
Fall, wird eine persönliche Begrüßung ausgegeben. Andernfalls erscheint die generische
Meldung »Hello world«. Diese Ausgaben werden wie bereits die Eingabeaufforderung
mit DISPLAY ausgegeben.
Kompiliert wird das Programm nun mit den Tasten F8 (kompilieren) bzw. F5 (kompilieren und ausführen). Der GnuCOBOL-Compiler kann durch ein einfaches Kommando
direkt ausgeführt werden, um eine ausführbare Datei zu erstellen. Dies wird in Listing 2.2
dargestellt.

11

3 Herausforderungen in betrieblichen Informationssystemen

3 Herausforderungen in betrieblichen
Informationssystemen
Bei der Entwicklung von betrieblichen Informationssystemen sehen sich Entwickler mit
grundlegenden Fragen und Anforderungen an die einzusetzenden Technologien und
Programmiersprachen konfrontiert.
Dieses Kapitel zeigt auf, welchen Herausforderungen sich Programmiersprachen – im
Speziellen COBOL und Java – in diesen Informationssystemen stellen müssen und gibt
einen Überblick über die wichtigsten Entscheidungskriterien für die Herangehensweise.

3.1 Datenmengen und Dimensionierung
Betriebliche Informationssysteme sind in der Regel dafür konzipiert, große Datenmengen
zu verarbeiten, die für gewöhnlich mit der Betriebszeit des Systems weiter zunehmen.
Daher ist bereits bei der Planung wichtig, den späteren Datenumfang so abzuschätzen,
dass nachträgliche Erweiterungen durch möglichst wenig Programmieraufwand zu
bewerkstelligen sind.
Die Dimensionierung von Datenstrukturen nimmt in Java eine untergeordnete Rolle
ein, da dynamisch Speicher alloziert werden kann, wodurch sich die Größe von Datenstrukturen dynamisch erweitern lässt, wie Abschnitt 5.2 genauer beschreibt. Um ein
hohes Datenaufkommen in adäquater Zeit bewältigen zu können, spielt in Java neben
der Algorithmik auch parallele Verarbeitung eine vorrangige Rolle. Ebenso beeinflusst
oftmals die Plattform, auf der ein Java-System betrieben wird, wie sich die Performanz
des Systems gestaltet.
Wenn Daten gleichzeitig im Speicher gehalten werden müssen, sind in COBOL Vorüberlegungen zur Dimensionierung eines Systems und der darin genutzten Datenstrukturen
weitaus wichtiger als in Java. Da COBOL, wie später in dieser Arbeit beschrieben, keine

12

3 Herausforderungen in betrieblichen Informationssystemen
dynamischen Datenstrukturen bietet, muss bereits zu Beginn sehr genau überdacht
werden, wie viele Daten ein System später gleichzeitig be- und verarbeiten soll. Die
befragten Experten gaben an, dass Wartungsaufträge teilweise lediglich damit zu tun
haben, dass Datenstrukturen – beispielsweise Arrays oder Strings – zu klein dimensioniert sind und künftig mehr oder längere Datensätze aufnehmen sollen. Herr Streit
bestätigte dies durch ein Beispiel aus der Praxis, bei dem eine vierstellige Nummer nicht
mehr ausreichend war, um Partnerunternehmen zu identifizieren. »Gelöst wurde das
dann [...] durch das Zulassen von Buchstaben, weil so der Speicherbedarf nicht erhöht
wurde und sich Datenstrukturen im Speicher nicht verschoben haben.« Dies illustriert
einen wichtigen Aspekt von Datenstrukturen in COBOL, der später genauer beleuchtet
wird: Obwohl solche Anpassungen, im Gegensatz zu Java, in COBOL vorkommen,
muss stets bedacht werden, wo Variablen im Speicher liegen, da andere Daten- und
Dateidefinitionen von dem bestehenden Aufbau der Datenstrukturen ausgehen.

3.2 Langlebigkeit, Wartbarkeit und Verlässlichkeit
Durch ihre hohe Komplexität werden betriebliche Informationssysteme i. d. R. über viele
Jahre oder sogar Jahrzehnte betrieben und dabei gewartet, erweitert und angepasst.
Um die Langlebigkeit, Wartbarkeit und Verlässlichkeit solcher Systeme sicherzustellen,
werden diese in der Praxis mehr oder weniger umfangreichen Tests unterzogen. Damit
kann beispielsweise sichergestellt werden, dass bestehender Code auch nach Erweiterungen weiterhin funktioniert. Eine der wichtigsten Techniken hierbei sind sogenannte
Unit-Tests. Dabei werden einzelne isolierte Einheiten getestet und so Einflüsse von
anderen Programmteilen minimiert.
In Java gibt es einige Frameworks, beispielsweise JUnit 5 oder Mockito6 , die das Testen
direkt oder indirekt unterstützen. Die Wartbarkeit begünstigt in Java zusätzlich das
relativ einfache Durchführen von Refactorings. So können Programme mithilfe von
modernen Entwicklungsumgebungen teilweise neu geschrieben bzw. strukturiert werden
und bestehender Code so im Zuge von Erweiterungen verbessert werden. Auch hierbei
sind Tests zur Überprüfung der Korrektheit von Vorteil.
COBOL bietet zum Testen weitaus weniger Möglichkeiten. Entwicklung, Testen und
Debuggen direkt am Host sind teuer, da die Kosten eines Mainframes oft nach Rechenzeit berechnet werden, und daher wurden, laut Herrn Lamperstorfer vor allem in
5
6

https://junit.org/ (besucht am 19.05.2018)
http://site.mockito.org/ (besucht am 19.05.2018)

13

3 Herausforderungen in betrieblichen Informationssystemen
frühen COBOL-Systemen, oftmals funktionierende und manuell getestete »Schablonen«
beispielsweise für die Dateiverarbeitung zur Erweiterung eines Systems wiederverwendet,
sodass diese nur minimal angepasst werden mussten. Auch Refactorings nehme man in
COBOL-Systemen tendenziell selten vor, da diese ein umfangreiches Testen erfordern
würden.
In puncto Verlässlichkeit können sich COBOL-Anwendungen jedoch oftmals auf gut
isolierte Infrastrukturen verlassen, die durch ihre Homogenität, wenig Fortentwicklung
und eingebaute Ausfallsicherheitsmaßnahmen eine zuverlässige Basis bieten. JavaSysteme hingegen werden auf vielen unterschiedlichen Plattformen betrieben, die sich
sehr schnelllebig verändern, wodurch zusätzliches Augenmerk auf die Sicherung der
oben genannten Eigenschaften gelegt werden muss.

3.3 Modularisierung, Wiederverwendbarkeit und
Variabilität
Weitere wichtige Punkte bei der Entwicklung von betrieblichen Informationssystemen
sind die Modularisierung und Wiederverwendbarkeit. Um ein System für die Zukunft
wart- und erweiterbar zu machen, ist eine gewisse Modularisierung anzustreben. Code
muss somit nicht mehrmals geschrieben werden, was auch das spätere Einarbeiten in
ein Projekt erleichtert, da der Projektumfang deutlich verringert werden kann.
Zudem ist, sei es um z. B. verschiedene Mandanten, Tarife oder Geschäftsjahre abzubilden, die im Grunde selbige Logik beinhalten, in betrieblichen Informationssystemen
häufig eine gewisse Variabilität gefordert. Auch diese kann durch Wiederverwendbarkeit
und Modularisierung stark begünstigt werden.

Java
Java ist eine hoch modulare Sprache. Objektorientierte Paradigmen wie Kapselung,
Polymorphie oder Aggregation/Komposition tragen dazu bei, dass Code wiederverwendet werden kann. Dabei ist vor allem die Gliederung in Klassen und Methoden, wie
Funktionen in Java gängigerweise genannte werden, ausschlaggebend. Des weiteren
können Bibliotheken als Java-Archive (kurz jar genannt) distribuiert und in anderen
Projekten wiederverwendet werden. Dieses Konzept nutzt auch die Programmiersprache

14

3 Herausforderungen in betrieblichen Informationssystemen
aus und stellt viele Funktionalitäten über Packages (siehe Abschnitt 4.1) bereit. Die
am häufigsten gebrauchten Bibliotheken sind dabei java.util, welche grundlegende
Datenstrukturen wie z. B. Listen (siehe Unterabschnitt 5.2.1) bereitstellt, java.io, die
Daten-Ein- und Ausgabe ermöglicht und allen voran java.lang, mit Ergänzungen zu
programmiersprachlichen Mitteln.
Diese Modularisierungsmöglichkeiten sorgen auch dafür, dass Java-Code variabel eingesetzt und bestehende Logik wiederverwendet oder beispielsweise durch Vererbung
minimal angepasst und nachträglich erweitert werden kann und führt dazu, dass Wartungen an Systemen, die sich auf Erweiterungen des Umfangs beziehen – z. B. das Einführen
eines neuen Tarifs – mit verhältnismäßig geringem Aufwand umgesetzt werden können.
Ein weiterer Punkt, der Java-Code wiederverwendbar macht, ist die Tatsache, dass
dieser in plattformunabhängigen Byte-Code übersetzt wird. Die Java-Virtual-Machine
(JVM ) führt dann diesen Byte-Code aus und sorgt so dafür, dass bereits kompilierte
Programme auf allen Systemen mit JVM ausführbar sind und weiterverteilt werden
können, ohne neu kompiliert werden zu müssen.

COBOL
Im Gegensatz zu Java lässt COBOL ein weitreichendes Modularisierungskonzept vermissen. Wie später in Unterabschnitt 4.4.2 genauer nachzulesen ist, fehlen grundlegende Spracheigenschaften, um die Wiederverwendbarkeit von Code sicherzustellen.
Der typische Ansatz von COBOL ist daher, Funktionalität über Schlüsselwörter statt
durch Bibliotheken bereitzustellen. Allerdings stößt dies unweigerlich an Grenzen, da
logischerweise nicht jede Datenstruktur und jeder Algorithmus als Teil der Sprache
implementiert werden kann. Die Sprache bietet also grundsätzlich mehr Funktionalität
durch Schlüsselwörter als Java, lässt sich im Gegensatz dazu aber schwerer erweitern.
COBOL bietet zudem die Möglichkeit Unterprogramme aufzurufen, welche Logik und
Daten kapseln und so wiederverwendbar machen. Auch denkbar sind sogenannte Copybooks. Dabei handelt es sich um ein ähnliches Konzept wie Headerdateien in C++,
also Dateien, deren Inhalt durch den Compiler vor dem Übersetzen an andere Stellen
kopiert wird. Diese werden in Abschnitt 5.1 näher beschrieben.
Diese vorgestellten Konzepte sind jedoch nur begrenzt für die generelle Wiederverwendung von Code geeignet. Wie Herr Lamperstorfer betonte, sieht man daher in der Praxis

15

3 Herausforderungen in betrieblichen Informationssystemen
oftmals Code-Blöcke, die ein und die selbe Logik abbilden, aber durch die Verwendung
von anderen Daten nochmals im Copy-Paste-Stil in den Code integriert werden, was
für viel Redundanz sorgt. Dies ist auf das fehlende Bibliothekskonzept zurückzuführen.
Weiter merkte Herr Lamperstorfer an, dass es womöglich auch an der fehlenden Erfahrung und Ausbildung der Entwickler lag, dass solche Vorgehensweisen häufig verwendet
wurden. Außerdem sei der Wartungsaufwand zur Entstehungszeit vieler bestehender
Systeme nicht in dem heute erforderlichen Ausmaß abzusehen gewesen.
Die fehlende Modularisierung sorgt auch dafür, dass COBOL wenig Variabilität im
Vergleich zu Java bietet. Code muss oftmals kopiert werden, um ähnliche Funktionalität
abzubilden und so fallen Anpassungen von bestehenden Systemen in diesem Bereich
unverhältnismäßig groß aus. Dieses Kopieren sieht man an dieser Stelle häufig, da bestehende Funktionalität – wie in Abschnitt 3.2 beschrieben – nur teuer und umständlich
einem Refactoring unterzogen und so bereits getesteter Code mit wenigen Anpassungen
wiederverwendet werden kann.
Um diese Redundanzen zu vermeiden, werden teilweise Datenstrukturen für mehr als
nur einen Zweck im Programm »missbraucht«. Darunter leidet die Les- und Wartbarkeit
von COBOL-Code sehr, da häufig nicht klar ist, welche Daten in welchem Kontext wie
verwendet werden. Zu diesem Thema sei auf Abschnitt 4.7 verwiesen.
Zwar unterstützt COBOL in neueren Standards eine objektorientierte Entwicklung,
durch die Konzepte zur Modularisierung und Wiederverwendung bereitgestellt werden,
jedoch ist diese Spracherweiterung in der Praxis irrelevant. Die meisten gängigen Systeme,
auf denen COBOL Programme betrieben werden, verfügen nicht über derartig neue
Compiler und auch bei der Verwendung merkt man, dass diese Konzepte nachträglich
hinzugefügt wurden und eigentlich nicht Bestandteil der Sprache sind. Hat man das
Glück, ein System mit einem kompatiblen Compiler zu haben, so bleibt als weiterer
Stolperstein der Fakt, dass die ohnehin raren COBOL-Entwickler in der Verwendung
objektorientierter Konzepte nicht firm sind. Daher wird diese Spracherweiterung in der
vorliegenden Arbeit nicht behandelt.
Ein Bibliothekskonzept ist also in COBOL nicht vorhanden und so werden Programme
und aufgerufene Unterprogramme beim Kompilieren statisch zu einer ausführbaren
Einheit gelinkt. Um dieses Verhalten zumindest soweit zu beeinflussen, dass dynamisch
geladene Unterprogramme entstehen, kann als »Trick« eine Variable eingeführt werden,
welche den Namen des Unterprogramms enthält. Wird nun das Programm aufgerufen,
welches in dieser Variable und nicht in einer festen Zeichenkette definiert ist, nimmt der
Compiler an, dass das geladene Unterprogramm variieren kann – auch wenn der Inhalt

16

3 Herausforderungen in betrieblichen Informationssystemen
der Variablen nicht verändert wird – und vermeidet so ein statisches Linken. Damit
lässt sich erreichen, dass nur Teile von Programmen bei Änderungen neu übersetzt
werden müssen.

3.4 Darstellungsgenauigkeit – Binäre und dezimale
Kommaarithmetik
Vor allem in betrieblichen Informationssystemen – die oftmals Geldbeträge durch eine
gewisse Anzahl von Rechenschritten errechnen – ist es unerlässlich, einen Blick auf
die Rechengenauigkeit des Systems und der verwendeten Sprachen zu werfen. Diese
ist oftmals eine Folge der Speicherrepräsentation rationaler Zahlen, die erheblichen
Einfluss auf den Darstellungsbereich hat. Man unterscheidet grundsätzlich zwischen
Speicherungen in Fließ- und Festkomma-Darstellung.

Fließkommaarithmetik
In modernen Programmiersprachen wie Java werden Datentypen für rationale Zahlen in
der Fließkommarepräsentation gespeichert. Daher auch der Name float (engl. »floating
point«). Diese Darstellung hat den großen Vorteil, dass sowohl kleine Zahlen, die gegen
Null gehen, als auch sehr große Zahlen mit dem gleichen Speicherbedarf dargestellt
werden können, da quasi das Trennzeichen der Vor- und Nachkommastellen verschoben
wird. Java verwendet zur Darstellung standardmäßig den Datentypen double, ein float
mit doppelter Darstellungsgenauigkeit bzw. doppeltem Speicherbedarf, der es ermöglicht,
als kleinsten Absolutwert 2−1074 und als größten (2 − 2−52 ) · 21023 darzustellen.
Diese Fließkommatypen werden zur Basis 2 berechnet und heißen daher auch binäre
Fließkommatypen. Dabei werden Zahlen nach IEEE 754 -Standard in Vorzeichen, Exponent und Mantisse umgerechnet und gespeichert. Ohne näher auf diesen eingehen
zu wollen, kann angemerkt werden, dass dieser einen Algorithmus festlegt, mit dessen Hilfe Variablen in einem Speicherbereich repräsentiert werden. Auch die Größe
dieses Speicherbereichs ist durch den Standard vorgegeben und daher fest. Dadurch
und durch den Umstand, dass sowohl Exponent als auch Mantisse ins Dualsystem
umgerechnet werden, ergibt sich die Problematik, dass eine Dezimalzahl u. U. nicht
exakt repräsentiert und lediglich die nächste Repräsentation gespeichert werden kann,
da eine Kommaverschiebung nur um dyadische Zahlenwerte passieren kann. Dieser

17

3 Herausforderungen in betrieblichen Informationssystemen
Effekt ist schwer absehbar und kann in der Praxis zu ungenauen (Zwischen-)Ergebnissen
führen.
public class PrecisionExample {

1
2

public static void main(String[] args) {
float number = 0.5f;
int numberInt = Float.floatToIntBits(number);
printFloatAndBinary(number, numberInt);

3
4
5
6
7

numberInt++;
number = Float.intBitsToFloat(numberInt);
printFloatAndBinary(number, numberInt);

8
9
10
11

number = 0.50000002f;
numberInt = Float.floatToIntBits(number);
printFloatAndBinary(number, numberInt);

12
13
14

}

15
16

public static void printFloatAndBinary(float number, int binary) {
System.out.println(
String.format("%.8f = %s", number,
Integer.toBinaryString(binary))
);
}

17
18
19
20
21
22

}

23

1

$ java PrecisionExample

2

0,50000000 = 111111000000000000000000000000

3

0,50000006 = 111111000000000000000000000001

4

0,50000000 = 111111000000000000000000000000

Listing 3.1: Ungenauigkeit am Beispiel einer float-Variable

Listing 3.1 illustriert beispielhaft, wie die Repräsentation eines Wertes vom tatsächlichen abweichen kann. Die erste Ausgabe des Programms stellt den float-Wert 0, 5
in binärer Speicherrepräsentation dar. Diese wurde für die zweite Ausgabe um die
kleinstmögliche Einheit, einen Bitwert, erhöht. Die nächstgrößere darstellbare Zahl
ist demnach 0, 50000006, was bedeutet, dass keine Zahlenwerte dazwischen abgebildet
werden können. Bei der dritten Ausgabe wird gezeigt, dass sich der Wert 0, 50000002

18

3 Herausforderungen in betrieblichen Informationssystemen
nicht als float darstellen lässt, sondern die nächstmögliche Repräsentation 0, 5 gewählt
wird.
Durch die Weiterverwendung eines solchen, nicht-exakt repräsentierten Werts würden
sich unter Umständen Folgefehler in Berechnungen ergeben. Außerdem können Vergleiche
von Zahlen, insbesondere von Berechnungsergebnissen, dadurch fehlerbehaftet sein,
weshalb Fließkommadaten stets auf ein Werteintervall statt auf Gleichheit geprüft
werden sollten.
In der java.math-Bibliothek findet sich jedoch auch ein Objekttyp BigDecimal, welcher einen Fließkommawert zur Basis 10 – ein dezimales Fließkomma – darstellt. Die
Speicherung beruht indessen auf zwei Integer-Werten, die einen unskalierten Faktor und einen Exponenten zur Skalierung repräsentieren. Außerdem ist dieser Typ
steuerbar was die Rundung, die Exaktheit von Ergebnissen und das Verhalten bei
nicht-darstellbaren Werten angeht. Hierbei lässt sich festhalten, dass BigDecimals nur
über andere BigDecimal-Objekte oder Strings zuverlässig instanziiert werden können,
da andere Konstruktoren die übergebenen Werte in Datentypen zwischenspeichern, die
zu eben diese ungewünschten Fehlern in der Repräsentation führen. BigDecimal bietet
somit eine Möglichkeit, Dezimalwerte exakt abzuspeichern. Mit diesem Objekttypen
gehen jedoch Speicher- und Laufzeit-Overheads einher, die nicht vernachlässigt werden
dürfen. Außerdem müssen Zwischenergebnisse i. d. R. zusätzlich abgeschnitten oder gerundet werden, da der BigDecimal-Typ keine festgelegte Anzahl an Nachkommastellen
hat und diese sich durch Berechnungen verändern können.

Festkommaarithmetik
Um die angesprochenen Probleme mit binären Fließkommatypen zu umgehen, verwenden
manche Sprachen Festkommaarithmetik, um rationale Zahlen zu speichern, oder bieten
zumindest Datentypen, um eine derartige Speicherrepräsentation zu erreichen.
Dabei wird im Gegensatz zu Fließkommazahlen festgelegt, wie viele Stellen einer Zahl
vor- bzw. nach dem Komma gespeichert werden. Jede Ziffer wird dabei für sich – je
nach Implementierung durch eine bestimmte Codierung – gespeichert und erlaubt somit
absolute Genauigkeit im Werte- bzw. Darstellungsbereich. Auch ist der Umgang mit
Überläufen fest definiert und führt zu konsistentem und abschätzbarem Verhalten.
COBOL verwendet diese Festkommaarithmetik. Ergebnisse werden zur Speicherung
»abgeschnitten«, außer man definiert explizit, dass gerundet wird. Listing 3.2 enthält

19

3 Herausforderungen in betrieblichen Informationssystemen
Beispiele zu beiden Varianten. PIC 9V9(2) deklariert eine Variable mit genau einer
Vor- und zwei Nachkommastellen. Damit wäre beispielsweise sichergestellt, dass alle
Geldbeträge < 10 – auch nach Berechnungen – korrekt dargestellt werden können.
Da Ergebnisse zeichenweise gespeichert werden und so keine Rundungsfehler oder
Fehler aufgrund von unzureichendem Speicherplatz zur Abbildung zulassen, ergibt
sich jedoch ein erhöhter Speicherbedarf. Dieser kann in COBOL jedoch zum Beispiel
durch das Nutzen von PACKED DECIMALs mit dem Schlüsselwort COMP-3 hinter der
PICTURE-Anweisung reduziert werden. Hierbei wird lediglich ein Nibble (1/2 Byte) pro
Ziffer benötigt.
IDENTIFICATION DIVISION.
PROGRAM-ID. PRECISION-EXAMPLE.
DATA DIVISION.
FILE SECTION.
WORKING-STORAGE SECTION.
01 TWO-DECIMALS-VALUE PIC 9V9(2) VALUE 0.50.
01 THREE-DECIMALS-VALUE PIC 9V9(3) VALUE 0.499.
01 RESULT PIC 9V9(2) VALUE ZERO.
PROCEDURE DIVISION.
MAIN-PROCEDURE.
COMPUTE RESULT =
TWO-DECIMALS-VALUE + THREE-DECIMALS-VALUE.
DISPLAY RESULT.
COMPUTE RESULT ROUNDED =
TWO-DECIMALS-VALUE + THREE-DECIMALS-VALUE.
DISPLAY RESULT.
STOP RUN.
END PROGRAM PRECISION-EXAMPLE.

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18

1

0.99

2

1.00

Listing 3.2: Dezimalzahlen in COBOL

20

3 Herausforderungen in betrieblichen Informationssystemen

In betrieblichen Informationssystemen und speziell bei der Verarbeitung von Geldbeträgen ist es unerlässlich, die Sicherheit
einer exakten Darstellung von Werten zu haben. Während die
binäre Fließkommadarstellung Speicherplatz-Vorteile und eine
Abschnitt 3.4 Flexibilität des Wertebereichs einer Zahl bietet, jedoch Werte
unter Umständen nicht exakt repräsentieren kann, stellt eine
Festkommaarithmetik sicher, dass Zahlen exakt und vorhersehbar repräsentiert
werden. Dies wird durch erhöhten Speicherbereich und fehlende Flexibilität
erkauft, ist jedoch in der Praxis oftmals unerlässlich. Eine Möglichkeit, diese
Sicherheit in Java zu erreichen, ist das Nutzen des BigDecimal-Typen, der viele
Nachteile und vor allem Unsicherheiten gegenüber binären Fließkommatypen,
durch eine dezimale Fließkommarepräsentation, aus dem Weg räumt. Jedoch
führt dieser unter Umständen zu Performanz- bzw. Speichereinbußen und bedarf
u. U. nach Berechnungen weiterer Bearbeitung. COBOL bietet mit Verwendung
der Festkommaarithmetik bereits standardmäßig eine Darstellungssicherheit und
Vorhersagbarkeit von Dezimalzahlen, die vielen modernen Sprachen fehlt.

3.5 Datenquellen
Kernaspekte von Informationssystemen sind die Daten-Ein- und Ausgabe. Neben Dateien, deren Verwendung später in Abschnitt 4.5 beschrieben wird, und Dateisystemen,
stellen dabei Datenbanken eine gebräuchliche Art der Datenhaltung dar.
Um Zugriff auf Daten innerhalb einer Datenbank zu erhalten, bietet Java mit der
»Java Database Connectivity« API standardisierte Mechanismen, um auf Datenbanken
zuzugreifen. Darauf aufbauend existieren Abstraktionsschichten wie Hibernate 7 , die eine
Abbildung von Entitäten der Datenbank auf Java-Klassen ermöglichen.
In COBOL können Datenbankabfragen mithilfe des EXEC SQL-Befehls erfolgen. Damit
lässt sich der betreffende SQL-Code direkt innerhalb des COBOL-Codes formulieren
und Werte aus Variablen nutzen bzw. in diese schreiben. Die Einbettung des SQL-Codes
in COBOL macht es, im Gegensatz zu Java, möglich, dass bereits der Compiler die
Syntax der SQL-Abfragen überprüfen kann. Dies ist mit Language Integrated Querys
in C# zu vergleichen. Herr Bonev bemerkte hierzu, dass diese Datenbankabfragen
7

http://hibernate.org/ (besucht am 19.05.2018)

21

3 Herausforderungen in betrieblichen Informationssystemen
oft Optimierungsmöglichkeiten bieten, da oft zu beobachten sei, dass Entwickler auf
einfache Datenbankabfragen zurückgreifen und eine eventuelle Datenfilterung erst später
innerhalb des Programms geschehe. Diese Filterung ist jedoch auch direkt durch eine
geeignete Datenbankabfrage zu erreichen, was sehr viel performanter sei.
Im Hinblick auf Datenquellen machen betriebliche Informationssysteme mit COBOL
oftmals vom Eingabe-Verarbeitung-Ausgabe-Prinzip, kurz EVA-Prinzip, Gebrauch. Dabei
wird ein Arbeitsvorgang in verschiedene Schritte unterteilt, die nacheinander ausgeführt
werden. Am Ende jedes Schrittes steht die Ausgabe der (Zwischen-)Ergebnisse, sodass
der darauffolgende diese weiterverarbeiten kann. Um diese einzelnen Schritte zu steuern
behilft man sich der Job Control Language, kurz JCL. Diese Skriptsprache steuert die
angesprochenen Stapelverarbeitungsvorgänge, engl. Batch-Jobs, und sorgt für die Einund Ausgabe von Daten, auch Reporting genannt.
Durch das EVA-Prinzip und die Tatsache, dass Host-Computer über sehr stark optimierte Datei-Ein- und Ausgabe verfügen, seien Datenbanken, laut Herrn Lamperstorfer,
in COBOL weniger relevant.

3.6 Schnittstellen
In betrieblichen Informationssystemen stellen außerdem Schnittstellen ein wichtiges
Thema dar. Sowohl das Bereitstellen von standardisierten und dokumentierten Interfaces
als auch das Nutzen von anderen Systemen über ihre Schnittstellen ist stets Teil aller
Anwendungsfälle.
Vor allem in der heutigen Zeit, in der Informationssysteme nicht mehr als alleinige
Verarbeitungs-, Reporting- und Darstellungsschicht fungieren, sondern eingebettet in
einen größeren Kontext aus verschiedensten Modulen, mobilen Applikationen und
Websites funktionieren und mit diesen kommunizieren müssen, ist ein ausgereiftes
Schnittstellenkonzept und die standardisierte Bereitstellung und Nutzung von Daten
und Diensten unerlässlich.
Für Java sind eine Fülle an Bibliotheken erhältlich, welche Netzwerkkommunikation über
verschiedenste Protokolle auf unterschiedlichen Ebenen ermöglichen. Neben diversen
verfügbaren Fremdbibliotheken bietet bereits das JDK unterschiedliche Methoden zur
Kommunikation mit Fremdsystemen.

22

3 Herausforderungen in betrieblichen Informationssystemen
Zudem ist es durch die Definition von Interfaces auch auf Klassenebene möglich,
Schnittstellen zu bieten, die eine einfache Erweiterung von und Verbindungen zu
Neusystemen möglich machen.
COBOL hingegen lässt hierfür einige Funktionalität vermissen. Durch das fehlende
Bibliothekskonzept – wie in Abschnitt 3.3 erläutert – und das gänzliche Fehlen von
Netzwerkkommunikationsmechanismen ist es in reinem COBOL nicht möglich, Netzwerkschnittstellen festzulegen, die von außen erreichbar sind, oder solche zu verwenden.
COBOL-Systeme nutzen daher i. d. R. Systemmodule, um Aufgaben, wie die Netzwerkkommunikation, zu erledigen, die mit reinem COBOL nicht möglich oder aufwendig
sind. Außerdem erfordern diese Systeme nicht selten Anpassungen in anderen Systemen,
auch wenn es nicht sinnvoll erscheint.
Auch intern kann ein COBOL-System nur bedingt Standards definieren, die zwischen
unterschiedlichen Programmteilen für einheitliche Kommunikationskanäle sorgen. Allerdings basieren COBOL-Systeme, wie Abschnitt 3.5 beschreibt, auf einfachen EVAPrinzipien, weshalb Schnittstellen in der Stapelverarbeitung datenbasiert seien, wie
Herr Lamperstorfer festhielt. Diese Eigenschaft ist jedoch mehr dem Host-Umfeld
zuzuschreiben als der Sprache COBOL.
Mit Tools wie IBM MQ, zuvor WebSphere MQ, 8 können Systeme allerdings so verbunden
werden, dass sie miteinander kommunizieren können. Laut Herrn Lamperstorfer lässt sich
damit »technisch einfach« eine Verbindung zwischen Alt- und Neusystemen herstellen,
diese sei jedoch fachlich und im Hinblick auf Performanz recht schwierig umzusetzen.

8

https://www.ibm.com/de-de/marketplace/secure-messaging (besucht am 19.05.2018)

23

4 Vergleich wichtiger Sprachkonzepte

4 Vergleich wichtiger Sprachkonzepte

4.1 Programmstruktur
Dieser Abschnitt behandelt die strukturellen Unterschiede von Java- und COBOLProgrammen. Dazu wird erläutert, in welche Einheiten sich die Programme der jeweiligen
Sprache aufteilen lassen.

Struktur eines Javaprogramms
Abbildung 4.1 gibt einen zusammenfassenden Überblick über die Teile eines JavaProgramms und bildet graphisch ab, wie sich die jeweiligen Komponenten zusammensetzen können.
Java Programm
Packages
Klassen
Funktionen / Methoden

Geschachtelte Klassen

Statement
Anonyme Klasse

Abbildung 4.1: Strukturelle Bestandteile eines Java-Programms

24

4 Vergleich wichtiger Sprachkonzepte
Anhand dieses Diagramms werden die wichtigsten Konzepte der Strukturierung von JavaCode aufgezeigt. Die erste Zeile einer Quelldatei beinhaltet die Package-Deklaration,
d. h. hiermit wird die Klasse dem genannten Package zugeordnet. Diese Deklaration
muss gleich der Ordnerhierarchie sein, in denen die Java-Dateien verwaltet werden.
Die nächstkleinere Einheiten eines Java-Programms stellen Klassen dar, von denen
Objekte instanziiert werden können. Hierbei handelt es sich um das Kernkonzept der
objektorientierten Programmierung. Um einen tieferen Einblick in diese Thematik zu
erhalten, sei auf einschlägige Fachliteratur verwiesen. Diese Klasse muss dabei in einer
Datei gespeichert sein, die den selben Namen trägt wie die Klasse selbst. Die Klasse
MasterThesis muss daher in der Datei MasterThesis.java stehen.

1

package de.masterthesis.augsburg;

2
3

public class Initializer {

4

static { // static initializer
System.out.println("Executed once for class on load");
}

5
6
7
8

{

9
10

// initializer
System.out.println("Called once for every instance");

}

11
12

public Initializer() {
System.out.println("Executed after all initializers");
}

13
14
15
16

public static void main(String[] args) {
System.out.println("main: start");
Initializer initializer = new Initializer();
System.out.println("main: termination");
}

17
18
19
20
21
22

}

Listing 4.1: Initializer in Java

Teil dieser Klassen können Funktionen, in Java oft Methoden genannt, Variablendeklarationen und weitere Klassen sein. Diese inneren Klassen haben strukturell die
selben Eigenschaften wie die umgebende Klasse. Die Bestandteile einer Klasse können
jeweils statisch oder auch einer Instanz zugeordnet sein. Auch dabei handelt es sich um

25

4 Vergleich wichtiger Sprachkonzepte
ein gängiges Konzept der objektorientierten Softwareentwicklung. Statische Methoden,
Variablen und Klassen können Teil einer Klasse sein und benötigen kein konkret instanziiertes Objekt, während nicht-statische Komponenten stets ein konkretes Objekt einer
Klasse benötigen.
Methoden wiederum bestehen aus einzelnen Statements. Variablendeklarationen stellen
auch Statements dar und sind an jeder Stelle innerhalb einer Klasse möglich, während
andere Statements als Teil einer Klasse nur dann gültig sind, wenn diese in geschweiften
Klammern stehen. Diese Blöcke werden – der Reihe nach – vor jedem Konstruktoraufruf
ausgeführt und heißen deshalb auch Initializer. Auch ist die Definition von statischen
Initializer möglich, die einmalig nach dem Laden einer Klasse ausgeführt werden.
Listing 4.1 führt Beispiele dafür an.
Statements, die aus Variablendeklarationen, Zuweisungen oder Methodenaufrufen bestehen, müssen im Gegensatz zu Block-Statements, wie z. B. Schleifen oder Verzweigungen,
stets mit einem Semikolon beendet werden.

1

package de.masterthesis;

2
3
4

import java.util.function.IntConsumer;
import java.util.stream.IntStream;

5
6

public class AnonymousClassAndMethodExample {

7

public static void main(String[] args) {
IntStream.range(0, 10).forEach(new IntConsumer() {
@Override
public void accept(int value) {
System.out.print(value + " ");
}
});
System.out.println();
IntStream.range(0, 10).forEach(value -> {
System.out.print(value + " ");
});
}

8
9
10
11
12
13
14
15
16
17
18
19
20

}

Listing 4.2: Anonyme Klassen und Funktion in Java

26

4 Vergleich wichtiger Sprachkonzepte
Die letzten strukturellen Elemente sind anonyme Klassen und Funktionen, auch LambdaFunktionen genannt, wobei anonyme Funktionen in Java genau genommen nur eine
syntaktische Schreibweise einer speziellen anonymen Klasse sind. Die Verwendung
wird in Listing 4.2 illustriert. Die Zeilen 9 – 14 beinhalten eine anonyme Klasse, die
das IntConsumer-Interface implementiert. Die völlig identische anonyme Klasse wird
implizit durch die Lambda-Funktion in den Zeilen 16 – 18 implementiert.
Neben der inhaltlichen Struktur kann festgehalten werden, dass Java Programme nur
wenigen festen Formatierungsregeln folgen müssen. Neben den Eigenschaften, dass die
Package-Deklaration vor Imports stehen, und diese wiederum vor der ersten Klasse
stehen müssen, können Java-Programme nahezu beliebig formatiert werden.

Struktur eines COBOL-Programms
COBOL Programm
Divisions
Sections
Paragraphs
Sentences
Statements

Abbildung 4.2: Strukturelle Bestandteile eines COBOL-Programms

Abbildung 4.2 zeigt die strukturellen Bestandteile eines COBOL-Programms. Ein
Programm besteht dabei aus vier fest definierten Divisions:
• IDENTIFICATION DIVISION – Hier werden grundlegende Daten zum Programm
wie der Name oder der Autor festgelegt.

27

4 Vergleich wichtiger Sprachkonzepte
• ENVIRONMENT DIVISION – Definiert die Ein- und Ausgabe sowie Konfigurationen
der Systemumgebung.
• DATA DIVISION – Diese Division beinhaltet die Definitionen von Daten. Dazu
zählen Variablen oder auch Datei-Record-Definitionen.
• PROCEDURE DIVISION – Innerhalb dieser Division befindet sich der ausführbare
Code.
Eine Division – außer der IDENTIFICATION DIVISION – kann wiederum aus verschiedenen Sections bestehen, wobei diese nur innerhalb der PROCEDURE DIVISION frei definiert
werden können.
Die ENVIRONMENT DIVISION kann zwei verschiedene Sections enthalten. Definitionen
zum Zielsystem finden sich innerhalb der CONFIGURATION SECTION und Angaben zu
Dateizugriffen sowie zu Ein- und Ausgabeoperationen in der INPUT-OUTPUT SECTION.

1
2
3
4
5

ENVIRONMENT DIVISION.
CONFIGURATION SECTION.
SPECIAL-NAMES.
DECIMAL-POINT IS COMMA.
CLASS VALID-NAME-CHARACTERS IS 'a' THRU 'z' 'A' THRU 'Z' ' '.

Listing 4.3: SPECIAL-NAMES Paragraph in COBOL

Erwähnenswert hierbei ist der SPECIAL-NAMES Paragraph der CONFIGURATION SECTION.
Darin können Definitionen vorgenommen werden, die u. a. Auswirkungen auf die Syntax
haben können. Listing 4.3 beinhaltet die Neudefinition des Dezimaltrennzeichens und
die Definition einer Klasse von Werten, die in diesem Beispiel valide Werte eines
Zeichens innerhalb von Namen darstellen. Diese Klassen sind jedoch nicht mit dem
objektorientierten Konzept einer Klasse zu vergleichen.
Teil der DATA DIVISION sind folgende Sections:
• FILE SECTION – Definiert Dateien bzw. Dateischemata, auf die im Programm
zugegriffen wird.

28

4 Vergleich wichtiger Sprachkonzepte
• WORKING-STORAGE SECTION – Enthält Variablendeklarationen, welche über mehrere Programmaufrufe hinweg bestehen bleiben.
• LOCAL-STORAGE SECTION – Enthält Variablendeklarationen, die bei jedem Programmaufrufe neu alloziert werden.
• LINKAGE SECTION – Enthält Definitionen von Variablen, welche bei einem Programmaufruf von außen übergeben werden können.
In der PROCEDURE DIVISION finden sich schließlich vom Entwickler definierte Sections,
welche ein COBOL-Pendant zu Funktionen in Java darstellen.
Die nächstkleinere Einheit eines COBOL-Programms stellen Paragraphs dar. Diese
lassen sich – mit kleinen Unterschieden – im Allgemeinen wie Sections verwenden.
In bestehenden COBOL-Programmen lassen sich daher zwei unterschiedliche Stile
beobachten. Auf der einen Seite gibt es Programme, die lediglich aus Paragraphs
bestehen, und auf der anderen existieren Systeme, in denen Sections verwendet wurden
und durch Paragraphs untergliedert sind. Generell ist zweitere Variante vorzuziehen,
wie auch Richards in „Enhancing Cobol program structure“ [20] beschreibt, da dadurch
sowohl die Programmstruktur lesbarer als auch die Fehleranfälligkeit verringert wird.
Auf beide Eigenschaften wird im weiteren Verlauf der Arbeit eingegangen.
Sections und Paragraphs können wiederum aus Sentences bestehen. Dabei handelt es sich
um ein oder mehr Statements. Ein Sentence wird stets von einem Punkt abgeschlossen.
Während Sections und Paragraphs Analogien zu Methoden in Java sind, kann man
Sentences am ehesten mit Block-Statements – sobald diese geschachtelt werden, stimmt
diese Analogie nicht mehr – und Statements mit Semikolon-terminierten Statements
in Java vergleichen. Herr Streit merkte dazu im Interview an, dass darauf zu achten
sei, dass diese Punkte keine Semantik transportieren. Dies lässt sich dadurch erreichen,
dass Statements wenn möglich durch das korrespondierende END-Statement (z. B. IF →
END IF) abgeschlossen werden. Dadurch unterbindet der Compiler die Nutzung von
Punkten innerhalb der Konstrukte, welche die Semantik ändern würden.
COBOL-Programme lassen sich nicht beliebig formatieren. So folgt ein COBOL-Programm einem festgelegten spaltenweisen Aufbau:
• Spalte 1 – 6 – In diesen Spalten befindet sich die sog. Sequenznummer. Damit
können Programmzeilen nummeriert werden. Da der Zeichensatz dafür dem

29

4 Vergleich wichtiger Sprachkonzepte
zugrundeliegenden System entspricht, können Zeilen auch beispielsweise mit
Buchstaben versehen werden.
• Spalte 7 – In dieser Spalte kann ein Zeichen gesetzt werden, um dem Compiler die
Bedeutung der Zeile kenntlich zu machen. Ein * leitet z. B. eine Kommentarzeile
ein und durch - kann die vorherige Zeile fortgeführt werden.
• Spalte 8 – 11 und Spalte 12 – 72 – Diese Spalten enthalten Definitionen
und ausführbaren Programmcode. Je nach COBOL-Dialekt sind diese beiden
Bereiche jedoch im Hinblick auf Variablendeklarationen unterschiedlich. Während
in ersterem nur die Stufennummern 01 und 77 deklariert werden dürfen, müssen
alle anderen in dem Bereich ab Spalte 12 stehen. Dies gilt jedoch nicht auf allen
Systemen.
• Spalte 73 – 80 – In klassischem COBOL dienen diese Spalten dazu, Kommentare
zur aktuellen Zeile einzufügen. Wie Herr Streit betonte, sind diese in Altsystemen exzessiv genutzt, um Versionsinformationen – wie Änderungsdatum oder
Ticketnummern – festzuhalten, sollten jedoch zum Wohl der Übersichtlichkeit
entfernt und im Zuge einer Renovierung oder Migration durch eine modernen
Versionsverwaltung, wie z. B. SVN oder Git, ersetzt werden. Auch ein Änderungsvergleich zwischen Programmversionen in einem entsprechenden Werkzeug wird
durch diese Kommentare erheblich erschwert. Wichtig ist es jedoch zu verstehen,
dass diese Kommentare, zu Zeiten, in denen es keine Versionsverwaltungssoftware
gab, sinnvoll waren.
Im sogenannten Free-Format, welches von einigen COBOL-Dialekten unterstützt wird,
gelten diese Beschränkungen nicht. Dabei gilt lediglich, dass Spalte 1 wie Spalte 7 zur
Kennzeichnung von Kommentaren fungiert. Auch die Breite eine Zeile kann hierbei, im
Gegensatz zum klassischen COBOL, 80 Zeichen überschreiten.

4.2 Variablen und Datentypen
Eine wichtiges Sprachmittel von Programmiersprachen ist die Verwendungsmöglichkeit
von Variablen. Je nach Programmiersprache haben diese Variablen unterschiedliche
Eigenschaften und werden verschieden deklariert, initialisiert bzw. definiert. Dieser
Abschnitt soll die Unterschiede dabei zwischen COBOL und Java herausarbeiten.

30

4 Vergleich wichtiger Sprachkonzepte

Variablen in Java
Eine Variable in Java hat stets einen bestimmten Datentypen. Dies können primitive
Datentypen – float, double, byte, char, short, int, long, boolean – aber auch
komplexe Objekttypen sein. Variablen primitiver Zahltypen haben dabei stets ein Vorzeichen. Außerdem gibt es zu jedem primitiven Datentypen einen Objekttypen, sogenannte
Wrapper-Klassen. Die Konvertierung zwischen diesen Typen erfolgt automatisch vom
Compiler und nennt sich Autoboxing und Unboxing.

1

public class VariableExample {

2

final int CONSTANT_VARIABLE = 1907;
int primitiveClassVariable = 0;
VariableExample complexClassVariable = null;

3
4
5
6

public static void main(String[] args) {
// CONSTANT_VARIABLE = 1860 -> Fehler
int primitiveLocalVariable = 1;
VariableExample complexLocalVariable = new VariableExample();
}

7
8
9
10
11
12
13

}

Listing 4.4: Variablendeklarationen in Java

Listing 4.4 soll einige Konzepte der Variablendeklaration und -definition verdeutlichen:
• Variablen können sowohl als Teil einer Klasse als auch lokal innerhalb einer
Methode deklariert werden.
• Variablen mit dem Modifier final sind Konstanten und können nicht mehr
geändert werden.
• Die Deklaration erfolgt nach dem Muster »hDatentypi hVariablennamei«.
• Die Initialisierung einer Variable geschieht durch das Zuweisen eines Wertes.

31

4 Vergleich wichtiger Sprachkonzepte
• Komplexe Objekttypen können den Wert null haben. Das bedeutet, die Variable,
die in diesem Fall eine Referenz auf einen Speicherbereich darstellt, ist leer. Hier
gilt es zu beachten, dass primitive Datentypen nicht null sein können.
• Instanzen eines Objekttypen werden durch das Schlüsselwort new und den Aufruf
eines Konstruktors erzeugt. Dieses Schlüsselwort sorgt für die dynamische Allokation von Speicherbereich. Im Gegensatz dazu wird der Speicherplatz für primitive
Datentypen, welche keine Konstruktoren besitzen, statisch reserviert.
Die Deklaration von Variablen bestimmter Datentypen sorgt dafür, dass ausreichend
Speicherplatz für diese reserviert wird. Die Stelle der Deklaration im Code ist dabei frei
wählbar und muss lediglich vor der ersten Verwendung stehen.
Der sog. Scope, zu deutsch Gültigkeitsbereich, gibt in der Programmierung an, in
welchem Bereich eine Variable gültig ist. In Java ist der Scope einer Variablen meist
einfach zu erkennen. Eine Variable ist innerhalb der geschweiften Klammern gültig, die
die Variablendeklaration beinhalten. Dies verdeutlicht Listing 4.5.

1
2

public class ScopeExample {
int memberAndLocalVariable;

3
4
5
6
7
8
9
10
11
12

void memberFunction(int parameter) {
// innerMemberVariable = 0; -> Ungültig
int memberAndLocalVariable = 0;
{ // int memberAndLocalVariable = 1; -> Ungültig
int localVariable;
}
int localVariable;
this.memberAndLocalVariable = 0;
}

13
14
15
16
17

void otherMemberFunction() {
// parameter = 0; -> Ungültig
this.memberAndLocalVariable = 0;
}

18
19
20

class InnerClass {
int innerMemberVariable;

21
22
23
24

void innerMemberFunction(int innerParameter) {
ScopeExample.this.memberAndLocalVariable = 0;
innerParameter = 0;

32

4 Vergleich wichtiger Sprachkonzepte

}

25

}

26
27

}

Listing 4.5: Variablendeklarationen mit verschiedenen Scopes

Das Attribut memberVariable ist innerhalb der gesamten Klasse ScopeExample und
somit in jeder enthaltenen Methode, verschachtelten Klassen und wiederum deren
Methoden, gültig. Eine Variable mit selbem Namen kann auch innerhalb einer Methode
deklariert und auf die Instanzvariable dem this-Schlüsselwort zugegriffen werden. In
geschachtelten Klassen muss zusätzlich der Klassenname vorangestellt, werden wie
Zeile 23 zeigt. Ist keine lokale Variable mit selbem Namen vorhanden, so kann dieses
Schlüsselwort auch weggelassen werden. Wie Zeile 15 zeigt, ist es nicht möglich, auf
lokale Variablen einer anderen Funktion zuzugreifen. Gleiches gilt für Instanzvariablen
verschachtelter Klassen.

Variablen in COBOL
Die Deklaration von Variablen unterscheidet sich in COBOL stark von der in Java.
Neben der Eigenschaft, dass Variablen nur innerhalb der DATA DIVISION – als Teil der
WORKING-STORAGE SECTION oder der LOCAL-STORAGE SECTION – deklariert werden
können, ist in COBOL die Definition eines Datentyps gleichzeitig auch die Festlegung
der Ausgabe-Repräsentation dieser Variable.
Dies sorgt nicht nur dafür, dass Speicherplatz nicht wie mit new in Java dynamisch
alloziert werden kann, sondern auch dafür, dass bereits an der Stelle der Variablendeklaration festgelegt werden muss, wie diese Daten im folgenden Programm dargestellt
werden. Das Schlüsselwort dafür ist die PICTURE- oder kurz PIC-Anweisung.

1
2
3
4
5
6

IDENTIFICATION DIVISION.
PROGRAM-ID. VARIABLE-EXAMPLE RECURSIVE.
DATA DIVISION.
WORKING-STORAGE SECTION.
01 PERSON-DATA.
05 PERSON-NAME PIC X(10) VALUE "Mustermann".

33

4 Vergleich wichtiger Sprachkonzepte

05 FILLER PIC X VALUE SPACE.
05 PERSON-HEIGHT-CM PIC 9(3) VALUE 178.
05 PERSON-HEIGHT-M REDEFINES PERSON-HEIGHT-CM PIC 9V99.
PROCEDURE DIVISION.
DISPLAY PERSON-DATA.
DISPLAY PERSON-NAME.
DISPLAY PERSON-HEIGHT-CM.
DISPLAY PERSON-HEIGHT-M.
END PROGRAM VARIABLE-EXAMPLE.

7
8
9
10
11
12
13
14
15

1

$ ./variableExample

2

Mustermann 178

3

Mustermann

4

178

5

1.78

Listing 4.6: Variablendeklarationen in COBOL

Listing 4.6 zeigt die Deklaration von vier Variablen. Dieses Beispiel illustriert verschiedene Konzepte der Variablendeklaration in COBOL.
Jede Variablendeklaration beginnt mit einer Stufennummer. Diese Stufennummer sorgt
für Gruppierung von Variablen. Zulässig sind dabei Zahlen zwischen 01 und 49. Die
Stufennummern sollten mit ausreichendem Abstand gewählt werden, um ein nachträgliches Einfügen zwischen zwei Stufennummern zu erleichtern. In der Praxis werden
dazu i. d. R. 5er-Schritte gewählt. Die speziellen Stufennummern 66, 77 und 88 werden
später separat behandelt. Wie das Beispiel demonstriert, ist der Zugriff auf einzelne
Variablen auch über den Gruppennamen möglich. Konstanten sind hierbei in COBOL
nicht möglich und so gilt es, wie Herr Bonev und Herr Lamperstorfer betonten, sicherzustellen, dass konstante Werte an keiner Stelle des Programms verändert werden. Ein
weiterer Nachteil davon ist, dass für diese pseudo-konstanten Werte im Gegensatz zu
Konstanten in Java Speicherplatz reserviert werden muss. In den Anfängen von COBOL
waren diese »Konstanten« daher verpönt und wurden nur sparsam verwendet.

34

4 Vergleich wichtiger Sprachkonzepte

IDENTIFICATION DIVISION.
PROGRAM-ID. DUPLICATE-NAMING.
DATA DIVISION.
WORKING-STORAGE SECTION.
01 FIRSTGROUP.
05 PNAME PIC X(20) VALUE "First value".
01 SECONDGROUP.
05 PNAME PIC X(20) VALUE "Second value".
PROCEDURE DIVISION.
MAIN-PROCEDURE.
DISPLAY "First: " PNAME IN FIRSTGROUP.
DISPLAY "Second: " PNAME IN SECONDGROUP.
END PROGRAM DUPLICATE-NAMING.

1
2
3
4
5
6
7
8
9
10
11
12
13

1

First: First value

2

Second: Second value

Listing 4.7: Mehrdeutige Variablennamen in COBOL

Diese Gruppierung ermöglicht es, Variablennamen mehrfach zu verwenden. Dabei
müssen Referenzen auf eine Variable, mithilfe des IN-Schlüsselworts immer auch die
einschließende Gruppe spezifizieren, um Mehrdeutigkeit zu vermeiden. Dies zeigt Listing 4.7.
Der Stufennummer folgt ein eindeutiger Name für die Variable. Hier kann jedoch auch das
Schlüsselwort FILLER verwendet werden. Dies sorgt dafür, dass eine Platzhaltervariable
angelegt wird, auf die jedoch später nicht direkt zugegriffen werden kann.
Die Festlegung der Repräsentation geschieht wie gezeigt durch ein PIC. Nach diesem
PIC wird festgelegt, wie diese Variable dargestellt werden soll. »X« steht dabei für ein
alphanumerisches, »9« für ein numerisches Zeichen und »A« für einen Buchstaben.
Die Angabe der Stellen einer Variable wird durch die Wiederholung des jeweiligen
Zeichens oder die verkürzte Notation mit der nachgestellten Anzahl der Wiederholungen
b X(4) – erreicht. Als Dezimaltrennzeichen wird
in runden Klammern – z. B. XXXX =
wie gezeigt ein »V« verwendet und ein vorangestelltes »S« sorgt dafür, dass eine

35

4 Vergleich wichtiger Sprachkonzepte
numerische Variable ein Vorzeichen führt. So wird genau festgelegt, wie viele Vor- und
Nachkommastellen eine Variable hat.
Die Initialisierung einer Variable erfolgt durch die VALUE-Anweisung, gefolgt von dem
Wert, welcher der Variablen zugewiesen werden soll. Dabei gibt es die Schlüsselwörter
SPACE bzw. SPACES und ZERO bzw. ZEROS, die anstelle eines Wertes verwendet werden
können, um eine Variable mit Leerzeichen bzw. Nullen zu initialisieren.
Durch die Definition der Repräsentation findet man in der Praxis oft Variablen, die auf
den selben Speicherbereich wie andere verweisen, jedoch die dort enthaltenen Daten
anders darstellen bzw. interpretieren. Dies geschieht, wie im Beispiel gezeigt, mithilfe
des Schlüsselworts REDEFINES.
Eine Typsicherheit ist in COBOL nicht ausreichend gewährleistet. So kann eine Variable
mit REDEFINES oder eine Variable, welche die eigentliche gruppiert, den Speicherbereich einer anderen mit unter Umständen ungültigen Werten befüllen. Auch sind
uninitialisierte Variablen teilweise mit falschen Datentypen vorbelegt.
Auch der Scope von Variablen in COBOL unterscheidet sich sehr stark von Java. Allgemein kann festgehalten werden, dass auf eine Variable von jeder Stelle innerhalb eines
Programms aus zugegriffen werden kann. Das sorgt dafür, dass schnell Fehler auftreten
können, die sich durch unbeabsichtigten Zugriff auf falsche Variablen ergeben. In der
Praxis sind diese, so alle befragten Experten übereinstimmend, häufiger beobachtbar
und bergen hohes und vor allem schwer auszumachendes Fehlerpotential. Außerdem
wird das Debuggen und die Fehleranalyse erschwert, da immer das gesamte Programm
betrachtet werden muss. WORKING-STORAGE SECTION und LOCAL-STORAGE SECTION
unterscheiden sich jedoch leicht. Während Variablenwerte in ersterer über mehrere Programmaufrufe hinweg erhalten bleiben, werden Variablen der LOCAL-STORAGE SECTION
bei jedem Aufruf neu instanziiert. Dieses Unterschiedes sind sich COBOL-Entwickler in
der Praxis nicht immer bewusst.
Speicherplatz von Variablen muss weder in COBOL noch in Java händisch freigegeben
werden. In Java sorgt der garbage collector dafür, dass Speicherbereich, der nicht
mehr verwendet wird, freigegeben wird. In COBOL geschieht dies mit dem Ende eines
Programms.

36

4 Vergleich wichtiger Sprachkonzepte

4.3 Arrays
Eine zentrale Datenstruktur in der Programmierung stellen Arrays bzw. Felder – in
COBOL auch als table bezeichnet – dar. Dabei handelt es sich um eine geordnete
Sammlung von Werten eines Typs, auf die, im Gegensatz zu z. B. verketteten Listen,
direkt zugegriffen werden kann.
Zeile 4 in Listing 4.8 beschreibt das Anlegen eines Arrays in Java mittels new-Schlüsselwort, wohingegen Zeile 8 den Zugriff auf ein Element zeigt. Die Indizierung der Elemente
beginnt dabei mit dem Element 0. Ein Feld der Größe 10 trägt beispielsweise die Indizes
0 – 9. Sowohl beim Anlegen als auch beim Zugreifen auf ein Element des Arrays wird
der []-Operator verwendet.

1

public class Arrays {

2

public static void main(String[] args) {
int[] intArray = new int[10];

3
4
5

for(int counter = 0; counter < intArray.length; counter++)
{
intArray[counter] = counter;
}

6
7
8
9

}

10
11

}

Listing 4.8: Felder in Java

In COBOL können Felder durch OCCURS, gefolgt von der Anzahl der zu speichernden Werte und TIMES angelegt werden. Dies illustriert Listing 4.9. Das INDEXED BYSchlüsselwort kann dazu genutzt werden, eine Variable zu definieren, mit der das Array
indiziert werden kann. In den Zeilen 10 und 11 ist der Zugriff auf ein einzelnes FeldElement zu sehen. Dies geschieht in COBOL mittels runder Klammern. Zu beachten ist
hierbei, dass COBOL die einzelnen Elemente beginnend mit 1 indiziert. Im Gegensatz
zu Java hat ein Array der Größe 10 in COBOL die Indizes 1 – 10. Dies ist jedoch nicht
zwangsläufig notwendig. In COBOL werden Indizes auch subscripts genannt.

37

4 Vergleich wichtiger Sprachkonzepte

1
2
3
4
5
6
7
8
9
10
11
12
13

IDENTIFICATION DIVISION.
PROGRAM-ID. ARRAYS.
DATA DIVISION.
WORKING-STORAGE SECTION.
01 ARRAY-ELEMENT PIC 9(2) OCCURS 10 TIMES
INDEXED BY ELEMENT-INDEX.
PROCEDURE DIVISION.
MAIN-PROCEDURE.
ACCEPT ELEMENT-INDEX.
ACCEPT ARRAY-ELEMENT(ELEMENT-INDEX).
DISPLAY ARRAY-ELEMENT(ELEMENT-INDEX).
STOP RUN.
END PROGRAM ARRAYS.

Listing 4.9: Felder in COBOL

Eine Besonderheit von Feldern in COBOL und in Java ist, dass diese auch mehrdimensional sein können. In COBOL spricht man statt von Dimensionen von Levels. Jedes
Element der ersten Dimension bzw. des ersten Levels besteht aus einem weiteren Feld.
Ein Zugriff auf ein beispielhaftes zweidimensionales Array ist dann mittels [][] in Java
bzw. (X,Y) in COBOL möglich. Dabei ist auch ein Zugriff auf eine ganze Dimension
möglich.
Eine weitere Gemeinsamkeit ist die Tatsache, dass Felder in beiden Sprachen eine feste
Größe haben. Nach dem Anlegen des Feldes kann diese Größe nicht mehr geändert
werden. Jedoch muss in COBOL bereits zur Zeit der Kompilierung festgelegt werden,
wie viele Elemente ein Array beinhalten soll. In Java kann diese Größe auch variabel
zur Laufzeit des Programms festgelegt werden.

4.4 Programmablauf und Kontrollfluss
Auch im Programmablauf ergeben sich Diskrepanzen zwischen COBOL und Java.
Allerdings führen diese Unterschiede nicht zu einem gänzlich anderen Ablauf, sondern
dazu, dass Gemeinsamkeiten nicht auf den ersten Blick erkennbar sind, obwohl der
Ablauf im Grunde sehr ähnlich ist. Sowohl Java- als auch COBOL-Programme werden
im Allgemeinen von oben nach unten durchlaufen. Beiden Programmiersprachen ist
gemein, dass sie einen definierten Einstiegspunkt in ein Programm haben. Während

38

4 Vergleich wichtiger Sprachkonzepte
jedes Java-Programm in der main-Methode startet, wird ein COBOL-Programm stets
sequenziell von oben nach unten abgearbeitet und durchlaufen und beginnt daher stets
mit der ersten Zeile der PROCEDURE DIVISION.

4.4.1 Genereller Ablauf
Listing 4.10 demonstriert einen sehr simplen Programmablauf in Java. Der Startpunkt
eines jeden Java-Programms ist die main-Methode. Von dieser aus können weitere
Methoden aufgerufen werden, und sobald das Ende dieser Methode erreicht ist, terminiert
das Programm. Im vorliegenden Beispiel wird nach einer Ausgabe in main die Methode
otherMethod aufgerufen, bevor der Ablauf wieder in der main-Methode fortgesetzt wird.
Daran soll folgendes Verhalten deutlich werden: Endet eine aufgerufene Methode wie
geplant, wird mit der nächsten Anweisung nach dem Methodenaufruf fortgefahren.

public class MainMethod{
public static void main(String[] args) {
System.out.println("Running main method!");
otherMethod();
System.out.println("Continue main method!");
}

1
2
3
4
5
6
7

public static void otherMethod() {
System.out.println("Running other method!");
}

8
9
10

}

11

1

$ java MainMethod

2

Running main method!

3

Running other method!

4

Continue main method!

Listing 4.10: Java main-Methode

In COBOL gestaltet sich der Programmablauf ähnlich. Das Programm wird stets von
oben nach unten durchlaufen, wobei dieser lineare Ablauf z. B. durch die Verwendung

39

4 Vergleich wichtiger Sprachkonzepte
von PERFORM-, CALL-, GO TO- oder NEXT SENTENCE-Anweisungen verändert werden
kann.
Ein Unterprogramm wird mit CALL aufgerufen und gibt mit GOBACK die Kontrolle
zurück an das aufrufende Programm. Die Ausführung eines COBOL-Programms endet
beim Erreichen einer STOP RUN-Anweisung oder mit dem Ende des Programms (END
PROGRAM).
Die beiden Ausführungen von Listing 4.11 zeigen das angesprochene Verhalten eines
COBOL-Programms. Beim ersten Durchlauf wird für die Variable INPUT-NUMBER der
Wert 0 eingegeben, was durch das Ausführen der STOP RUN-Anweisung das Beenden
des Programmes bewirkt. Beim zweiten Mal wird hingegen der Wert 1 eingegeben.
Dieser Wert verhindert das Abschließen des Programms mittels STOP RUN, wodurch der
Programmablauf in Zeile 16 fortgesetzt wird und somit erneut die Eingabeaufforderung
erscheint.

1
2
3
4
5
6

IDENTIFICATION DIVISION.
PROGRAM-ID. SIMPLE-CONTROL-FLOW.
DATA DIVISION.
WORKING-STORAGE SECTION.
01 INPUT-NUMBER PIC 9.
88 IS-ZERO VALUE 0.

7
8
9
10
11
12
13
14
15

PROCEDURE DIVISION.
MAIN-PARAGRAPH.
DISPLAY "Main paragraph".
PERFORM SECOND-PARAGRAPH.
DISPLAY "Main paragraph again".
IF IS-ZERO THEN
STOP RUN
END-IF.

16
17
18
19
20

SECOND-PARAGRAPH.
DISPLAY "Enter some number: " WITH NO ADVANCING.
ACCEPT INPUT-NUMBER.
END PROGRAM SIMPLE-CONTROL-FLOW.

40

4 Vergleich wichtiger Sprachkonzepte

1

$ ./simpleControlFlow

2

Main paragraph

3

Enter some number: 0

4

Main paragraph again

5

$ ./simpleControlFlow

6

Main paragraph

7

Enter some number: 1

8

Main paragraph again

9

Enter some number: 2

Listing 4.11: Programmablauf in COBOL

Wie in Abschnitt 4.1 beschrieben, besteht ein COBOL-Programm aus verschiedenen
strukturellen Komponenten. Listing 4.12 soll den Einfluss davon auf den Programmablauf veranschaulichen.

41

4 Vergleich wichtiger Sprachkonzepte

IDENTIFICATION DIVISION.
PROGRAM-ID. PARAGRAPH-SECTION-CONTROL-FLOW.

1
2
3

PROCEDURE DIVISION.
MAIN-PROCEDURE.
DISPLAY "Calling section:".
PERFORM TEST-SECTION.
DISPLAY SPACE.
DISPLAY "Calling paragraphs with PERFORM THRU:".
PERFORM FIRST-TEST-PARAGRAPH THRU THIRD-TEST-PARAGRAPH.
DISPLAY SPACE.
DISPLAY "Calling paragraph:".
PERFORM FIRST-TEST-PARAGRAPH.
STOP RUN.

4
5
6
7
8
9
10
11
12
13
14
15

TEST-SECTION SECTION.
FIRST-TEST-PARAGRAPH.
DISPLAY "1" WITH NO ADVANCING.

16
17
18
19

SECOND-TEST-PARAGRAPH.
DISPLAY "2" WITH NO ADVANCING.

20
21
22

THIRD-TEST-PARAGRAPH.
DISPLAY "3" WITH NO ADVANCING.

23
24
25
26

END PROGRAM PARAGRAPH-SECTION-CONTROL-FLOW.

27

1

$ ./paragraphSecionControlFlow

2

Calling section:

3

123

4

Calling paragraphs with PERFORM THRU:

5

123

6

Calling paragraph:

7

1

Listing 4.12: Programmablaufunterschiede in COBOL mit Sections und Paragraphs

42

4 Vergleich wichtiger Sprachkonzepte
Wird mittels PERFORM eine Section aufgerufen, so werden alle Paragraphs innerhalb
dieser Section der Reihe nach ausgeführt. Ruft man jedoch einen Paragraph auf, so
wird nur dieser Paragraph ausgeführt. Eine weitere Möglichkeit ist die Kombination des
PERFORM mit dem THRU-Schlüsselwort. Hierbei werden alle Paragraphs zwischen zwei
festgelegten Paragraphs ausgeführt. Der Kontrollfluss geht bei jeder Variante stets an
das Statement nach dem PERFORM.
Um Verwirrungen vorzubeugen und lesbaren Code zu erhalten, sollten alle Paragraphs
stets Teil einer Section und auch nur diese Ziel einer PERFORM-Anweisung sein. Der
letzte Paragraph einer Section sollte dabei immer ein EXIT-Paragraph sein, der nur das
Schlüsselwort EXIT beinhaltet. So ist das Ende einer Section beim Lesen des Codes klar
erkennbar. Dieses Vorgehen wurde auch von Richards bereits 1984 als Best-Practice
beschrieben [20]. Die meisten Code-Beispiele dieser Arbeit enthalten bewusst keinen
separaten EXIT-Paragraph, um den Umfang und die Übersichtlichkeit der Listings so
gering wie möglich zu halten.

4.4.2 Funktionen, Unterprogramme und Rückgabewerte
Wichtiger Bestandteil von Programmiersprachen sind Prozeduren und Funktionen.
Dabei handelt es sich um Codeabschnitte, die von einer anderen Stelle aus aufgerufen
werden können. Im Gegensatz zu Prozeduren, die bestimmte Verarbeitungsschritte
durchlaufen, liefern Funktionen dabei noch zusätzlich einen Rückgabewert.

Java

In Java muss jede Anweisung Teil einer Funktion sein. Wie zuvor beschrieben startet
ein Java-Programm mit der main-Methode. Die Unterscheidung zwischen Methoden
und Prozeduren wird in Java gängigerweise nicht getroffen. Oft findet sich auch die
Bezeichnung Funktion. Java unterscheidet sich hier von manchen anderen modernen
Sprachen, da es keine Methodenschachtelungen erlaubt.
Listing 4.13 zeigt verschiedene Methoden. An diesem Beispiel sollen zwei wichtige
Konzepte dargestellt werden:
• Übergabe von Parametern – Wie gezeigt, erhalten die Funktionen unterschiedliche Parameter. Die Methode process() zum Beipiel erhält keinen Para-

43

4 Vergleich wichtiger Sprachkonzepte
meter. getGreeting(String, String) erwartet hingegen zwei Parameter vom
Typ String.
• Rückgabe eines Wertes – Eine Funktion muss stets den Typ ihres Rückgabewertes definieren. Soll kein Rückgabewert geliefert werden, ist der Typ als void
zu definieren. Im Gegensatz zu anderen Sprachen kann eine Methode in Java
lediglich einen Wert zurückliefern.

1
2
3
4

public class MethodExample {
public void printGreeting(String greeting) {
System.out.println(greeting);
}

5

public String getGreeting(String firstName, String surname) {
return String.format("Hello %s %s!", firstName, surname);
}

6
7
8
9

public void process() {
String greeting = getGreeting("Max", "Mustermann");
printGreeting(greeting);
}

10
11
12
13
14

}

Listing 4.13: Methoden in Java

Der Aufruf einer Funktion erfolgt mittels Methodenname und den zu übergebenen
Parametern in runden Klammern. Außerdem zeigt sich, dass Funktionen mithilfe
des return-Statements einen Rückgabewert an die aufrufende Funktion zurückgeben
können. Ein return kann auch dazu benutzt werden, um Funktionen an anderen Stellen
als der letzten Zeile zu verlassen. Eine Funktion ohne Rückgabewert – void – terminiert
implizit in der letzten Zeile und benötigt kein explizites return, kann dieses jedoch
auch ohne Rückgabewert nutzen, um vorher den Funktionsablauf zu beenden. Eine
Methode mit Rückgabewert muss stets einen Wert mit passendem Datentyp durch
return zurückgeben.
Eine elegante Möglichkeit, die sich mit Funktionen in Java bietet, ist die Rekursion.
Dabei handelt es sich um eine Funktion, die sich selbst aufruft. In Java begegnet
man rekursiven Implementierungen selten, obwohl diese, im Gegensatz zu iterativen
Ansätzen, oft eleganter und durch weniger Code formuliert werden könnten. Auf der
anderen Seite ist die iterative Implementierung jedoch sicherer, da rekursive Varianten

44

4 Vergleich wichtiger Sprachkonzepte
unter Umständen an die nicht fest definierte Grenze der maximalen Rekursionstiefe
gelangt. Die Funktionen facultyRecursive und facultyIterative in Listing 4.14
berechnen die Fakultät einer übergebenen Zahl rekursiv bzw. iterativ.

1

public class RecursionExample {

2

public static int facultyRecursive(int number) {
if (number <= 1)
return 1;
return number * facultyRecursive(number - 1);
}

3
4
5
6
7
8

public static int facultyIterative(int number) {
int product = 1;
while (number > 1) {
product = product * number;
number--;
}
return product;
}

9
10
11
12
13
14
15
16
17

}

Listing 4.14: Rekursion in Java

COBOL

Das Konzept einer Funktion existiert in COBOL nicht. Lediglich das Aufrufen einer
Section oder eines Paragraphs mithilfe eines PERFORM geben ansatzweise ähnliche
Möglichkeiten und können daher als Vergleich herangezogen werden. Jedoch können
dabei weder Parameter übergeben noch ein Wert zurückgeliefert werden. Darum ist es
nötig, Werte, die innerhalb einer Section verwendet oder zurückgeliefert werden sollen,
in Variablen zu kopieren. Wie in Abschnitt 4.2 beschrieben, sind diese Variablen jedoch
immer global innerhalb eines Programms definiert.
Oft bringt das allerdings Probleme mit sich. Zum Beispiel werden in der Praxis oft
Variablen, die für etwas anderes gedacht sind, an einer anderen Stelle wiederverwendet.
So ist nicht ganz klar, welchen Zweck Variablen erfüllen. Ein weiterer großer Nachteil
ist, dass Logik oftmals kopiert und sehr ähnlich nochmals geschrieben werden muss, um
auf anderen Daten zu operieren.

45

4 Vergleich wichtiger Sprachkonzepte

1
2

IDENTIFICATION DIVISION.
PROGRAM-ID. FACULTY RECURSIVE.

3
4
5
6
7
8
9

DATA DIVISION.
WORKING-STORAGE SECTION.
01 WS-NUMBER PIC 9(4) VALUE 5.
01 WS-PRODUCT PIC 9(4) VALUE 0.
LOCAL-STORAGE SECTION.
01 LS-NUMBER PIC 9(4).

10
11
12
13
14
15
16
17
18
19
20
21
22
23

PROCEDURE DIVISION.
IF WS-NUMBER = 0
MOVE 1 TO WS-PRODUCT
ELSE
MOVE WS-NUMBER TO LS-NUMBER
COMPUTE WS-NUMBER = WS-NUMBER - 1
CALL "FACULTY"
COMPUTE WS-PRODUCT = LS-NUMBER * WS-PRODUCT
END-IF.
IF LS-NUMBER = 5
DISPLAY WS-PRODUCT
END-IF.
GOBACK.

24
25

END PROGRAM FACULTY.

Listing 4.15: Rekursion in COBOL

Rekursive PERFORM-Aufrufe sind zwar syntaktisch möglich, jedoch führt die Ausführung
zu einem undefinierten Verhalten des Programms und ist deshalb in jedem Fall zu unterlassen. Es kann quasi festgehalten werden, dass Rekursionen innerhalb eines Programms
in COBOL nicht möglich sind. Anders sieht es dabei mit gesamten Programmen aus.
Listing 4.15 enthält analog zu gezeigtem Java-Beispiel auch ein Programm, welches
rekursiv die Fakultät einer Zahl errechnet und ausgibt. Wichtig ist hierbei vorallem die
RECURSIVE Definition hinter dem Programmnamen in Zeile 2. Die WORKING-STORAGE
SECTION enthält dabei Variablen, welche von jeder Instanz des rekursiv aufgerufenen Programms gemeinsam genutzt werden. In LOCAL-STORAGE SECTION finden sich
Variablen, deren Gültigkeitsbereich sich auf die aktuelle Aufrufinstanz beschränken.

46

4 Vergleich wichtiger Sprachkonzepte
In COBOL ist es möglich, eigenständige Unterprogramme aufzurufen. Wie bereits
in Abschnitt 4.1 erläutert, dient die LINKAGE SECTION dazu, im Unterprogramm zu
definieren, welche Variablen übergeben werden. Mithilfe der CALL-Anweisung, des
Programmnamens und der Angabe von Variablennamen kann dieses Unterprogramm
aufgerufen und die Werte übergeben werden. Wie in Abschnitt 3.3 kann die Angabe
des Programmnamens auch pseudo-variabel geschehen, um ein statisches Linken der
Programmteile zu vermeiden.

1
2
3
4
5
6
7
8
9
10
11
12
13
14

1
2
3
4
5
6
7
8
9
10
11
12
13

IDENTIFICATION DIVISION.
PROGRAM-ID. CALLING_PROGRAM.
DATA DIVISION.
WORKING-STORAGE SECTION.
01 SUB-PROGRAM-PARAMS.
05 INPUT-NUMBER PIC 9(4).
05 RET-VALUE PIC 9(4).
PROCEDURE DIVISION.
MAIN-PROCEDURE.
ACCEPT INPUT-NUMBER.
CALL "CALLED_PROGRAM" USING SUB-PROGRAM-PARAMS.
DISPLAY "CALLING PROGRAM: " RET-VALUE.
STOP RUN.
END PROGRAM CALLING_PROGRAM.

IDENTIFICATION DIVISION.
PROGRAM-ID. CALLED_PROGRAM.
DATA DIVISION.
LINKAGE SECTION.
01 SUB-PROGRAM-PARAMS.
05 INPUT-NUMBER PIC 9(4).
05 RET-VALUE PIC 9(4).
PROCEDURE DIVISION USING SUB-PROGRAM-PARAMS.
MAIN-PROCEDURE.
DISPLAY "SUB-PROGRAM got passed: " INPUT-NUMBER.
COMPUTE RET-VALUE = INPUT-NUMBER * 2.
GOBACK.
END PROGRAM CALLED_PROGRAM.

47

4 Vergleich wichtiger Sprachkonzepte

1

$ ./CALLING_PROGRAM

2

22

3

SUB-PROGRAM got passed: 0022

4

CALLING PROGRAM: 0044

Listing 4.16: Unterprogramme in COBOL

Listing 4.16 zeigt den Aufruf eines Unterprogramms und die Übergabe von Parametern.
Diese Parameter werden per Referenz übergeben. Das heißt, dass Unterprogramme
stets auf den gleichen Speicherbereich zugreifen wie das ursprüngliche Programm und
so auch dessen Daten verändern. Dies gilt es zu beachten, da dadurch ungewünschte
Seiteneffekte oder gar Fehler auftreten können. Das Definieren eines Rückgabewertes
in einem Unterprogramm ist nicht möglich. Soll ein Rückgabewert im aufgerufenen
Programm gesetzt werden, so ist dieser innerhalb der übergebenen Datenstruktur zu
setzen, auf die auch das aufrufende Programm Zugriff hat.
In Java sind diese Aufrufe von Unterprogrammen weitestgehend mit klassenübergreifenden Methodenaufrufen zu vergleichen. Der große Unterschied hierbei ist, dass ein
COBOL-Unterprogramm bei jedem Aufruf am gleichen Punkt – der ersten Zeile der
PROCEDURE DIVISION – startet, wohingegen in Java beliebige Methoden aufgerufen
werden können, solange diese sichtbar sind. Herr Streit merkte an, dass dies in der Praxis
dazu führe, dass oftmals ein »Funktionscode« als Teil der Übergabedaten definiert
würde, anhand dessen im Unterprogramm die eigentliche Funktionalität ausgewählt
und ausgeführt wird. Beispielsweise werde ein »’I’ für Insert« oder ein »’D’ für Delete«
übergeben.

4.4.3 Verzweigungen
Bedingte Verzweigungen, sprich die Ausführung von Programmteilen nur unter bestimmten Voraussetzungen, stellen eine weitere wichtige Eigenschaft dar. Sowohl Java als
auch COBOL bieten hierfür die Schlüsselwörter if-else (Java) bzw. IF-ELSE-END-IF
(COBOL). Auch die Verwendung ist sehr ähnlich, wie folgende Beispiele zeigen.

48

4 Vergleich wichtiger Sprachkonzepte

1

import java.util.Scanner;

2
3
4
5
6
7
8
9
10

public class IfExample {
public static void main(String... args) {
int number = new Scanner(System.in).nextInt();
if (number == 0) {
System.out.println("Number is 0");
System.out.println("Number is still 0");
} else
System.out.println("Number is not 0");

11

System.out.println(number == 0 ? "0" : "Not 0");

12

}

13
14

}

Listing 4.17: Verzweigung in Java

In Listing 4.17 wird anhand einer Nutzereingabe eine Fallunterscheidung bzw. Verzweigung gemacht. Dabei soll gezeigt werden, dass es möglich ist sowohl mehrere Zeilen als
auch nur eine Zeile konditionell auszuführen. Soll mehr als eine Zeile untergeordnet
werden, ist eine Gruppierung als Block – mit geschweiften Klammern – nötig. Der elseZweig zeigt eine einzelne Anweisung als bedingt auszuführendes Statement. Das letzte
Statement zeigt die Verwendung des konditionalen Operators »?«. Dabei handelt es
sich – im Gegensatz zu Statements in if-else-Konstrukten – um bedingte Expressions,
also reine Ausdrücke statt Anweisungen, die abhängig von Wahrheitswerten eingesetzt
werden.
Listing 4.18 bildet die selbe Logik in COBOL ab. Die beiden Sections END-IF-EXAMPLE
und PERIOD-IF-EXAMPLE zeigen dabei zwei unterschiedliche Wege diese zu konstruieren.
Während erstere eine ELSE- und eine END-IF Anweisung nutzt, um das Konstrukt
aufzubauen und zu terminieren, verwendet letztere die Eigenschaft, dass ein IF auch
durch ein Sentence-Ende – siehe Abschnitt 4.1 – abgeschlossen werden kann. Dies erlaubt
jedoch keine verschachtelten Verzweigungen und kann – wie die befragten Experten
anmerkten – in der Praxis schnell zu Fehlern oder zumindest zu schwer durchschaubarem
Verhalten führen. Herr Streit betonte, dass bestehende Programme teilweise solche
Konstrukte beinhalten, ein IF jedoch stets mit einem END-IF terminiert werden sollte.
Dies sorgt dafür, dass es dem Compiler möglich ist, Fehler in der Verzweigung zu
erkennen und eine bessere Lesbarkeit zu erreichen.

49

4 Vergleich wichtiger Sprachkonzepte

1
2
3
4
5

IDENTIFICATION DIVISION.
PROGRAM-ID. IF-EXAMPLE.
DATA DIVISION.
WORKING-STORAGE SECTION.
01 VAR PIC 9.

6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25

PROCEDURE DIVISION.
MAIN-PROCEDURE SECTION.
ACCEPT VAR.
PERFORM END-IF-EXAMPLE.
ACCEPT VAR.
PERFORM PERIOD-IF-EXAMPLE.
STOP RUN.
END-IF-EXAMPLE SECTION.
IF VAR = 0
DISPLAY "VAR = 0"
ELSE
DISPLAY "VAR != 0"
END-IF.
PERIOD-IF-EXAMPLE SECTION.
IF VAR = 0
DISPLAY "VAR = 0"
ELSE
DISPLAY "VAR != 0".
END PROGRAM IF-EXAMPLE.

Listing 4.18: Verzweigung in COBOL

Sowohl in Java als auch in COBOL ist es möglich, arithmetische Ausdrücke in Bedingungen zu verwenden. Während dies in Java üblich ist, wies Herr Streit darauf hin, dass
dies in COBOL eher selten verwendet wird, da dabei oftmals nicht ausreichend klar ist,
wie viele Nachkommastellen die Ergebnisse dieser Berechnungen tragen.

4.4.4 Schleifen
Wie in vielen anderen Sprachen unterstützen Java und COBOL auch Schleifenkonstrukte. Während Java dafür dedizierte Schlüsselwörter bereitstellt, fungiert in COBOL
auch dafür das PERFORM-Statement. Dies kann für Unklarheiten sorgen, weil dieses
Schlüsselwort, wie in Unterabschnitt 4.4.1 beschrieben, auch dafür verwendet wird,
Sections und Paragraphs aufzurufen.

50

4 Vergleich wichtiger Sprachkonzepte

1
2
3
4
5
6

public class Loops {
public static void main(String... args) {
int number = 0;
while (number < 10) {
number++;
}

7

number = 0;
do {
number++;
} while (number < 10);

8
9
10
11
12

for (number = 0; number < 10; number++) {
System.out.println(number);
}

13
14
15
16

for (int num : new int[] { 0, 1, 2, 3, 4, 5 }) {
System.out.println(num);
}

17
18
19

}

20
21

}

Listing 4.19: Schleifen in Java

Java bietet mit while-, do-while- und for-Schleifen drei unterschiedliche Arten von
Schleifen. Listing 4.19 enthält alle drei Konstrukte. Während die ersten beiden eine
Bedingung kopf- bzw. fußgesteuert überprüfen, wird eine for-Schleife i. d. R. dazu
genutzt, um Werte einer bestimmten (Zahlen-)Menge zu durchlaufen.
COBOL nutzt für alle Schleifen das PERFORM-Schlüsselwort. In Verbindung mit weiteren
Statements entstehen so unterschiedliche Schleifentypen. Listing 4.20 beschreibt die
wichtigsten davon. Eine bedingte Schleifenausführung lässt sich mithilfe des UNTILSchlüsselworts und einer nachfolgenden Bedingung erreichen. Eine Zählschleife, entsprechend eines for in Java, kann durch VARYING, FROM und BY konstruiert werden. Jede
Schleife kann zusätzlich durch die Angabe von WITH TEST AFTER von einer kopfgesteuerten zu einer fußgesteuerten Schleife gemacht werden, d. h. die Bedingung wird nach
einem Schleifendurchlauf geprüft und nicht davor.

51

4 Vergleich wichtiger Sprachkonzepte

1
2
3
4
5

IDENTIFICATION DIVISION.
PROGRAM-ID. LOOP-EXAMPLE.
DATA DIVISION.
WORKING-STORAGE SECTION.
01 NUM PIC 9(2).

6
7
8
9
10
11
12

PROCEDURE DIVISION.
MAIN-PROCEDURE SECTION.
PERFORM PERFORM-UNTIL.
PERFORM PERFORM-VARYING.
PERFORM PERFORM-VARYING-TEST-AFTER.
STOP RUN.

13
14
15
16
17
18
19

PERFORM-UNTIL SECTION.
MOVE 0 TO NUM.
PERFORM UNTIL NUM = 10
COMPUTE NUM = NUM + 1
END-PERFORM.
DISPLAY NUM.

20
21
22
23
24
25

PERFORM-VARYING SECTION.
MOVE 0 TO NUM.
PERFORM VARYING NUM FROM 0 BY 1 UNTIL NUM = 10
DISPLAY NUM
END-PERFORM.

26
27
28
29
30
31

PERFORM-VARYING-TEST-AFTER SECTION.
MOVE 0 TO NUM.
PERFORM WITH TEST AFTER VARYING NUM FROM 0 BY 1 UNTIL NUM = 10
DISPLAY NUM
END-PERFORM.

32
33

END PROGRAM LOOP-EXAMPLE.

Listing 4.20: Schleifen in COBOL

4.4.5 Weitere Schlüsselwörter
Weitere Schlüsselwörter, die den Kontrollfluss – vor allem im Zusammenhang mit
Verzeigungen und Schleifen – in Java steuern können, sind außerdem break, continue
und goto. Zu beachten ist dabei, dass das goto-Schlüsselwort zwar im Sprachstandard

52

4 Vergleich wichtiger Sprachkonzepte
definiert, jedoch in keiner gängigen JVM implementiert ist. Die Verwendung führt zu
Fehlern beim Kompilieren. In Listing 4.21 finden sich beispielhafte Verwendungen der
beiden anderen Schlüsselwörter.

public class BreakContinueExample {

1
2

public static void main(String[] args) {
breakExample();
continueExample();
}

3
4
5
6
7

private static void breakExample() {
System.out.println("\n== break example == ");
for (int counter = 0; counter < 10; counter++) {
if (counter > 1 && counter < 8)
break;
System.out.print("(" + counter + ")");
}
}

8
9
10
11
12
13
14
15
16

private static void continueExample() {
System.out.println("\n== continue example == ");
for (int counter = 0; counter < 10; counter++) {
if (counter > 2 && counter < 8)
continue;
System.out.print("(" + counter + ")");
}
}

17
18
19
20
21
22
23
24

}

25

1

$ java BreakContinueExample

2

== break example ==

3

(0)(1)

4

== continue example ==

5

(0)(1)(2)(8)(9)

Listing 4.21: Beispiele für die Verwendung von break und continue in Java

Ein break sorgt wie gezeigt dafür, dass die direkt umfassende Schleife verlassen wird.
Auch ein continue hat Auswirkungen auf die direkt beinhaltende Schleife. So sorgt

53

4 Vergleich wichtiger Sprachkonzepte
es dafür, dass der aktuelle Schleifendurchlauf abgebrochen und mit dem nächsten
fortgefahren wird. Unterabschnitt 4.8.2 zeigt eine weitere Verwendung des breakStatements. Deutlich unüblicher – jedoch nicht weniger relevant – ist der Gebrauch
eines Labels in Java. Dieses Label kann in Verbindung mit break- oder continueAnweisungen genutzt werden, um mehrere umfassende Schleifen zu verlassen bzw. um
mit dem nächsten Schleifendurchlauf einer weiter außen befindlichen fortzufahren. Die
Anweisung betrifft dabei die Schleife, welche das Label trägt.
In COBOL ist ebenfalls das Schlüsselwort CONTINUE vorhanden. Allerdings ist hierbei Vorsicht geboten, da dieses abweichende Bedeutung vom gleichnamigen JavaSchlüsselwort hat. Während in Java zum nächsten Schleifendurchlauf gesprungen werden
kann, entspricht dieses Schlüsselwort in COBOL lediglich einer Anweisung, bei der nichts
ausgeführt wird. Dies ist in der Praxis häufig zu beobachten, um z. B. Verzweigungsteile
leer zu lassen, ohne die Bedingung negieren zu müssen, da der Compiler keine leeren
Teile akzeptiert.
Neben diesem ist NEXT SENTENCE ein Schlüsselwort, das häufig in älterem Code zu
finden sei, wie Herr Lamperstorfer bestätigte. Dieses kann dazu genutzt werden, um den
aktuellen Sentence zu verlassen und mit der darauf folgenden Anweisung fortzufahren.
Ein grundlegendes Problem, das sich mit Verwendung dieser Anweisung jedoch ergibt,
ist, dass das in Abschnitt 4.1 angesprochene Punkt-Symbol mit Semantik belegt wird. So
kann ein zusätzliches Sentence-Ende Zeichen den Programmfluss ändern. Zu beobachten
ist die Verwendung von NEXT SENTENCE auch häufig zur Negation einer Bedingung,
indem der IF-Zweig lediglich dieses Statement enthält und der ELSE-Zweig die Logik bei
Nichtzutreffen der Bedingung enthält. Diese Konstrukte sollten daher vermieden werden
und durch Negation mit NOT ausgedrückt bzw. anders ersetzt werden. Aus genannten
Gründen ist dieses Schlüsselwort in GnuCOBOL standardmäßig verboten.
Seltener zu finden ist dagegen die EXIT PERFORM-Anweisung. Diese kann innerhalb von
Schleifen dazu genutzt werden, um, wie mit einem break in Java, die umgebende Schleife
zu verlassen oder durch EXIT PERFORM CYCLE, wie mit einem continue in Java, mit
dem nächsten Schleifendurchlauf fortzufahren. Dies soll Listing 4.22 verdeutlichen.

1
2
3
4
5

IDENTIFICATION DIVISION.
PROGRAM-ID. EXIT-PERFORM.
DATA DIVISION.
WORKING-STORAGE SECTION.
01 NUM PIC 9(2).

54

4 Vergleich wichtiger Sprachkonzepte

PROCEDURE DIVISION.
MAIN-PROCEDURE SECTION.
PERFORM EXIT-PERFORM.
PERFORM EXIT-PERFORM-CYCLE.
STOP RUN.
EXIT-PERFORM SECTION.
MOVE 0 TO NUM.
PERFORM VARYING NUM FROM 0 BY 1 UNTIL NUM = 10
EXIT PERFORM
DISPLAY "This is omitted!"
END-PERFORM.
DISPLAY NUM.
EXIT-PERFORM-CYCLE SECTION.
MOVE 0 TO NUM.
PERFORM VARYING NUM FROM 0 BY 1 UNTIL NUM = 10
EXIT PERFORM CYCLE
DISPLAY "This is omitted!"
END-PERFORM.
DISPLAY NUM.
END PROGRAM EXIT-PERFORM.

6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25

1

00

2

10

Listing 4.22: EXIT PERFORM in COBOL

Die Verwendung des GO TO-Befehls sollte in COBOL unterlassen werden und ist oftmals
sogar durch projekt- oder unternehmensspezifische Vorgaben verboten ist, da ansonsten
sehr schwer verständlicher und wartbarer Code entstehen kann. Eine Ausnahme dieses
Verbotes stellt dabei das GO TO mit einem EXIT-Paragraphen (siehe Unterabschnitt 4.4.1)
als Ziel dar. Dies ist nötig, da COBOL keinen Befehl wie das return in Java enthält,
um die Ausführungskontrolle an die aufrufende Stelle zurückzugeben. Leider findet man
in der Praxis oftmals Code, der GO TO-Befehle zur Steuerung des Ablaufs verwendet.
Sogar Schleifenkonstrukte sind in älteren Programmen oft damit realisiert, worauf Herr
Streit hinwies.

55

4 Vergleich wichtiger Sprachkonzepte

4.4.6 Ausnahmebehandlung
In modernen Sprachen sind Ausnahmebehandlungsmechanismen vorhanden, um die
Steuerung des Kontrollflusses klar von der Fehlerbehandlung zu trennen. So wird zum
einen eine übersichtlichere Implementierung erlaubt, aber auch erreicht, dass bereits
der Compiler auf Fehler hinweisen kann, die bei der Ausführung auftreten können bzw.
gänzlich das Kompilieren bei ungenügender Fehlerbehandlung verweigert.
Java bietet dabei das Konzept der Exceptions. Diese lassen sich in sogenannte checked
und unchecked-Exceptions unterteilen. Während checked-Exception stets einer ausreichenden Fehlerbehandlung oder Deklaration im Code bedürfen und ansonsten zu Fehlern
des Kompiliervorgangs führen, können unchecked-Exceptions unbehandelt gelassen
werden. Zur genauen Verwendungserklärung kann weiterführende Literatur wie Java
for COBOL programmers [4] von Byrne und Cross herangezogen werden.

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19

IDENTIFICATION DIVISION.
PROGRAM-ID. IF-EXAMPLE.
DATA DIVISION.
WORKING-STORAGE SECTION.
01 NUM PIC 9(2).
01 TARGET-STRING PIC X(5).
PROCEDURE DIVISION.
MAIN-PROCEDURE SECTION.
ACCEPT NUM.
COMPUTE NUM = NUM * 2
ON SIZE ERROR DISPLAY "The value could not be doubled."
STOP RUN
END-COMPUTE.
DISPLAY "Doubled number: " NUM.
STRING 'This is a little too long' DELIMITED BY SIZE
INTO TARGET-STRING
ON OVERFLOW DISPLAY "The string is too long!".
STOP RUN.
END PROGRAM IF-EXAMPLE.

Listing 4.23: Rudimentäre Fehlerbehandlung in COBOL

COBOL bietet zur generellen Ausnahmebehandlung keine Methodik. Fehlerfälle müssen
über Variablenwerte signalisiert, geprüft und entsprechend behandelt werden. Herr Streit
wies darauf hin, dass eine ungenügende Prüfung hierbei zum kompletten Absturz des

56

4 Vergleich wichtiger Sprachkonzepte
Programms führen kann. Jedoch ist es möglich, vordefinierte Fehler bei Berechnungen
oder String-Zuweisungen abzufangen und darauf zu reagieren, wie Listing 4.23 zeigt.
Dazu können ON SIZE ERROR und ON OVERFLOW genutzt werden.

4.4.7 Nebenläufigkeit
In Java ist es möglich und durchaus üblich, Programme nebenläufig zu entwickeln
und ablaufen zu lassen. Das heißt, mehrere Threads arbeiten parallel und führen
Verarbeitungen – je nach Hardware nur scheinbar – gleichzeitig aus. Dabei muss der
Entwickler auf die Synchronisation von gemeinsam genutzten Speicherbereichen achten,
um gültige Daten zu gewährleisten. Diese nebenläufige Programmierung birgt zwar
ein gewisses Fehlerpotential bei der Implementierung, sorgt jedoch dafür, dass Logik
tendenziell effizienter ausgeführt wird.
In COBOL ist diese nebenläufige Ausführung nicht möglich. Ein COBOL-Programm
führt Verarbeitungsschritte stets sequenziell aus und erlaubt keine parallelen Ausführungen. Durch einen Transaktionsmonitor ist es jedoch möglich, dass verschiedene
Programme gleichzeitig ausgeführt werden, die jedoch keine Kenntnis von anderen
ausgeführten Programmen haben. Bei einem Transaktionsmonitor handelt es sich um
eine Art Middleware, vergleichbar zu Application-Servern in Java, welche Anfragen
entgegennimmt, dafür sorgt, dass Ressourcen geöffnet und aufgeräumt werden, auf
Host-Systemen Terminal-Masken zur Verfügung stellt und entscheidet, wie viele und
welche Programme parallel ausgeführt werden. Ein Beispiel hierfür ist das Customer
Information Control System, kurz CICS. Um aus einem COBOL-Programm Teile des
Transaktionsmonitors aufzurufen, gibt es Befehle wie EXEC CICS.

4.5 Dateien
Wie in Abschnitt 3.6 beschrieben wurde, stellen oftmals auch Dateien eine wichtige
Datenressource dar. Der Umgang – das Lesen und Schreiben – mit Dateien in Java und
COBOL wird nachfolgend erläutert und gegenübergestellt.

57

4 Vergleich wichtiger Sprachkonzepte

Dateien in Java
Java bietet bereits mit Bibliotheksfunktionen des JDK umfangreiche Möglichkeiten,
Dateien zu lesen und zu schreiben. Dies geschieht dabei in der Regel zeilenweise, wobei
auch byte- bzw. zeichenweises Lesen möglich ist. Das Beispiel Listing 4.24 zeigt dabei
zusätzlich die Verwendung der Klasse InputStream. Diese sorgt dafür, dass die Datei
nicht auf einmal in den Speicher geladen wird, sondern nur die gelesenen Daten im
Speicher gehalten werden. Dies ist essenziell, um große Dateien zu lesen, da der Speicher
des Systems ohne eine solche Methodik möglicherweise nicht ausreichend wäre, um die
gesamte Datei zu speichern und so eine Exception auftreten würde.

1
2
3
4
5
6
7
8
9
10

import
import
import
import
import
import
import
import
import
import

java.io.BufferedReader;
java.io.BufferedWriter;
java.io.IOException;
java.io.InputStream;
java.io.InputStreamReader;
java.nio.charset.Charset;
java.nio.charset.StandardCharsets;
java.nio.file.FileSystems;
java.nio.file.Files;
java.nio.file.Path;

11
12

public class FileInputOutput {

13
14

private final static Path filePath =
,→
FileSystems.getDefault().getPath("file.txt");

15
16
17
18
19

public static void main(String... args) {
writeFile();
readFile();
}

20
21
22

private static void writeFile() {
String s = "I'm getting written to the File\n";

23

try (BufferedWriter writer =
Files.newBufferedWriter(filePath, StandardCharsets.UTF_8)) {
writer.write(s, 0, s.length());
} catch (IOException x) {
System.err.format("IOException: %s%n", x);
}

24
25
26
27
28
29
30

}

31

58

4 Vergleich wichtiger Sprachkonzepte

private static void readFile() {
try (InputStream in = Files.newInputStream(filePath);
BufferedReader reader = new BufferedReader(new
,→
InputStreamReader(in))) {
String line = null;
while ((line = reader.readLine()) != null) {
System.out.println(line);
}
} catch (IOException x) {
throw new RuntimeException(x);
}
}

32
33
34

35
36
37
38
39
40
41
42
43

}

Listing 4.24: Datei-Ein- und Ausgabe in Java [18]

In Java sind darüber hinaus viele Bibliotheken erhältlich, die das Parsen von bestimmten,
standardisierten Dateiformaten erleichtern können. Jedoch erfordert es ohne diese
Bibliotheken stets eigene Implementierungen, da das JDK nicht viel mehr als die
gezeigten Abstraktionen und Möglichkeiten bietet.

Dateien in COBOL
In COBOL hingegen wird der Zugriff auf Dateien auf Basis sogenannter Records
bewerkstelligt. Dies entspricht weitestgehend dem gezeigten Java-Beispiel, jedoch hat
der Entwickler hier die Möglichkeit zu definieren, wie eine Zeile der Datei aufgebaut ist.
Dies setzt zwar voraus, dass der Dateiinhalt in einer Art Tabelle formatiert ist, sorgt
aber dafür, dass kein Mehraufwand beim Parsen nötig ist.

1
2
3

26
21
45

Monika Hofmann
Marc
Bauer
Sophia
Maier

Listing 4.25: Ein- bzw. Ausgabedatei recordFile.txt

59

4 Vergleich wichtiger Sprachkonzepte

1
2
3
4
5
6
7

01 PERSON.
88 EOF VALUE HIGH-VALUES.
05 AGE PIC 9(3).
05 FILLER PIC X.
05 FIRSTNAME PIC X(9).
05 FILLER PIC X.
05 SURNAME PIC X(7).

Listing 4.26: Personendaten Copybook

Listing 4.25 zeigt den Aufbau der zu verarbeitenden Datensätze, die in Listing 4.26 als
COBOL Struktur definiert sind. Listing 4.28 und Listing 4.27 beinhalten Sections, die
die Datei-Ein- bzw. Ausgabe bewerkstelligen. Diese werden durch den COPY Befehl in
Listing 4.29 eingebunden und genutzt. Zeile 7 spezifiziert dabei, dass es sich um eine
Datei handelt, deren Einträge durch einen Zeilenvorschub getrennt sind.

1
2
3
4
5
6
7

WRITE-FILE SECTION.
DISPLAY "Write to file:".
OPEN EXTEND RecordFile.
DISPLAY "AGE FIRSTNAME SURNAME"
ACCEPT PERSON.
WRITE PERSON.
CLOSE RecordFile.

Listing 4.27: Dateien schreiben in COBOL (vgl. [28])

1
2
3
4
5
6
7
8
9
10
11

READ-FILE SECTION.
DISPLAY "Read from file:".
OPEN INPUT RecordFile.
PERFORM UNTIL EOF
READ RecordFile AT END SET EOF TO TRUE
END-READ
IF EOF EXIT PERFORM CYCLE
END-IF
DISPLAY "Age: " AGE SPACE "Name: " SURNAME ", " FIRSTNAME
END-PERFORM.
CLOSE RecordFile.

60

4 Vergleich wichtiger Sprachkonzepte
Listing 4.28: Dateien lesen in COBOL (vgl. [28])

Im Gegensatz dazu kann man den Aufbau als ORGANIZATION IS RECORD SEQUENTIAL
bzw. ORGANIZATION IS SEQUENTIAL definieren oder weglassen, da dies dem Standard
entspricht, was bedeutet, dass die Einträge nicht voneinander abgetrennt sind. Dies
wäre gleichbedeutend mit dem Entfernen der Zeilenumbrüche in Listing 4.25.

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25

IDENTIFICATION DIVISION.
PROGRAM-ID. ENTITIES.
DATA DIVISION.
WORKING-STORAGE SECTION.
01 PERSON OCCURS 4 TIMES INDEXED BY PE-IDX.
05 FNAME PIC X(6).
05 SNAME PIC X(6).
05 PA-IDX PIC 9.
PROCEDURE DIVISION.
MAIN-PROCEDURE.
PERFORM SET-PARTNER.
PERFORM PRINT-PARTNER.
STOP RUN.
SET-PARTNER SECTION.
MOVE " Anna Wolf3" TO PERSON(1).
MOVE "Hubert Mayer4" TO PERSON(2).
MOVE " Olaf Wolf1" TO PERSON(3).
MOVE "Ursula Mayer2" TO PERSON(4).
PRINT-PARTNER SECTION.
PERFORM VARYING PE-IDX FROM 1 BY 1 UNTIL PE-IDX = 5
DISPLAY FNAME(PE-IDX)" "SNAME(PE-IDX)
" is married with "
FNAME(PA-IDX(PE-IDX))" "SNAME(PA-IDX(PE-IDX))
END-PERFORM.
END PROGRAM ENTITIES.

61

4 Vergleich wichtiger Sprachkonzepte

1

Write to file:

2

AGE FIRSTNAME SURNAME

3

44

Adam

Opal

4

Read from file:

5

Age:

26 Name: Hofmann,

6

Age:

21 Name:

Bauer,

Marc

7

Age:

45 Name:

Maier,

Sophia

8

Age:

44 Name:

Opal,

Adam

Monika

Listing 4.29: Datei-Ein- und Ausgabe in COBOL (vgl. [28])

Mit relativer Dateiorganisation – ORGANIZATION IS RELATIVE – und anderen Zugriffsmodi wie ACCESS MODE IS RANDOM lassen sich auch nicht-sequenzielle Dateizugriffe,
beispielsweise über Record-Indizes, realisieren.

4.6 Generische Programmierung
Moderne Programmiersprachen wie Java oder C# erlauben eine Programmierung mit
sogenannten Generics. Dabei handelt es sich um ein Konzept, bei dem Variablentypen
generisch sein können, solange sie bestimmte Eigenschaften erfüllen. Diese Eigenschaften werden durch das Implementieren eines bestimmten Interfaces oder durch das
Erben von einer bestimmten Klasse beschrieben und bestehen im einfachsten Fall aus
dem Erben von der Klasse Object, was für jede Java-Klasse der Fall ist. Dies soll
Listing 4.30 verdeutlichen. Hieran wird auch deutlich, dass sowohl für Interfaces als
auch für Oberklassen stets das Schlüsselwort extends verwendet werden muss.
In diesem Beispiel werden die drei generischen Typen S, T und U verwendet. T muss
dabei die Eigenschaft erfüllen, das Serializable Interface zu implementieren. S muss
eine Unterklasse von Number sein. Für U hingegen wird keine bestimmte Eigenschaft
definiert. Das bedeutet, wie oben beschrieben, dass jede Klasse, die von der Klasse
Object erbt, verwendet werden kann.
Eine weitere Eigenschaft, die gezeigt werden soll, ist, dass es sowohl generische Klassen
als auch generische Methoden geben kann. Generische Typen, die für eine Klasse
definiert sind, stehen in der gesamten Klasse zur Verfügung, müssen jedoch bereits beim

62

4 Vergleich wichtiger Sprachkonzepte
instanziieren festgelegt werden. Generische Methoden hingegen definieren generische
Typen nur für den eigenen Scope.

1

import java.io.Serializable;

2
3
4
5
6
7

public class GenericExample {
public static void main(String... args) {
GenericType<Exception, Float> generic = new GenericType<>();
generic.decorate(generic);
}

8

static class GenericType<T extends Serializable, S extends Number> {
T serializableObject;
S someNumber;
public <U> String decorate(final U someObject) {
return "~" + someObject.toString() + "~";
}
}

9
10
11
12
13
14
15
16

}

Listing 4.30: Generics in Java

Dieses Konzept sorgt dafür, dass Algorithmen implementiert und als Bibliotheken bereitgestellt werden können, ohne Kenntnis über die tatsächlich verwendeten Datentypen
zu haben, was die in Abschnitt 3.3 angesprochenen Modularisierungsmöglichkeiten
unterstützt. Beispielsweise kann ein Sortieralgorithmus implementiert werden, welcher
generische Objekte entgegennimmt, die das Comparable-Interface – ein Java Interface,
das dafür sorgt, dass zwei Objekte in Größenbeziehung gesetzt werden können – implementieren. Folglich können mit diesem Algorithmus alle Objekte sortiert werden, die das
Interface implementieren. Dieses Konzept ist in der objektorientierten Programmierung
grundlegend und trägt maßgeblich zur Wiederverwendung und Kapselung bei.
COBOL hingegen unterstützt keine generischen Datentypen, was, wie in Abschnitt 3.3
gezeigt, deutlich weniger Möglichkeiten zur Wiederverwendung und Modularisierung
mithilfe von Bibliotheken zur Folge hat.

63

4 Vergleich wichtiger Sprachkonzepte

4.7 Konventionen
Da in umfangreichen Softwareprojekten oft eine Vielzahl von Entwicklern tätig sind
und sich das Entwicklerteam auch über die Zeit ändern kann, ist es nötig, dass alle
Entwickler einen ähnlichen Stil verfolgen, sodass das Zurechtfinden innerhalb des Codes
eines anderen Programmierers erleichtert wird. Diese Konventionen können zwar auch
auf Projektebene festgelegt werden, jedoch entwickeln sich in Programmiersprachen oft
Konventionen, die sich projekt-, personen- und unternehmensunabhängig etablieren. In
diesem Kapitel werden die wichtigsten dieser Konventionen beschrieben.

Groß- und Kleinschreibung
Beim Programmieren wird oftmals Groß- und Kleinschreibung verwendet, um ein
höheres Maß an Struktur und Lesbarkeit des Codes zu erreichen.
Java ist »case-sensitive«, d. h. es wird zwischen Groß- und Kleinbuchstaben unterschieden, während COBOL »case-insensitive« ist, folglich – außer in Strings – keinen
Unterschied macht. In Java ist es üblich, Methodennamen und veränderbare Variablen
mit einem kleinen Buchstaben beginnend zu benennen. Besteht der Name aus mehreren Wörtern, so wird dieser im »CamelCase« geschrieben, was bedeutet, dass stets
Großbuchstaben für den Beginn eines folgenden Wortes verwendet werden. Beispiele
hierfür wären getAdditionalData() oder int currentAmountOfMoney. Klassennamen
werden in selbigem Muster geschrieben, beginnen jedoch mit einem Großbuchstaben:
ToolBox. Konstante Variablen und Werte innerhalb eines Aufzählungstyps sollten durchgehend aus Großbuchstaben bestehen, wobei einzelne Wörter mit einem Unterstrich
voneinander getrennt werden (final int MULIPLY_FACTOR = 2).
COBOL hingegen unterscheidet bei Variablennamen und Schlüsselwörtern nicht zwischen
Groß- und Kleinschreibung. Es ist jedoch üblich, sowohl Schlüsselwörter als auch
Variablennamen komplett groß zu schreiben. Dies rührt daher, dass COBOL aus der
Lochkartenzeit stammt, die meist lediglich Großbuchstaben im Zeichensatz hatten. Auch
frühe Host-Systeme, auf denen COBOL entwickelt und ausgeführt wurden, arbeiteten
meist nur mit Großschreibung, sodass Programme auch über die Zeit hinweg nur so
geschrieben wurden.

64

4 Vergleich wichtiger Sprachkonzepte

Affixe
Ein weiteres wichtiges Werkzeug bei der Strukturierung von Programmcode ist das
Versehen mit Affixen (Prä- oder Suffixen).
In Java ist es nicht ratsam, Affixe zu verwenden. Da diese jedoch in einigen bestehende
Codebasen Verwendung finden, werden im Folgenden die üblichsten behandelt. Oftmals
werden Interfaces in Java mit einem vorangestellten »I« gekennzeichnet. Diese Konvention sorgt jedoch dafür, dass Implementierungen eines Interfaces namentlich nicht immer
klar abgegrenzt und definiert sind. Wird beispielsweise ein Interface IOutput definiert,
so könnten valide Implementierungen ConsoleOutput oder PrinterOutput sein. Jedoch
erlaubt dies namentlich auch die Interface-Implementierung namens Output, bei der
nicht ausreichend klar ist, welchen Zweck diese Klasse erfüllt.
Ein weiterer Codingstil, der gelegentlich angewendet wird, ist das Nutzen von »m«
und »s« als Präfix von Variablen. Diese sollen kennzeichnen, dass eine Variable entweder Instanzvariable (member) oder statisch (static) ist. Durch die Verwendung von
modernen IDEs, die beide farblich unterschiedlich darstellen, und des Schlüsselwortes
this, welches exakt für Referenzen auf Instanzvariablen gedacht ist, werden Variablen
jedoch bereits ausreichend gekennzeichnet, sodass der Code durch die Verwendung
dieser Präfixe unnötigerweise schwerer lesbar gemacht wird.
In COBOL ist es in der Praxis dagegen sehr sinnvoll, Affixe zu verwenden. Da es nicht
möglich ist, lokale Variablen zu definieren, erlauben diese, schnell und übersichtlich
kenntlich zu machen, welche Variablen zu welchem Programmteil gehören. Dabei handelt
es sich um eine Best-Practice-Methode, um den Code verständlicher und leichter lesbar
zu machen, wie Herr Streit im Fachinterview betonte, auch wenn in der Praxis oftmals
darauf verzichtet wird.
So kann man den Namen einer Section oder eines Paragraph mit einem Präfix versehen
und auch die darin genutzten Variablen damit kennzeichnen. Beispielsweise sollte eine
Variable PC-100-VALUE nur in der Section PC-100-PROCESS verwendet werden.
Oft finden sich in bestehendem Code auch Präfixe, welche die Speicherart – z. B. WS- für
WORKING-STORAGE – kennzeichnen. Eine Benennung nach den genutzten Programmteilen
ist jedoch vorzuziehen und sorgt für klarere Struktur und Lesbarkeit.

65

4 Vergleich wichtiger Sprachkonzepte
In COBOL ist jedoch Vorsicht geboten, da, vor allem in alten Systemen, die Zeichenzahl
von Datei-, Programm- und Variablennamen Begrenzungen unterliegt. So ist es nicht
unüblich, dass beispielsweise lediglich 8 Stellen für Dateinamen zur Verfügung stehen,
was eine sinnvolle Benennung erheblich erschwert. Dies ist auch ein Grund dafür, dass
Affixe seltener beobachtbar sind, als sie sein sollten.

Schlüsselwörter
In COBOL ist es möglich, bestimmte Schlüsselwörter zu verkürzen. Dabei kann jedoch
nicht beliebig gekürzt werden. Es sind lediglich weitere Schlüsselwörter mit selber
Funktion definiert, die genutzt werden können. Ein Beispiel dafür ist die PICTUREAnweisung, die auch als PIC geschrieben werden kann. Dabei handelt es sich zwar nicht
um eine Konvention im eigentlichen Sinne, jedoch findet sich in der Praxis oftmals
COBOL-Code, der gekürzte Schlüsselwörter verwendet.
In Java ist ein Verkürzen von Schlüsselwörtern hingegen nicht möglich.

Formatierung des Quelltextes
Neben den in Abschnitt 4.1 beschriebenen fest vorgegebenen strukturellen Eigenschaften
von Java- und COBOL-Programmen, lassen sich auch Konventionen beschreiben, die
das Formatieren des Quelltextes betreffen.
Für COBOL und Java gilt hierbei gleichermaßen, dass pro Zeile genau ein Statement
stehen sollte. Alles innerhalb eines Blocks – untergeordnete Anweisungen – wird konventionell um einen Tabulatorsprung eingerückt. Außerdem sollten zwischen Blöcken
und Anweisungen Leerzeilen eingefügt werden, die die Lesbarkeit erhöhen. In COBOL
ist jedoch bei der Einrückung das bereits beschriebene Spaltenprinzip zu beachten.

66

4 Vergleich wichtiger Sprachkonzepte

4.8 Weitere Sprachkonzepte
4.8.1 Benannte Bedingungen
Neben den bereits angesprochenen Stufennummern stellt die 88 eine weitere Besonderheit in COBOL dar. Mit ihr ist es möglich, einer Variable einen Wahrheitswert
zuzuweisen, der von einem anderen Variablenwert abhängt. Es entsteht eine sogenannte
benannte Bedingung.
Listing 4.31 zeigt die Verwendung der Stufennummer 88. Die Variable AGE kann dabei
zweistellige numerische Werte enthalten, die einem beispielhaften Alter entsprechen,
welches zu Beginn mit 13 vorbelegt wird. Liegt der Wert zwischen 0 und 17 (VALUE 0
THRU 17), so weisen die Variablen ISUNDERAGE den Wahrheitswert TRUE und ISADULT
den Wahrheitswert FALSE auf.
Der so entstandene Wahrheitswert kann folglich immer dann verwendet werden, wenn
überprüft werden soll, ob die Variable AGE im Bereich zwischen 0 und 17 bzw. zwischen
17 und 99 liegt, sprich getestet werden, ob das Alter einer minder- oder volljährigen
Person entspricht.

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18

IDENTIFICATION DIVISION.
PROGRAM-ID. EIGHTYEIGHT.
DATA DIVISION.
WORKING-STORAGE SECTION.
01 AGE PIC 9(2) VALUE 13.
88 ISUNDERAGE VALUE 0 THRU 17.
88 ISADULT VALUE 18 THRU 99.
PROCEDURE DIVISION.
MAIN.
IF ISUNDERAGE THEN
DISPLAY 'Person is underage (AGE = 'AGE')'
ELSE
DISPLAY 'Person is adult'
END-IF.
SET ISADULT TO TRUE
DISPLAY 'AGE = ' AGE.
STOP RUN.
END PROGRAM EIGHTYEIGHT.

67

4 Vergleich wichtiger Sprachkonzepte

1

$ ./eightyeight

2

Person is underage (AGE = 13)

3

AGE = 18

Listing 4.31: Beispiel für COBOL Stufennummer 88

Zeile 15 des Programms illustriert einen weiteren Anwendungsfall der benannten Bedingungen. So lässt sich der Wert der eigentlichen Variable setzen, indem der bedingten
Variable der Wahrheitswert TRUE zugewiesen wird. Das Ergebnis dieser Zuweisung wird
in der Ausgabe von Listing 4.31 in Zeile 3 dargestellt. Zu beachten ist hierbei, dass die
meisten COBOL-Compiler nur das Setzen des Wertes TRUE erlauben.
Dieses Verhalten kann dazu genutzt werden, um Variablen mit bestimmten Werten zu
belegen, wie Listing 4.32 zeigt. Oftmals fungieren diese benannten Bedingungen auch
als Schalter bzw. Flags, d. h. je nach Wert werden unterschiedliche Funktionalitäten
ausgeführt.

68

4 Vergleich wichtiger Sprachkonzepte

1
2
3
4
5
6
7
8
9
10
11
12
13
14

IDENTIFICATION DIVISION.
PROGRAM-ID. VALUE-DEFAULT.
DATA DIVISION.
WORKING-STORAGE SECTION.
01 ERROR-MESSAGE PIC X(50) VALUE SPACE.
88 FIRST-ERROR VALUE "The first error occured!".
88 SECOND-ERROR VALUE "The second error occured!".
88 THIRD-ERROR VALUE "The third error occured!".
PROCEDURE DIVISION.
MAIN.
SET SECOND-ERROR TO TRUE.
DISPLAY ERROR-MESSAGE.
STOP RUN.
END PROGRAM VALUE-DEFAULT.

Listing 4.32: Setzen von Werten mithilfe benannter Bedingungen

Abbildung in Java

Java besitzt kein Sprachkonstrukt, um die Funktionalität der Stufennummer 88 direkt
nachzubilden. Eine Möglichkeit, gleiches Verhalten darzustellen bietet allerdings die
Implementierung spezieller Methoden. Dies soll Listing 4.33 veranschaulichen.

1

public class EightyEight{

2
3
4
5
6
7
8

public static void main(String[] args) {
AgeCheck ageCheck = new AgeCheck();
printAgeInformation(ageCheck);
ageCheck.setAge(18);
printAgeInformation(ageCheck);
}

9
10
11
12
13
14
15
16

public static void printAgeInformation(AgeCheck ageCheck)
{
System.out.println(
String.format(
"Age %s is %s!",
ageCheck.getAge(),
ageCheck.isAdult() ? "adult":"underage"

69

4 Vergleich wichtiger Sprachkonzepte

)

17

);
}
static class AgeCheck {
private int age;

18
19
20
21
22

public AgeCheck() {
age = 13;
}

23
24
25
26

public void setAge(int newAge) {
age = newAge;
}

27
28
29
30

public int getAge() {
return age;
}

31
32
33
34

public boolean isUnderage() {
return (0 <= age && age <= 17);
}

35
36
37
38

public boolean isAdult() {
return (age >= 18);
}

39
40
41

}

42
43

}

Listing 4.33: Bedingte Werte in Java

Die Methoden isUnderage und isAdult geben einen Wahrheitswert in Abhängigkeit
des Variablenwertes zurück. Die Funktion setAge setzt wiederum das Alter.

1
2
3
4
5

public class ValueSet {
enum ErrorMessage {
FIRST_ERROR("The first error occured!"),
SECOND_ERROR("The second error occured!"),
THIRD_ERROR("The third error occured!");

6
7

private String message;

8
9

private ErrorMessage(String message){

70

4 Vergleich wichtiger Sprachkonzepte

this.message = message;

10

}

11
12

String getMessage() {
return this.message;
}

13
14
15

}

16
17

public static void main(String[] args) {
ErrorMessage errorMessage = ErrorMessage.SECOND_ERROR;
System.out.println(errorMessage.getMessage());
}

18
19
20
21
22

}

Listing 4.34: Setzen eines konstanten Wertes mit einem Enum in Java

Der Anwendungsfall, dass eine benannte Bedingung in COBOL verwendet wird, um
bestimmte Werte zu setzen, lässt sich in Java am elegantesten über Aufzählungstypen,
also enums, realisieren. Wie der Typ ErrorMessage in Listing 4.34 zeigt, setzt jeder
einzelne konstante Wert des Aufzählungstypen eine eigene Fehlernachricht, welche
anschließend über die getMessage-Funktion verfügbar ist.

4.8.2 Mehrfachverzweigungen
Ein wichtiges Konstrukt, um den Programmfluss eines Programms zu steuern, sind
Mehrfachverzweigungen. Obwohl sowohl Java als auch COBOL Mehrfachverzweigungen bieten, sind diese doch leicht unterschiedlich zu verwenden. Im Folgenden sollen
verschiedene Verwendungsmöglichkeiten der jeweiligen Konstrukte dargestellt werden.

Mehrfachverzweigungen in Java

In Java bildet das switch-case-Konstrukt eine Mehrfachverzweigung ab. Listing 4.35
zeigt dabei die wichtigsten Verwendungsmöglichkeiten. Zu beachten ist, dass Werte nur
mit Literalen und Konstanten verglichen werden können. Ein Vergleich einer Variablen
mit einer weiteren ist hierbei nicht zulässig, solange diese nicht als final deklariert
ist. Auch der Vergleich auf bestimmte Wertebereiche oder nicht-primitive Datentypen

71

4 Vergleich wichtiger Sprachkonzepte
– ausgenommen sind deren Wrapper-Klassen – ist nicht zulässig. Seit Java 7 sind
Vergleiche mit String-Literalen möglich.

1

public class MyCalendar {

2

public void printMonthDays(int month)
{
switch(month){
case 1: case 3: case 5: case 7:
case 8: case 10: case 12:
System.out.println("This Month has 31 days.");
break;
case 2:
System.out.println("This Month has 28 or 29 days.");
break;
case 4: case 6: case 9: case 11:
System.out.println("This Month has 30 days.");
break;
default:
System.out.println("Month is not valid");
break;
}
}

3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21

}

Listing 4.35: Mehrfachverzweigungen in Java

Jedoch ist ein gewolltes »Durchfallen« möglich, um bei verschiedenen Werten die
gleichen Programmzweige zu durchlaufen. Dabei spielt das Schlüsselwort break eine
entscheidende Rolle. Wird kein break am Ende einer case-Anweisung verwendet, so wird
automatisch in den ausführbaren Block der darauffolgenden case-Anweisung gesprungen.
Dies zeigt sich in den Zeilen 6, 7, 10 und 13 von Listing 4.35. Die Verwendung der breakAnweisung wird hingegen in den Zeilen 9, 12 und 15 genutzt, um den switch-Block zu
verlassen.
Das Fehlen eines break kann in der Praxis schnell zu unerwünschtem und unerklärlichem
Verhalten führen. Deshalb folgt in der Regel jedem case ein break.

72

4 Vergleich wichtiger Sprachkonzepte
Mehrfachverzweigungen in COBOL

Das Pendant in COBOL stellt das Schlüsselwort EVALUATE dar. Wenngleich es den
gleichen Sinn wie das switch-case-Konstrukt in Java erfüllen soll, ist es vielseitiger
einsetzbar, wie die folgenden Beispiele illustrieren sollen. Listing 4.36 und Listing 4.37
sind hierbei semantisch gleich, obwohl das EVALUATE-Konstrukt jeweils leicht anders
verwendet wird.
Das folgende Listing 4.36 führt die Verwendungsmöglichkeit an, die dem switch-caseKonstrukt in Java am nächsten kommt. Nach dem EVALUATE-Schlüsselwort werden
Variablennamen angegeben, deren Werte anschließend in einer WHEN-Bedingung betrachtet werden sollen.
Auch hier sieht man in den Zeilen 12, 15, 18 und 21 ein gewolltes »Durchfallen« wie in
Java. Einziger Unterschied hierbei ist, dass in COBOL jeder ausführbare Block nach
einem WHEN eigenständig und somit kein break notwendig ist. Ein »Durchfallen« ist
nur möglich, wenn der komplette Anweisungsblock leer ist.
Der OTHER-Zweig entspricht in COBOL dem aus Java bekannten default. Dieser Zweig
wird ausgeführt, wenn die Kriterien keines anderen zutreffen.
Die erste Besonderheit, die Listing 4.36 illustrieren soll, ist das Testen von jeweils
zwei Bedingungen. Dies geschieht mithilfe des ALSO-Schlüsselworts. Während in Java
lediglich die Evaluation einer einzelnen Bedingung möglich ist, erlaubt COBOL die
Überprüfung beliebig vieler Kriterien.

1
2
3
4
5
6
7
8
9
10
11
12
13

IDENTIFICATION DIVISION.
PROGRAM-ID. SWITCH-CASE-EVALUATE.
DATA DIVISION.
WORKING-STORAGE SECTION.
01 AGE PIC 9(3).
01 SEX PIC X(1).
PROCEDURE DIVISION.
MAIN.
ACCEPT AGE.
ACCEPT SEX.
EVALUATE AGE ALSO SEX
WHEN 0 THRU 17 ALSO "M"
WHEN 0 THRU 17 ALSO "m"

73

4 Vergleich wichtiger Sprachkonzepte

14
15
16
17
18
19
20
21
22
23
24
25
26
27
28

DISPLAY "Underage boy"
WHEN 0 THRU 17 ALSO "F"
WHEN 0 THRU 17 ALSO "f"
DISPLAY "Underage girl"
WHEN 17 THRU 99 ALSO "M"
WHEN 17 THRU 99 ALSO "m"
DISPLAY "Adult man"
WHEN 17 THRU 99 ALSO "F"
WHEN 17 THRU 99 ALSO "f"
DISPLAY "Adult woman"
WHEN OTHER
DISPLAY "Unknown age or gender"
END-EVALUATE.
STOP RUN.
END PROGRAM SWITCH-CASE-EVALUATE.

Listing 4.36: Mehrfachverzweigungen in COBOL mit ALSO

Eine weitere Eigenheit zeigt sich in der Auswertung der Variable AGE. Hierbei werden
im Beispiel Wertebereiche angegeben, in denen die Variable liegen kann. Auch das ist in
Java so nicht möglich, da nur mit Literalen und Konstanten verglichen werden kann.
Listing 4.37 stellt weitere Unterschiede zu Mehrfachverzweigungen in Java dar. So ist
diese EVALUATE TRUE-Variante (auch als EVALUATE FALSE möglich) mit geschachtelten
if-Abfragen in Java zu vergleichen. Jede Bedingung hinter dem WHEN-Schlüsselwort
entspricht hierbei einem vollständigen logischen Ausdruck. Daher ist es möglich, wie
in Zeile 14 gezeigt, Rechenoperationen durchzuführen oder logische Operatoren wie in
diesem Fall das OR zu verwenden.

1
2
3
4
5
6
7
8
9
10
11

IDENTIFICATION DIVISION.
PROGRAM-ID. SWTICH-CASE-EVALUATE.
DATA DIVISION.
WORKING-STORAGE SECTION.
01 FIRST-NUM PIC 9(2).
01 SECOND-NUM PIC 9(2).
PROCEDURE DIVISION.
MAIN.
ACCEPT FIRST-NUM.
ACCEPT SECOND-NUM.
EVALUATE TRUE

74

4 Vergleich wichtiger Sprachkonzepte

12
13
14
15
16
17
18
19
20
21

WHEN FIRST-NUM EQUALS SECOND-NUM
DISPLAY "Both numbers are equal"
WHEN FIRST-NUM > SECOND-NUM*2 OR FIRST-NUM*2 < SECOND-NUM
DISPLAY "One number is more then twice the other"
WHEN FIRST-NUM < SECOND-NUM
DISPLAY "The first number is lower"
WHEN FIRST-NUM > SECOND-NUM
DISPLAY "The first number is greater"
END-EVALUATE.
STOP RUN.

Listing 4.37: Mehrfachverzweigungen in COBOL als EVALUATE TRUE

Mithilfe des ALSO-Schlüsselworts sind sowohl Variablen-Vergleiche wie in Listing 4.36
als auch TRUE-Vergleiche wie in Listing 4.37 zusammen möglich.

4.8.3 Speicherausrichtung
Dieser Abschnitt soll einen kurzen Abriss über die COBOL Stufennummer 77 geben.
Mit der Stufennummer 77 deklarierte Daten haben folgende beiden Eigenschaften:
• Die Variable kann nicht weiter unter gruppiert werden.
• Die Variable wird an festen Grenzen des Speichers ausgerichtet.
Während ersteres wenig Bedeutung in der Praxis hat, war es früher nötig, Variablen für
bestimmte Instruktionen an festen Speichergrenzen auszurichten. Üblicherweise mussten
die Adressen dieser Grenzen je nach Compiler ganzzahlig durch 4 bzw. 8 teilbar sein.
Dieses Verhalten ist heutzutage jedoch nicht mehr nötig. Dies und die Tatsache, dass
durch forcierte Speicherausrichtung Speicherbereiche zwischen Daten mit Stufennummer
77 ungenutzt, aber reserviert bleiben, führen dazu, dass diese Stufennummer nicht mehr
genutzt werden sollte.
In Java gibt es kein vergleichbares Konzept, da die Speicherverwaltung komplett abstrahiert ist und dem Entwickler nicht ermöglicht wird, direkten Einfluss darauf zu
nehmen.

75

4 Vergleich wichtiger Sprachkonzepte

4.8.4 Reorganisation von Daten
Dieser Abschnitt beschreibt die COBOL Stufennummer 66, die eine besondere Rolle
spielt.
In Listing 4.38 wird die Stufennummer 66 in Verbindung mit der RENAMES-Anweisung,
was zwingend erforderlich ist, verwendet, um Teile der Personendaten neu zu gruppieren.
Dies geschieht durch die Verwendung des THRU-Schlüsselworts. Ohne die Angabe dieses
Bereichs können auch einzelne Variablen umbenannt werden. Hierbei wird lediglich
eine neue Referenz auf den selben Speicherbereich erstellt, nicht jedoch neuer Speicher
alloziert.

IDENTIFICATION DIVISION.
PROGRAM-ID. COBOL-RENAMES-EXAMPLE.
DATA DIVISION.
FILE SECTION.
WORKING-STORAGE SECTION.
01 PERSON-DATA.
05 FIRST-NAME PIC X(10) VALUE "Max".
05 SURNAME PIC X(10) VALUE "Mustermann".
05 STREET PIC X(15) VALUE "Musterstraße".
05 HOUSENUMBER PIC X(5) VALUE "7a".
05 ZIP-CODE PIC X(6) VALUE "12345".
05 CITY PIC X(15) VALUE "Musterstadt".

1
2
3
4
5
6
7
8
9
10
11
12
13

66 PERSON-NAME RENAMES FIRST-NAME THRU SURNAME.
66 PERSON-ADDRESS RENAMES STREET THRU CITY.
PROCEDURE DIVISION.
MAIN-PROCEDURE.
DISPLAY PERSON-NAME.
DISPLAY PERSON-ADDRESS.
STOP RUN.
END PROGRAM COBOL-RENAMES-EXAMPLE.

14
15
16
17
18
19
20
21

1

Max

Mustermann

2

Musterstraße

7a

12345 Musterstadt

Listing 4.38: Stufennummer 66 und RENAMES-Befehl

76

4 Vergleich wichtiger Sprachkonzepte
Diese Stufennummer wird in der Praxis selten verwendet und auch ist in Java zu dieser
Stufennummer kein exaktes Pendant zu finden.

Abbildung in Java

Die Gruppierung von Daten erfolgt in Java in eigenen Klassen, aus denen sich wiederum
andere Objekte zusammensetzen können. Diese Aggregationsbeziehung ist im Diagramm
in Abbildung 4.3 dargestellt.
Address
Name

Person

street : String

firstName : String

name : Name

houseNumber : String

surname : String

address : Address

zipCode : String
city : String

Abbildung 4.3: UML-Diagramm einer Aggregation

Die Verwendung der Stufennummer 66 als reines Umbenennen eines Datums entfällt in
Java, da in diesem Fall neue Variablen mit anderen Namen deklariert werden können,
welchen der ursprüngliche Wert zugewiesen wird.

4.8.5 Implizierte Variablennamen
Dieser Abschnitt behandelt einen Fehler, der typischerweise zu Beginn in der Softwareentwicklung beobachtet werden kann. Listing 4.39 zeigt, wie Anfänger häufig versuchen,
logische Ausdrücke zu konstruieren. Dies entspricht dem intuitiven Gedanken »Wenn
Variable X größer 0 und kleiner 5 ist, dann . . . « oder der mathematischen Definition
»0 < X < 5«.

77

4 Vergleich wichtiger Sprachkonzepte

public class IfVariableError {

1
2

public static void main(String[] args) {
long timeMillis = System.currentTimeMillis();

3
4
5

if (timeMillis > 0 && < Long.MAX_VALUE) {
System.out.println("We never get here!");
}

6
7
8
9

if (0 < timeMillis < Long.MAX_VALUE) {
System.out.println("We never get here either!");
}

10
11
12

}

13

}

14

1

$ javac -Xmaxerrs 2 IfVariableError.java

2

IfVariableError.java:4: error: > expected

3

if (System.currentTimeMillis() > 0 && < Long.MAX_VALUE) {
^

4
5
6

IfVariableError.java:4: error: ')' expected
if (System.currentTimeMillis() > 0 && < Long.MAX_VALUE) {
^

7
8

2 errors

Listing 4.39: Keine implizierten Variablennamen in logischen Ausdrücken in Java

Versucht man, Listing 4.39 zu kompilieren, treten einige Fehler auf. In Java können
nur vollständige logische Ausdrücke mit logischen Operatoren verknüpft werden. Zum
anderen kann innerhalb eines logischen Ausdrucks lediglich maximal einmal ein Vergleichsoperator verwendet werden.
Listing 4.40 demonstriert eine funktionsfähige Implementierung des vorhergehenden
Beispiels. Dieser Code kann fehlerfrei kompiliert und ausgeführt werden wie die Ausgabe
zeigt.

78

4 Vergleich wichtiger Sprachkonzepte

public class IfVariableNoError {

1
2

public static void main(String[] args) {
long timeMillis = System.currentTimeMillis();
if (0 < timeMillis && timeMillis < Long.MAX_VALUE) {
System.out.println("We get here everytime!");
}
}

3
4
5
6
7
8

}

9

1

$ javac IfVariableNoError.java

2

$ java IfVariableNoError

3

We get here everytime!

Listing 4.40: Verwendung von Variablennamen in logischen Ausdrücken in Java

Implizierte Variablennamen in COBOL

In COBOL hingegen ist das Schreiben von logischen Ausdrücken mit implizierten
Variablennamen möglich. Listing 4.41 stellt in Zeile 11 die Verwendung in COBOL dar,
die im Gegensatz zu Java möglich ist.

1
2

IDENTIFICATION DIVISION.
PROGRAM-ID. IMPLICIT-VARIABLE-NAMES.

3
4
5
6

DATA DIVISION.
WORKING-STORAGE SECTION.
01 INPUT-NUMBER PIC 9(2).

7
8
9
10
11
12
13

PROCEDURE DIVISION.
MAIN-PROCEDURE.
ACCEPT INPUT-NUMBER.
IF INPUT-NUMBER >= 10 AND <= 20 THEN
DISPLAY "Your number is >= 10 and <= 20."
ELSE

79

4 Vergleich wichtiger Sprachkonzepte

14
15
16

DISPLAY "Your number is < 10 or > 20."
END-IF.
STOP RUN.

17
18

END PROGRAM IMPLICIT-VARIABLE-NAMES.

Listing 4.41: Implizierte Variablennamen in COBOL

4.8.6 Modifier
In Java ist es, anders als in COBOL, möglich die Sichtbarkeit von Variablen, Funktionen
und Klassen nach außen zu steuern. Dazu dienen sogenannte Modifier, die an dieser
Stelle kurz erläutert werden.
Auf Funktionen oder Variablen, die mit dem Schlüsselwort public gekennzeichnet sind,
kann von jeder Stelle des Programms aus zugegriffen werden.
Durch protected wird der Zugriff auf die enthaltende Klasse, mitsamt geschachtelter
Klassen, und alle Unterklassen beschränkt. Erbt eine Klasse eine solche Methode oder
Variable, kann sie diese nutzen. Andere Klassen haben keinen Zugriff darauf.
Um maximal-restriktiven Zugriff auf einen Teil einer Klasse sicherzustellen, bietet sich
das Schlüsselwort private an. Dieses erlaubt nur Zugriffe aus der enthaltenden Klasse
und aus geschachtelten Klassen, d. h. nur aus der Datei in der die private-Definition
erfolgt.
Wird kein Schlüsselwort explizit genutzt, so ist die Sichtbarkeit auf das aktuelle Package
beschränkt (engl. package-private). Das bedeutet, dass alle Klassen des Packages Zugriff
erhalten, wohingegen Klassen anderer Packages keinen erhalten.

4.8.7 Assoziation von Entitäten
Vor allem in der objektorientierten Programmierung ist es nötig, innerhalb von Objekten
Referenzen auf andere Entitäten zu halten, um so Verbindungen zwischen diesen Ob-

80

4 Vergleich wichtiger Sprachkonzepte
jekten zu realisieren. Damit können Funktionalitäten und Daten von anderen Entitäten
genutzt und verändert werden.
In der Regel unterscheidet man zwischen drei Arten von Assoziationen. Die 1-zu-1 Beziehung beschreibt eine Beziehung bei der jeweils einem Objekt ein anderes zugeordnet ist.
Ein Beispiel dafür wäre eine klassische Ehekonstellation, bei der einem Partner genau ein
anderer zugeordnet wird, wobei auch Beziehungen zwischen Entitäten unterschiedlicher
Typen möglich sind.
Bei der 1-zu-N Assoziation hingegen wird einer Entität eine Menge anderer zugeordnet. Exemplarisch dafür wäre eine Bibliothek-Buch Beziehung. Während ein konkret
gedrucktes Buchexemplar nur in einer Bibliothek stehen kann, kann diese mehrere (N)
Bücher beinhalten.

1

public class AssociationExample {

2

class MarriageParticipant { // 1-to-1 association
MarriageParticipant partner;
}

3
4
5
6

class Library { // 1-to-many association
List<Book> books;
}
class Book {
Library library;
}

7
8
9
10
11
12
13

class Student { // many-to-many association
List<Course> courses;
}
class Course {
List<Student> students;
}

14
15
16
17
18
19
20

}

Listing 4.42: Assoziationen in Java

Die dritte Form stellt eine M-zu-N Assoziation dar, in der mehreren Objekten auf einer
Seite mehrere auf der jeweils anderen zugeordnet werden. Dies ist beispielsweise bei der
Beziehung von Studenten und Veranstaltungen gegeben. Während mehrere Studenten

81

4 Vergleich wichtiger Sprachkonzepte
Teil einer Veranstaltung sein können, kann ein Student mehr als eine Veranstaltung
besuchen.
In Java lassen sich diese Assoziationen durch Attribute innerhalb einer Klasse realisieren,
wie Listing 4.42 für die oben beschriebenen Beispiele zeigt. Ob diese Attribute innerhalb
der Klasse instanziiert, oder wie in Unterabschnitt 5.3.3 von außen zur Verfügung
gestellt werden, hat dabei keine Auswirkung.

IDENTIFICATION DIVISION.
PROGRAM-ID. ENTITIES.
DATA DIVISION.
WORKING-STORAGE SECTION.
01 PERSON OCCURS 4 TIMES INDEXED BY PE-IDX.
05 FNAME PIC X(6).
05 SNAME PIC X(6).
05 PA-IDX PIC 9.
PROCEDURE DIVISION.
MAIN-PROCEDURE.
PERFORM SET-PARTNER.
PERFORM PRINT-PARTNER.
STOP RUN.
SET-PARTNER SECTION.
MOVE " Anna Wolf3" TO PERSON(1).
MOVE "Hubert Mayer4" TO PERSON(2).
MOVE " Olaf Wolf1" TO PERSON(3).
MOVE "Ursula Mayer2" TO PERSON(4).
PRINT-PARTNER SECTION.
PERFORM VARYING PE-IDX FROM 1 BY 1 UNTIL PE-IDX = 5
DISPLAY FNAME(PE-IDX)" "SNAME(PE-IDX)
" is married to "
FNAME(PA-IDX(PE-IDX))" "SNAME(PA-IDX(PE-IDX))
END-PERFORM.
END PROGRAM ENTITIES.

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25

1

Anna

2

Hubert

3

Olaf

4

Ursula

Wolf is married with

Olaf

Wolf

Mayer is married with Ursula

Mayer

Wolf is married with

Anna

Wolf

Mayer is married with Hubert

Mayer

Listing 4.43: Assoziationen in COBOL

82

4 Vergleich wichtiger Sprachkonzepte
In COBOL werden Daten häufig als Array gespeichert. Dabei lassen sich Beziehungen
über die Speicherung von Indizes erreichen. Dies zeigt Listing 4.43 für das Beispiel
verheirateter Personen. Um mehrfache Beziehungen herzustellen kann, statt einem
Index, ein Array von Indizes gespeichert werden.

83

5 Typische Pattern in COBOL und Java

5 Typische Pattern in COBOL und Java

5.1 Externe Deklaration von Daten
Sowohl zur Wiederverwendbarkeit als auch zur Erreichung einer gewissen Typsicherheit
ist es in vielen Programmiersprachen möglich, Datenstrukturen extern in einer eigenen
Datei zu deklarieren und an verschiedenen Stellen wieder zu verwenden. Dies ist auch
in COBOL und Java möglich, wenngleich sich die Ansätze stark unterscheiden. In
Java ist diese Deklaration ein entscheidendes Sprachkonzept und so muss – wie bereits
beschrieben – jede Klasse in einer eigenen Datei angelegt werden. In COBOL bietet
dieses Konzept lediglich einen gewissen komfortableren Umgang mit Datendeklarationen,
ist jedoch nicht zwingend notwendig.
In Java werden Klassen in sogenannten Packages organisiert. Um auf Klassen aus einem
anderen Package zuzugreifen, ist ein Importieren der betreffenden Klasse notwendig.
Dies wird wie in Listing 5.1 mithilfe des import-Statements erreicht.

1

package com.firstpackage;

2
3

import com.secondpackage.MySystemPart;

4
5

public interface MySystem {

6

public void doSomething(MySystemPart systemPart);

7
8
9

}

Listing 5.1: Import in Java

Das Interface MySystem nutzt dabei die in Package com.secondpackage enthaltene
Klasse MySystemPart. Bei der Verwendung einer Klasse aus dem selben Package ist kein

84

5 Typische Pattern in COBOL und Java
zusätzliches import-Statement notwendig. Das Importieren geschieht dabei implizit
über das Setzen des Packagenamens wie in Zeile 1 gezeigt.
COBOL bietet zur externen Deklaration von Daten das COPY-Schlüsselwort. Hiermit wird
der Inhalt einer anderen Datei, eines sogenannten COBOL-Copybook, durch den Compiler
an die Stelle des COPY kopiert. Das Verhalten ist stark mit der Präprozessoranweisung
#include in den Programmiersprachen C und C++ zu vergleichen.

1

01

ERROR-MESSAGES.
05 ERR-MSG PIC X(20) OCCURS 3 TIMES INDEXED BY MSG-INDEX.

01

ERROR-MESSAGES-INIT-VALUES.
05 FILLER PIC X(20) VALUE "Error 1 occured".
05 FILLER PIC X(20) VALUE "Error 2 occured".
05 FILLER PIC X(20) VALUE "Error 3 occured".

2
3
4
5
6
7

Listing 5.2: COBOL-Copybook Datei (COPYBOOK.cpy)

1
2
3
4
5
6
7
8
9
10
11
12
13
14

IDENTIFICATION DIVISION.
PROGRAM-ID. COPY-EXAMPLE.
DATA DIVISION.
WORKING-STORAGE SECTION.
COPY COPYBOOK
REPLACING ERR-MSG
BY MSG
"Error 1 occured" BY "First error occured!".
PROCEDURE DIVISION.
MAIN-PROCEDURE.
MOVE ERROR-MESSAGES-INIT-VALUES TO ERROR-MESSAGES.
ACCEPT MSG-INDEX.
DISPLAY MSG(MSG-INDEX).
STOP RUN.
END PROGRAM COPY-EXAMPLE.

Listing 5.3: Nutzung eines COBOL-Copybook

Listing 5.2 zeigt den Inhalt des Copybooks. Hier werden die Datenstrukturen definiert,
die dann an anderer Stelle genutzt werden können. In Listing 5.3 Zeile 5 wird das
COBOL-Copybook in die WORKING-STORAGE SECTION kopiert, sodass die deklarierten
Daten im Programm genutzt werden können.

85

5 Typische Pattern in COBOL und Java
In diesem speziellen Fall wird zusätzlich Gebrauch der Schlüsselwörter REPLACING und
BY gemacht. Dieses kann dazu verwendet werden, um Variablennamen oder Strings im
dem Copybook auszutauschen. Dieser Mechanismus führt zu einer höheren Wiederverwendbarkeit, sollte jedoch mit Bedacht genutzt werden, da eine Analyse des Programms
erschwert wird, weil Variable durch die Namensersetzung im Quelltext schwerer zu
finden sind.
Am Rande wird hier auch die Nutzung eines FILLER gezeigt. Hierbei handelt es sich
um eine Variable, die nicht direkt verwendet werden kann, da sie keinen Namen hat.
Wie im Beispiel sind FILLER oftmals Teile von größeren Strukturen.
Das Einbinden eines Copybooks ist auch innerhalb der PROCEDURE DIVISION möglich
wie Listing 5.4 und Listing 5.5 darstellen. Somit wird es möglich, Logik in Form von
Code, der wiederverwendet wird, auszulagern und an verschiedenen Stellen zu nutzen.
Dies ist allerdings in einigen Unternehmen verpönt, wie Herr Streit anmerkte und daher
eher seltener zu sehen.

1
2
3
4
5
6

EVALUATE VAR
WHEN 1 DISPLAY "First error occured!"
WHEN 2 DISPLAY "Second error occured!"
WHEN 3 DISPLAY "Third error occured!"
WHEN OTHER DISPLAY "Unknown error code!"
END-EVALUATE.

Listing 5.4: COBOL-Copybook Datei (COPYBOOK-EVALUATE.cpy)

1
2
3
4
5
6
7
8
9
10
11

IDENTIFICATION DIVISION.
PROGRAM-ID. COPY-EVALUATE.
DATA DIVISION.
WORKING-STORAGE SECTION.
01 INPUT-NUMBER PIC 9(2).
PROCEDURE DIVISION.
MAIN-PROCEDURE.
ACCEPT INPUT-NUMBER.
COPY COPYBOOK-EVALUATE REPLACING VAR BY INPUT-NUMBER.
STOP RUN.
END PROGRAM COPY-EVALUATE.

Listing 5.5: Nutzung von COPYBOOK-EVALUATE.cpy

86

5 Typische Pattern in COBOL und Java
Herr Lamperstorfer wies darauf hin, dass diese Copybooks jedoch auch problematische
Eigenschaften mit sich bringen, die es zu beachten gilt. So müssen bei Änderungen
daran, alle Programme, die das Copybook einbinden, neu kompiliert werden. Außerdem
werden Dateistrukturen oftmals durch diese repräsentiert, wodurch Änderungen daran,
Anpassungen der in Abschnitt 4.5 erwähnten RECORD-basierten Dateien erfordern, da
sich alle Datenfelder ohne eine Trennung von Zeilenvorschüben verschieben.

In Java ist die Auslagerung von Daten und Logik fester Bestandteil der Sprache. Dieses Konzept spiegelt sich auch in der
Modularisierung – vgl. Abschnitt 3.3 – wieder. COBOL bietet
hierfür das Schlüsselwort COPY. Wenngleich dieses Konzept
Abschnitt 5.1 deutlich weniger mächtig ist als das import-Statement in Java
so ist es doch eine Möglichkeit Daten und Logik zu kapseln und
auszulagern. Wie Herr Streit betonte, werden diese Copybooks in der Praxis zwar
verwendet, könnten aber noch feingranularer und öfter zum Einsatz kommen.

5.2 Komplexe Datenstrukturen
5.2.1 Listen
Während Abschnitt 4.3 Felder behandelt, welche eine feste Größe haben, bietet das
Konzept von Listen deutliche Vorteile, wenn die Anzahl der Elemente variabel, d. h. zum
Zeitpunkt des Erstellens nicht bekannt ist.

Listen in Java

In Java kann das List-Interface implementiert werden bzw. ein Objekt dieser Implementierung instanziiert werden, um eine Liste variabler Größe zu erhalten. Die wohl
gebräuchlichste Implementierung dieses Interfaces stellt die Klasse ArrayList dar. Intern hält diese – wie der Name schon vermuten lässt – ein Array, welches bei Bedarf in
ein neues, größeres Array kopiert wird. Die einfache Handhabung dieser Klasse wird in
Listing 5.6 dargestellt.

87

5 Typische Pattern in COBOL und Java

import
import
import
import

1
2
3
4

java.util.ArrayList;
java.util.Arrays;
java.util.List;
java.util.stream.IntStream;

5

public class ArrayListExample {

6
7

public static void main(String[] args) {
List<Integer> integerList = new ArrayList<>();
printListInformation(integerList);

8
9
10
11

IntStream.range(0, 10)
.forEach(value -> integerList.add(value)) ;
printListInformation(integerList);

12
13
14
15

integerList.remove(5);
printListInformation(integerList);

16
17
18

integerList.add(Integer.MAX_VALUE);
printListInformation(integerList);

19
20

}

21
22

private static void printListInformation(List<Integer> list) {
System.out.println(
"Elements: " + Arrays.toString(list.toArray()) +
" - Size: " + list.size()
);
}

23
24
25
26
27
28

}

29

1

Elements: [] - Size: 0

2

Elements: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] - Size: 10

3

Elements: [0, 1, 2, 3, 4, 6, 7, 8, 9] - Size: 9

4

Elements: [0, 1, 2, 3, 4, 6, 7, 8, 9, 2147483647] - Size: 10

Listing 5.6: ArrayList Beispiel in Java

88

5 Typische Pattern in COBOL und Java
Listen in COBOL

Eine exakte Abbildung von Listen ist in COBOL nicht möglich, da hier bereits zum
Zeitpunkt des Kompilierens feststehen muss, wie groß ein Feld ist.

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39

IDENTIFICATION DIVISION.
PROGRAM-ID. LIST-EXAMPLE.
DATA DIVISION.
WORKING-STORAGE SECTION.
01 LIST PIC 9(3) OCCURS 99 TIMES INDEXED BY L-IDX.
01 D-IDX PIC 9(2).
01 D-IDX-COUNT PIC 9(2).
01 D-IDX-COUNT-TMP PIC 9(2).
01 P-IDX PIC 9(2).
01 I-VAL PIC 9(3).
PROCEDURE DIVISION.
MAIN-PROCEDURE.
PERFORM PRINT-LIST.
MOVE 2 TO I-VAL. PERFORM INSERT-VALUE. PERFORM PRINT-LIST.
MOVE 4 TO I-VAL. PERFORM INSERT-VALUE. PERFORM PRINT-LIST.
MOVE 1 TO D-IDX. PERFORM DELETE-VALUE. PERFORM PRINT-LIST.
STOP RUN.
INSERT-VALUE SECTION.
MOVE I-VAL TO LIST(L-IDX).
IF L-IDX < 99 THEN
COMPUTE L-IDX = L-IDX + 1
END-IF.
DELETE-VALUE SECTION.
IF D-IDX <= 99 THEN
COMPUTE L-IDX = L-IDX - 1
PERFORM VARYING D-IDX-COUNT
FROM D-IDX BY 1
UNTIL D-IDX-COUNT = L-IDX
COMPUTE D-IDX-COUNT-TMP = D-IDX-COUNT + 1
MOVE LIST(D-IDX-COUNT-TMP) TO LIST(D-IDX-COUNT)
END-PERFORM
END-IF.
PRINT-LIST SECTION.
PERFORM VARYING P-IDX FROM 1 BY 1 UNTIL P-IDX = L-IDX
DISPLAY LIST(P-IDX)"," WITH NO ADVANCING
END-PERFORM.
COMPUTE P-IDX = L-IDX - 1.
DISPLAY " SIZE: " P-IDX.
END PROGRAM LIST-EXAMPLE.

89

5 Typische Pattern in COBOL und Java

1

SIZE: 00

2

002, SIZE: 01

3

002,004, SIZE: 02

4

004, SIZE: 01

Listing 5.7: Einfache Listen Implementierung in COBOL

Listing 5.7 zeigt jedoch beispielhaft eine einfache und unvollständige Implementierung
einer Liste in COBOL. Hierbei sind lediglich Einfüge- und Löschoperationen realisiert.
Zu beachten ist, dass aus bereits genannten Gründen auch diese Liste eine maximale
Größe hat, die unter Umständen nicht ausreichend ist. Weitere Funktionalitäten der
Liste müssten analog implementiert werden.

5.2.2 Sets
Neben den in Unterabschnitt 5.2.1 beschriebenen Listen bieten Sets in der Programmierung eine weitere häufig genutzte Datenstruktur. Die zwei wesentlichen Unterschiede
im Gegensatz zu Listen sind zum einen eine fehlende Ordnung der Elemente und zum
anderen die Eigenschaft, dass ein und das selbe Element nur genau einmal innerhalb
eines Sets vorkommen darf. Das Set entspricht somit weitestgehend der mathematischen
Definition einer Menge.

Sets in Java

Wie für Listen bietet Java auch für Sets das Set-Interface. Die wohl am häufigsten
genutzte Implementierung dieses Interfaces stellt die HashSet-Klasse dar, welche die
hashCode-Methode eines Objektes nutzt, um es pseudo-eindeutig identifizierbar zu
machen. Dadurch wird vermieden, dass die gesamte Liste durchlaufen werden muss, um
Duplikate zu finden.
In Listing 5.8 wird gezeigt, dass das Einfügen von Elementen, die bereits im Set enthalten
sind, keine Auswirkung hat. Die Eigenschaft, dass ein Set ungeordnet ist, lässt sich leider
nicht zeigen, da Java die Werte bei der gezeigten Ausgabe ordnet. Dieses Verhalten
tritt auch auf, wenn die Werte in umgekehrter Reihenfolge dem Set hinzugefügt werden,

90

5 Typische Pattern in COBOL und Java
was jedoch in keinem Fall bedeutet, dass es sich beim Set um eine stets sortierte Liste
handelt, auch wenn es den Eindruck vermittelt.

import java.util.HashSet;
import java.util.Set;
import java.util.stream.IntStream;

1
2
3
4

public class HashSetExample {

5
6

public static void main(String[] args) {
Set<Integer> integerSet = new HashSet<>();

7
8
9

IntStream.range(0, 10).forEach(number -> integerSet.add(number));
integerSet.forEach(number -> System.out.print(number + " "));

10
11
12

System.out.println();

13
14

IntStream.range(5, 15).forEach(number -> integerSet.add(number));
integerSet.forEach(number -> System.out.print(number + " "));

15
16

}

17

}

18

1

0 1 2 3 4 5 6 7 8 9

2

0 1 2 3 4 5 6 7 8 9 10 11 12 13 14

Listing 5.8: HashSet Beispiel in Java

Sets in COBOL

Analog zu Listen kann festgehalten werden, dass eine Implementierung von Sets in
COBOL nicht ohne weiteres möglich ist. Die Einschränkung der Größe der Datenstruktur
bestünde auch hier.

91

5 Typische Pattern in COBOL und Java

1
2

IDENTIFICATION DIVISION.
PROGRAM-ID. SET-EXAMPLE.

3
4
5
6
7
8
9
10

DATA DIVISION.
WORKING-STORAGE SECTION.
01 SET-STORAGE PIC 9(3) OCCURS 100 TIMES INDEXED BY S-IDX.
01 SET-NIL-VALUE PIC 9(3) VALUE 0.
01 SET-SIZE PIC 9(3) VALUE 000.
01 I-VAL PIC 9(3).
01 D-VAL PIC 9(3).

11
12
13
14
15
16
17
18
19
20

PROCEDURE DIVISION.
MAIN-PROCEDURE.
PERFORM INIT-SET.
PERFORM PRINT-SET.
MOVE 2 TO I-VAL. PERFORM
MOVE 4 TO I-VAL. PERFORM
MOVE 2 TO I-VAL. PERFORM
MOVE 4 TO D-VAL. PERFORM
STOP RUN.

INSERT-VALUE.
INSERT-VALUE.
INSERT-VALUE.
DELETE-VALUE.

PERFORM
PERFORM
PERFORM
PERFORM

PRINT-SET.
PRINT-SET.
PRINT-SET.
PRINT-SET.

21
22
23
24
25

INIT-SET SECTION.
PERFORM VARYING S-IDX FROM 1 BY 1 UNTIL S-IDX = 100
MOVE SET-NIL-VALUE TO SET-STORAGE(S-IDX)
END-PERFORM.

26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45

INSERT-VALUE SECTION.
SEARCH-EQUAL-VALUE.
PERFORM VARYING S-IDX FROM 1 BY 1
UNTIL S-IDX = 100 OR I-VAL = SET-NIL-VALUE
IF SET-STORAGE(S-IDX) = I-VAL THEN
SET I-VAL TO SET-NIL-VALUE
END-IF
END-PERFORM.
INSERT-IF-NOT-ALREADY-PRESENT.
PERFORM VARYING S-IDX FROM 1 BY 1
UNTIL S-IDX = 100 OR I-VAL = SET-NIL-VALUE
IF SET-STORAGE(S-IDX) = SET-NIL-VALUE THEN
MOVE I-VAL TO SET-STORAGE(S-IDX)
SET I-VAL TO SET-NIL-VALUE
COMPUTE SET-SIZE = SET-SIZE + 1
END-IF
END-PERFORM.
INSERT-VALUE-EXIT.
EXIT.

92

5 Typische Pattern in COBOL und Java

46

DELETE-VALUE SECTION.
PERFORM VARYING S-IDX FROM 1 BY 1
UNTIL S-IDX = 100 OR D-VAL = SET-NIL-VALUE
IF SET-STORAGE(S-IDX) = D-VAL THEN
SET SET-STORAGE(S-IDX) TO SET-NIL-VALUE
SET D-VAL TO SET-NIL-VALUE
COMPUTE SET-SIZE = SET-SIZE - 1
END-IF
END-PERFORM.

47
48
49
50
51
52
53
54
55
56

PRINT-SET SECTION.
PERFORM VARYING S-IDX FROM 1 BY 1 UNTIL S-IDX = 100
IF NOT SET-STORAGE(S-IDX) = SET-NIL-VALUE THEN
DISPLAY SET-STORAGE(S-IDX)"," WITH NO ADVANCING
END-IF
END-PERFORM.
DISPLAY "SIZE: " SET-SIZE.

57
58
59
60
61
62
63
64

END PROGRAM SET-EXAMPLE.

65

1

SIZE: 000

2

002,SIZE: 001

3

002,004,SIZE: 002

4

002,004,SIZE: 002

5

002,SIZE: 001

Listing 5.9: Einfache Set Implementierung in COBOL

Listing 5.9 greift jedoch die Kernaspekte von Sets auf und zeigt eine mögliche Implementierung in COBOL. Wie auch in Listing 5.9 sind nur Einfüge- und Löschoperationen
realisiert.
Wenngleich diese Implementierung beispielhaft zeigt, dass die Grundidee eines Sets
auch in COBOL abbildbar ist, so hat sie gegenüber Java doch einige Nachteile. Zum
einen ist sie ineffizient, da – anders als z. B. bei HashSets – stets alle Werte der Liste
durchlaufen werden müssen, um Redundanz zu vermeiden. Zum anderen liegt die große
Stärke von Datenstrukturen in Java in der Generizität (siehe Abschnitt 4.6). Diese kann

93

5 Typische Pattern in COBOL und Java
in COBOL nicht erreicht werden, wodurch ein Set stets neu für die zugrundeliegenden
Datentypen implementiert werden muss.

5.2.3 Maps
Maps erlauben die Speicherung von Schlüssel-Werte-Paaren. Dadurch wird jeder Wert
in der Datenstruktur eindeutig unter einem Schlüssel abgelegt. Dies erlaubt schnellen
Zugriff auf bestimmte Elemente und wird oft durch eine sogenannte HashMap realisiert, wobei auch andere Implementierungen wie Bäume denkbar sind. Bei diesen
HashMaps wird der Schlüssel gehasht, d. h. durch eine bestimmte Funktion in einen
pseudo-eindeutigen Wert umgerechnet, der die Speicherstelle angibt und so schnellen
Zugriff auf ein Element erlaubt. Dies eignet sich vor allem, wenn viele Elemente in der
Datenstruktur gespeichert werden und konstante Zugriffszeit – O(1) – auf Elemente notwendig ist. Diese Zugriffszeit hängt jedoch von der zugrundeliegenden Implementierung
ab.
In Java steht dafür das Interface Map und Implementierungen wie HashMap bereit. Damit
werden generische Objekte anhand ihrer hashCode-Funktion in einer Map verwaltet.
COBOL bietet keine Konstrukte, um eine Map abzubilden. Wie die Experten Bonev und
Streit angaben, wurden in der Praxis allerdings Möglichkeiten entwickelt, eine solche
Datenstruktur in COBOL abzubilden, indem z. B. eine eigene Hash-Funktion für den
genauen Anwendungsfall implementiert wird, die die Eingabewerte eindeutig auf Indizes
eines Arrays fester Größe abbildet. Eine weitere bereits beobachtete Variante ist das
Nutzen von zwei Listen, wobei eine nach einem bestimmten Attribut der enthaltenen
Daten sortiert wird und den Index des eigentlichen Objektes in der zweiten Liste
beinhaltet, wodurch sich durch effiziente Indexsuche eine Map abbilden lässt.

5.2.4 Verbunddatenstrukturen
Structs und Unions sind weitere in der Programmierung verbreitete Datenstrukturen.
Beide Typen bilden sogenannte Verbunddatenstrukturen, d. h. sie bieten eine Art
Kapselung von mehreren Variablen, welche unterschiedlichen Typs sein können. Structs
bezeichnen dabei einen Speicherbereich, der aus mehreren Variablen besteht, die so
gruppiert gespeichert werden. Unions hingegen bezeichnen einen Speicherbereich, der

94

5 Typische Pattern in COBOL und Java
auf verschiedene Weisen – in unterschiedlichen Datentypen – interpretiert werden kann.
Sie gruppieren mehrere Variablen, von denen stets nur eine Gültigkeit aufweisen kann.

Structs und Unions in COBOL

Das fundamentale Konzept von Variablendeklarationen in COBOL ist – wie bereits in
Abschnitt 4.2 angesprochen – die Nutzung von Stufennummern, was eine Untergliederung
mithilfe höherer Nummern erlaubt. Das sorgt dafür, dass jede untergliederte Variable
in COBOL eine Verbunddatenstruktur darstellt.

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15

1
2
3
4
5
6
7
8
9
10

IDENTIFICATION DIVISION.
PROGRAM-ID. UNION-PROGRAM.
DATA DIVISION.
WORKING-STORAGE SECTION.
01 NUMBER-GROUP.
05 FIRST-NUMBER PIC 9(4) VALUE 1907.
05 SECOND-NUMBER PIC 9(2) VALUE 42.
01 NEW-NUMBER REDEFINES NUMBER-GROUP PIC 9(4)V9(2).
PROCEDURE DIVISION.
MAIN-PROCEDURE.
DISPLAY "INTEGER: " NUMBER-GROUP.
DISPLAY "DECIMAL: " NEW-NUMBER.
CALL "UNION-SUB-PROGRAM" USING NUMBER-GROUP.
STOP RUN.
END PROGRAM UNION-PROGRAM.

IDENTIFICATION DIVISION.
PROGRAM-ID. UNION-SUB-PROGRAM.
DATA DIVISION.
LINKAGE SECTION.
01 PASSED-VALUE PIC 9(3)V9(3).
PROCEDURE DIVISION USING PASSED-VALUE.
MAIN-PROCEDURE.
DISPLAY "UNION-SUB-PROGRAM: " PASSED-VALUE.
GOBACK.
END PROGRAM UNION-SUB-PROGRAM.

95

5 Typische Pattern in COBOL und Java

1

$ ./UNION-PROGRAM

2

INTEGER: 190742

3

DECIMAL: 1907.42

4

UNION-SUB-PROGRAM: 190.742

Listing 5.10: Structs und Unions in COBOL

Listing 5.10 zeigt sowohl die Verwendung als Struktur-Typ, als auch den Zugriff als
Union-Typ in einem Unterprogramm und mithilfe der in Abschnitt 4.2 beschriebenen
REDEFINES Anweisung. Wie bereits in dieser Arbeit gezeigt, wird – in diesem Falle zur
Ausgabe – auf eine gesamte Datenstruktur zugegriffen, die mehrere unterschiedliche Variablen enthält. Diese Datenstruktur stellt ein Struct dar. Im gezeigten Unterprogramm
hingegen wird der selbe Speicherbereich anders interpretiert.
Dies wird laut Herrn Streit in der Praxis auch oft ausgenutzt, um Erweiterungen von Programmen zu realisieren. Da Unterprogramme lediglich einen Zeiger auf Datenstrukturen
übergeben bekommen, können diese Strukturen erweitert werden, ohne das Unterprogramm zu ändern, solange neue Datenfeldern an das Ende angehängt werden. Weitere
Unterprogramme, welche an neue Datenfelder angepasst wurden, können wiederum
die Daten, die hinten angehängt wurden, nutzen. Das Einfügen von Feldern zwischen
bestehenden, hat unweigerlich die Anpassung aller Komponenten zur Folge.

Structs und Unions in Java

In Java gehen Verbunddatenstrukturen in Klassen und Aufzählungstypen (javenum) auf.
Klassen stellen weiterentwickelte Formen von Structs dar, die, wie Listing 5.11 zeigt,
unterschiedliche Attribute kapseln. Diese Klassen werden auch Java Beans genannt.

1
2
3
4
5

public class Bean{
public int age;
public String firstName;
public String surname;
}

Listing 5.11: Struct in Java (JavaBean)

96

5 Typische Pattern in COBOL und Java
Unions dagegen lassen sich durch verschiedene getter-Methoden abbilden. Dabei bietet
eine Klasse mehere Methoden, die sich auf das selbe Feld zurückführen lassen, aber
dieses – wie Listing 5.12 zeigt – in verschiedenen Datentypen zurückliefern oder Felder
verbinden.

1

public class Union {

2

private int heightInCm;
private String firstName;
private String surname;

3
4
5
6

public int getHeightInCentimeter() {
return heightInCm;
}

7
8
9
10

public float getHeightInMeter() {
return heightInCm / 100f;
}

11
12
13
14

public String getFullName() {
return firstName + " " + surname;
}

15
16
17
18

}

Listing 5.12: Union in Java

97

5 Typische Pattern in COBOL und Java

Die vorgestellten Datenstrukturen bieten eine Möglichkeit, je
nach Anwendungsfall, Daten effizient und dynamisch zu speichern und bereitzustellen. Während Java Listen, Sets und
Maps bereits im Sprachstandard unterstützt, müssen diese
Abschnitt 5.2 von Entwicklern in COBOL selbst implementiert werden, was
selbstverständlich Wissen über die Algorithmen voraussetzt.
Herr Streit betonte, dass etwaige Datenstrukturen manchmal in bestehenden
COBOL-Programmen zu finden sind, jedoch – durch das Fehlen des entsprechenden Vokabulars in der Entstehungszeit – oft andere Namen tragen und daher
als solche nicht leicht zu erkennen sind. COBOL bietet dagegen Verbunddatenstrukturen, die vielfältig genutzt, aber auch ausgenutzt werden können, als
fundamentalen Teil des Variablenkonzepts. Bei der Nutzung ist darauf zu achten,
dass Werte entweder synchronisiert oder zumindest nicht durch die Nutzung an
verschiedenen Stellen korrumpiert werden. Herr Lamperstorfer wies außerdem
darauf hin, dass im Gegensatz zu Java, wo Algorithmen für Standardprobleme wie beispielsweise das Sortieren einer Liste, durch das JDK bereitgestellt
werden, COBOL wenig Mittel liefert. Daher werden häufig Programme des
Betriebssystems aufgerufen, um diese Aufgaben zu erfüllen.

5.3 Entwurfsmuster
Vor allem in objektorientierter Programmierung sind Entwurfsmuster – engl. design
patterns – von hoher Bedeutung. Dabei handelt es sich um Muster, die sich häufig in
der Planung und Umsetzung von Software bewährt haben und so als wiederverwendbare
Vorgehensweise bei bestimmten Problemstellungen angewendet werden können. Dieses
Kapitel erläutert die gebräuchlichsten Entwurfsmuster in Java. Für einen umfassenden
Überblick kann auf Design Patterns [11] von Gamma u. a. verwiesen werde, welches
wohl als Grundlagenwerk auf diesem Gebiet bezeichnet werden kann.

5.3.1 Callback-Muster
In der Programmierung ist es häufig nötig, dass bestimmte Ereignisse andere Aktionen
auslösen. Dies ist insbesondere in Programmen sinnvoll, die parallele Verarbeitungs-

98

5 Typische Pattern in COBOL und Java
schritte beinhalten. Um auf diese Ereignisse zu reagieren gibt es im Allgemeinen zwei
Möglichkeiten:
• (Busy-)Polling – Unter Polling versteht man das zyklische Abfragen eines Wertes
oder eines Zustandes, durch einen Teil, der von diesem Wert abhängt.
• Callbacks – Callbacks sind Funktionen, die in einer bestimmten Art und Weise
anderen Programmabschnitten zur Verfügung gestellt werden und bei Bedarf
aufgerufen werden können, um z. B. über Zustandsänderungen zu benachrichtigen.
Im Gegensatz zum Polling, bei dem permanent Rechenzeit dafür aufgewendet werden
muss, aktiv eine Zustandsänderung zu überwachen, wird in der Praxis häufig das
Entwurfsmuster der Callbacks verwendet. Damit wird erreicht, dass ein Teilprogramm
nicht wie beschrieben aktiv Änderungen beobachten muss, sondern sich von einem
anderen Programmabschnitt über Zustände benachrichtigen lassen kann.
Obwohl das klassische Callback-Muster aufgrund von fehlenden funktionalen Elementen
in Java nicht direkt implementierbar ist, finden sich oft sehr ähnliche Abbildungen
davon. Die standardisierten Schnittstellen Observer und Observable bieten dabei eine
generische Möglichkeit zur Änderungsbenachrichtigung. Häufiger lassen sich jedoch
sogenannte Listener beobachten, welche das Callback-Muster abbilden. Hierbei werden
eigene Interfaces definiert, was zwar die Generizität verringert, jedoch zu breiterem
Funktionsumfang und leichter verständlichem Code führt.
Das Listing 5.13 zeigt die Handhabung des Observer-Pattern [11] in Java mithilfe
der Observer und Observable-Interfaces. Wie gezeigt, kann die Implementierung des
Observer-Interfaces auch in einer anonymen Klasse geschehen. Diese sprachlichen
Konstrukte wurden bereits in Abschnitt 4.1 beschrieben.

1
2
3
4
5
6

import
import
import
import
import
import

java.time.Instant;
java.util.Observable;
java.util.Observer;
java.util.concurrent.Executors;
java.util.concurrent.ScheduledExecutorService;
java.util.concurrent.TimeUnit;

7
8
9
10

public class ObserverPattern {
public static void main(String[] args) {
TimeObservable timeObservable = new TimeObservable();

99

5 Typische Pattern in COBOL und Java

Observer plainObserver = ((o, arg) ->
,→
System.out.println("PlainTime: " + arg));
timeObservable.addObserver(plainObserver);
timeObservable.addObserver(new FormattedObserver());
timeObservable.startObservable();

11

12
13
14

}

15
16

static class FormattedObserver implements Observer {
public void update(Observable o, Object arg) {
System.out.println("FormattedTime: " +
,→
Instant.ofEpochMilli((long) arg).toString());
}
}

17
18
19

20
21
22

static class TimeObservable extends Observable {
private ScheduledExecutorService executor =
,→
Executors.newScheduledThreadPool(3);

23
24

25

public void startObservable() {
for (int delay : new int[] { 1, 3, 5 }) {
executor.schedule(() -> {
setChanged();
notifyObservers(System.currentTimeMillis());
}, delay, TimeUnit.SECONDS);
}
}

26
27
28
29
30
31
32
33

}

34
35

}

Listing 5.13: Observer und Observable in Java

Die sehr viel gebräuchlichere Variante ist es jedoch, Listener zu verwenden. Dabei
handelt es sich streng genommen um nichts anderes, als eine eigene Definition des
Observer-Interfaces. Jedoch wird durch die klare Definition der Funktionalität deutlich
spezifischerer Code geschrieben, der vor allem in puncto Typsicherheit und Lesbarkeit
einige Vorteile gegenüber des Java-eigenen Interfaces bietet.

100

5 Typische Pattern in COBOL und Java

1
2
3
4
5
6

import
import
import
import
import
import

java.time.Instant;
java.util.ArrayList;
java.util.List;
java.util.concurrent.Executors;
java.util.concurrent.ScheduledExecutorService;
java.util.concurrent.TimeUnit;

7
8

public class ListenerPattern {

9
10
11
12
13
14
15
16
17
18
19
20
21

public static void main(String[] args) {
TimeProducer timeProducer = new TimeProducer();
TimeListener plainListener = new TimeListener() {
public void printTime(long timeMillis) {
System.out.println("PlainTime: " + timeMillis);
}
};
FormattedListener formattedListener = new FormattedListener();
timeProducer.registerListener(plainListener);
timeProducer.registerListener(formattedListener);
timeProducer.start();
}

22
23
24
25

interface TimeListener {
void printTime(long timeMillis);
}

26
27
28
29
30
31
32

static class FormattedListener implements TimeListener {
public void printTime(long timeMillis) {
System.out.println("FormattedTime: " +
Instant.ofEpochMilli(timeMillis).toString());
}
}

33
34

static class TimeProducer {

35
36

37

private ScheduledExecutorService executor =
,→
Executors.newScheduledThreadPool(3);
private List<TimeListener> timeListeners = new ArrayList<>();

38
39
40
41

void registerListener(TimeListener timeListener) {
timeListeners.add(timeListener);
}

42
43
44

void notifyListeners(long value) {
timeListeners.forEach(listener -> listener.printTime(value));

101

5 Typische Pattern in COBOL und Java

}

45
46

void start() {
for (int delay : new int[] { 1, 3, 5 }) {
executor.schedule(
() -> notifyListeners(System.currentTimeMillis()),
delay, TimeUnit.SECONDS);
}
}

47
48
49
50
51
52
53

}

54

}

55

Listing 5.14: Listener in Java

Die Aufgabe beider Beispiele ist die gleiche. Jedoch verdeutlicht Listing 5.14 die
Typsicherheit eigener Interfaces und kennzeichnet, wie diese erreicht wird. Listing 5.15
wäre eine beispielhafte Ausgabe beider Programme.

1

FormattedTime: 2018-04-16T12:32:44.482Z

2

PlainTime: 1523881964482

3

FormattedTime: 2018-04-16T12:32:46.481Z

4

PlainTime: 1523881966481

5

FormattedTime: 2018-04-16T12:32:48.481Z

6

PlainTime: 1523881968481

Listing 5.15: Ausgabe der Callback-Beispiele in Java

In COBOL können Callbacks nur rudimentär abgebildet werden, helfen jedoch auch hier,
Code klarer zu strukturieren. So kann beispielsweise für jedes Element einer Liste, ein
Unterprogramm als Callback aufgerufen werden oder durch die in Unterabschnitt 4.8.2
gezeigten Mehrfachverzweigungen Code abhängig von Bedingungen ausgeführt und so
unterschiedliches Verhalten erreicht werden. Vor allem in Verbindung mit Flags (siehe
Unterabschnitt 4.8.1) kann die Ausführung von einzelnen Codeteilen erreicht werden,
die dem Callback-Muster ähnlich ist. Diese Callback-Strategien lassen sich laut Herrn
Streit auch in realen Systemen beobachten.

102

5 Typische Pattern in COBOL und Java

5.3.2 Singleton-Muster
»Alles ist ein Objekt.« [25] Diese Aussage findet sich in unzähliger Hochschullektüre
und Fachbüchern. Genauer wäre – mit Blick auf statische Elemente – zwar die Aussage,
dass alles Teil einer Klasse sei, jedoch ist für die Idee dahinter beides richtig. Gemeint
ist damit, dass es keine Funktionalität oder Eigenschaft gibt, die nicht Teil einer Klasse
bzw. eines Objektes ist.

1

public class Pope {

2

private static Pope instance = null;

3
4

private Pope() {}

5
6

public static Pope getInstance() {
if (instance == null) {
instance = new Pope();
}
return instance;
}

7
8
9
10
11
12
13

public static void die() {
instance = null;
}

14
15
16
17

}

Listing 5.16: Singleton in Java

Manchmal wird eine Klasse zwar durch ein Objekt repräsentiert, allerdings existiert
nur genau eine Instanz davon. Im realen Leben könnte man z. B. den Papst als genau
einmalig vorkommende Instanz nehmen. Diese spezielle Person gibt es stets nur einmal
und so muss bei der Modellierung beachtet werden, dass es zu jedem Zeitpunkt nur
eine Instanz der Klasse gibt.
Listing 5.16 modelliert das Beispiel des Papstes in Java. Um die angesprochenen Eigenschaften einer Sigleton-Klasse zu realisieren, werden verschiedene Mechanismen verwendet. Zum einen enthält die Klasse einen privaten Konstruktor, um eine Instanziierung
mittels new-Operator zu verhindern bzw. nur innerhalb der eigenen Klasse zuzulassen.
Außerdem speichert und liefert die Klasse mit der statischen getInstance()-Methode
die aktuell gültige Instanz und legt ggf. eine neue an. Die die()-Funktion wurde

103

5 Typische Pattern in COBOL und Java
beispielhaft für das Ableben eines Papstes implementiert, sodass in der getInstance()Methode eine neue Instanz erzeugt würde.
In der Praxis stellen zum Beispiel eine Datenbank-, Konfigurations- oder Hardwareschnittstellen oftmals ein Singleton-Objekt dar. Im Gegensatz zu statischen Klassen
und Funktionen bieten Singletons einige Vorteile:
• Eine Singleton-Klasse kann Interfaces implementieren und von anderen Klassen
erben.
• Singleton-Klassen können instanziiert werden, sobald sie gebraucht werden. Statische Klassen werden beim Starten des Programms initialisiert.
• Klassen können von Singleton-Klassen erben und erhalten damit die MemberVariablen und -Funktionen.
Allerdings gibt es auch Anwendungsfälle, in denen eine Klasse mit statischen Variablen
und Funktionen genutzt werden sollte. Als Faustregel dafür gilt zum einen, dass die
Klasse keinen Zustand repräsentiert und zum anderen lediglich eine Sammlung von
Variablen und Funktionen gleicher Domäne, wie z. B. mathematische Operationen,
bereitstellt.
In COBOL ist das Singleton-Muster irrelevant, da es sich dabei um ein rein objektorientiertes Konzept handelt und diese COBOL-Erweiterungen kein Teil der vorliegenden
Arbeit sind.

5.3.3 Dependency Injection
In einer objektorientierten Programmierumgebung werden Funktionalitäten in Klassen
gekapselt und so die Wiederverwendbarkeit erhöht. Dies wurde bereits in Abschnitt 3.3
dargestellt. Um damit komplexere Probleme zu lösen und Abhängigkeiten herzustellen,
werden Klassen oftmals komponiert bzw. aggregiert. Dabei gibt es zwei Möglichkeiten
wie eine Aggregation aussehen kann:
• Erzeugung aller nötigen Objekt-Instanzen innerhalb der Klasse, die diese benötigt.

104

5 Typische Pattern in COBOL und Java
• Erzeugung der nötigen Objekt-Instanzen an zentraler Stelle und Injizieren in
Objekte, welche diese benötigen (Dependency Injection).
Die erste der angesprochenen Vorgehensweise verletzt allerdings – je nach Ausnutzen
und Implementierung – mehr oder weniger die Eigenschaft, dass eine Klasse für genau
eine Aufgabe zuständig ist. Außerdem werden so implizit Abhängigkeiten zwischen
Komponenten hergestellt, die schwer zu durchschauen sind.

1
2
3
4
5
6

public class DependencyInjection {
public static void main(String... args) {
Injectable inj = () -> 42;
InjectionTarget injTarget = new InjectionTarget(inj);
injTarget.printNumber();
}

7

interface Injectable {
int getNumber();
}

8
9
10
11

static class InjectionTarget {
private final Injectable injectable;

12
13
14

public InjectionTarget(Injectable injectable) {
this.injectable = injectable;
}

15
16
17
18

public void printNumber() {
System.out.println(injectable.getNumber());
}

19
20
21

}

22
23

}

Listing 5.17: Dependency Injection in Java

Dependency Injection sorgt dafür, dass Abhängigkeiten explizit hergestellt werden.
Martin beschreibt in seinem Buch Clean Code [16] dieses Muster auch als »Inversion of
Control«, da dabei die Kontrolle über die Instanziierung verlagert – quasi invertiert –
wird. So entsteht eine losere Kopplung, durch die Abhängigkeiten auch zur Laufzeit
geändert und gesteuert werden können. Ein weiterer Vorteil zeigt sich beim Testen von
Systemen. So lassen sich für Komponenten, welche Abhängigkeiten von Außen bekommen

105

5 Typische Pattern in COBOL und Java
leichter Unit-Tests schreiben, da darunterliegende Strukturen extern gesteuert werden
können.
Listing 5.17 beinhaltet eine einfache Dependency Injection. Der Code macht gleichzeitig
Gebrauch von Interfaces, was einen Teil der Flexibilität der Dependency Injection
verdeutlicht. Neben der gezeigten Möglichkeit der Übergabe an den Konstruktor einer
Klasse, erwähnt Martin [16] auch die Varianten diese Abhängigkeiten über SetterMethoden oder Interfaces herzustellen.
Da Variablen, wie Abschnitt 4.2 beschreibt, in COBOL immer dem ganzen Programm
zugänglich sind, ist die Dependency Injection hier nicht relevant.

5.4 Redundanz durch Wertekopien
Abschnitt 4.2 beschreibt Variablendeklarationen und -definitionen in Java und COBOL.
Wie bereits geschildert, sind Datentyp und Repräsentation in COBOL eng miteinander
verwoben. Das sorgt in der Praxis häufig für redundanten Code, da nur zu Darstellungszwecken häufig Werte kopiert werden müssen. Dies hat nicht nur Auswirkungen auf die
Lesbarkeit des Codes, sondern auch auf die Performanz.
Laut Herrn Bonev ist beobachtbar, dass der dafür nötige MOVE-Befehl große Teile von
COBOL-Code ausmacht, da häufig etliche Variablen für den selben Wert existieren und
der Inhalt synchron gehalten werden muss, weil COBOL innerhalb eines Programms
keine Referenzen auf Variablen oder Objekte bietet. Auch beim Aufrufen von Unterprogrammen, wie in Unterabschnitt 4.4.2 beschrieben, wird dies, den Experten nach,
häufig genutzt, um eine gewisse Sicherheit zu haben, dass Daten an anderer Stelle nicht
verändert werden oder, um Daten in Strukturen zu packen, die vom aufgerufenen Programm verstanden werden. Dazu werden Daten vor einem Aufruf in Variablen kopiert,
das entsprechende Programm aufgerufen und die Ergebnisse anschließend wieder in die
ursprünglichen Strukturen kopiert.
Eine Möglichkeit, welche laut Herrn Streit in Betracht gezogen werden kann, ist es,
verschiedene Variablen als Union-Verbunddatenstruktur, wie in Unterabschnitt 5.2.4
beschrieben, mithilfe des REDEFINES-Schlüsselworts anzulegen und so MOVE-Befehle
einzusparen. Diese Lösung bringt auch Sicherheit im Bezug auf Synchronisation, da das
Kopieren nicht versehentlich vergessen werden kann. Häufig wird dies jedoch nicht eingesetzt, da sich Seiteneffekte und Fehler ergeben können, wenn Daten an unterschiedlichen

106

5 Typische Pattern in COBOL und Java
Stellen modifiziert werden. Dabei sollte, wie in Abschnitt 4.7 beschrieben, auf klare
Affixe geachtet werden, was in der Folge dazu führt, dass mehr MOVE-Befehle verwendet
werden müssen, die nur schlecht vermeidbar sind. Während diese MOVE-Befehle zur
Übersichtlichkeit beitragen und daher in Kauf genommen werden können, sollten andere
genau untersucht und wenn möglich entfernt werden.
Eine weitere Strategie, MOVE-Befehle einzusparen, ist die Nutzung des CALL USING
Befehls wie in Unterabschnitt 4.4.2. Laut Herrn Streit ist tendenziell selten zu beobachten, dass Entwickler an dieser Stelle die Variablen übergeben, die das Programm
wirklich benötigt. Stattdessen werden wie in Abschnitt 5.1 gezeigt Copybooks angelegt,
die an mehreren Stellen zum Einsatz kommen, um eine Struktursicherheit zu haben,
und nur diese einem Unterprogramm übergeben. Das macht das Kopieren von und
in ursprüngliche Strukturen notwendig. Hierbei wäre es allerdings möglich, vorhandene Strukturen per Variablennamen zu übergeben, solange der Aufbau dem in den
aufgerufenen Unterprogrammen entspricht.
Seltener lässt sich die Nutzung von MOVE CORRESPONDING beobachten. Dabei werden
alle untergruppierten Variablen einer gegliederten Datenstruktur in eine andere Datenstruktur kopiert, die eine exakte namentliche Entsprechung in der Zielstruktur haben.
Dies sei, den Experten nach, jedoch nicht weit verbreitet und sollte vermieden werden,
da Programmlogik und -semantik abhängig von Variablennamen gemacht wird.

107

6 COBOL bleibt von Bedeutung

6 COBOL bleibt von Bedeutung

6.1 Fazit
Zusammenfassend kann festgehalten werden, dass sich die Sprachen COBOL und Java
auf den ersten Blick stärker unterscheiden, als dies in Wahrheit der Fall ist. Viele
bekannte Konzepte lassen sich wiederfinden und Parallelen zwischen unterschiedlich
wirkenden Konstrukten ziehen.
Nichtsdestotrotz ist auch klar erkennbar, dass COBOL so manches vermissen lässt,
was von neueren Sprachen wie Java zur Verfügung gestellt wird und an einigen Stellen
andere Ansätze verfolgt. Dies gilt auch für die Werkzeuge und Umgebungen für die
jeweiligen Sprachen. Dadurch wird die Analyse von Fehlern und das Erweitern solcher
Systeme i. d. R. komplexer als bei Systemen, die auf neuen Technologien basieren. Eine
konsequente Einhaltung einiger Richtlinien sorgt jedoch dafür, dass COBOL leichter
les- und wartbar wird.
Selbst für erfahrene Entwickler können daher erste Kontakte mit COBOL-Systemen
befremdlich wirken. Doch mit Wissen über häufig beobachtbare Muster, ungewohnte
Stolpersteine und nicht direkt erkennbare Analogien zwischen COBOL-Konzepten und
denen bekannter Sprachen, ist die Einarbeitung problemlos möglich.

6.2 Ausblick
Durch den Wandel der letzten Jahre bzw. Jahrzehnte in komplexen Softwaresystemen
wird es immer schwerer, reine COBOL-Systeme zu nutzen und sinnvoll in eine heterogene IT-Landschaft einzubetten. Kunden sind von Applikationen für verschiedenste
Systeme und Plattformen abhängig und müssen sich darauf verlassen können, dass die
Erweiterung um neue Back- und Frontends ohne Einfluss auf bestehende Komponenten

108

6 COBOL bleibt von Bedeutung
vonstattengehen kann. Auch ist es nötig, die Basis für interne Systemergänzungen
zu schaffen, indem festgelegte Interfaces bedient, verwendet und angeboten werden.
Während diese Anforderungen mit modernen Sprachen wie Java mühelos erreicht werden
können, bieten Altsysteme nur spärliche Möglichkeiten in dieser Richtung.
Aber auch finanzielle Aspekte sorgen über kurz oder lang dafür, dass Unternehmen
Altsysteme migrieren und Geschäftslogik zunehmend in neuen Technologien abbilden.
Dieser Wandel ist jedoch auch dafür verantwortlich, dass in Zukunft weiterhin Entwickler
mit COBOL-Know-how gefragt sein werden, um schlecht dokumentierte Altsysteme
mit all ihren Zusammenhängen zu verstehen und in neuen Code zu überführen.

Verknüpfung von COBOL und Java
Abschließend bleibt zu sagen, dass auch der gleichzeitige Betrieb von COBOL und Java
in der Praxis möglich ist. Das verspricht kleinere Einheiten von Programmcode, die
migriert und in Java neu implementiert oder weiterverwendet werden können.

1
2
3
4
5
6

01

W-DATE-FORM.
05 W-JJ
05 FILLER
05 W-MM
05 FILLER
05 W-AA

PIC
PIC
PIC
PIC
PIC

XX.
X
XX.
X
XX.

VALUE '.'.
VALUE '.'.

Listing 6.1: Ursprünglicher COBOL-Code

1
2
3
4
5
6

Var w_Date_Form = declare.level(1).var() ;
Var w_Jj = declare.level(5).picX(2).var() ;
Var filler$1 = declare.level(5).picX(1).value(".").filler() ;
Var w_Mm = declare.level(5).picX(2).var() ;
Var filler$2 = declare.level(5).picX(1).value(".").filler() ;
Var w_Aa = declare.level(5).picX(2).var() ;

Listing 6.2: Generierter Java-Code

109

6 COBOL bleibt von Bedeutung
Herr Lamperstorfer wies darauf hin, dass es dazu die Möglichkeit gibt, COBOL-Code
innerhalb der JVM laufen zu lassen. Man spricht auch von Rehosting. Dazu wird ein
spezieller Compiler benötigt, der den COBOL- in Byte-Code der JVM übersetzt. Damit
wird es möglich, COBOL-Module direkt aus Java-Code heraus zu nutzen. Außerdem
existieren Werkzeuge, die COBOL-Code in Java-Code übersetzen, sodass dieser anschließend – im Gegensatz zu generiertem Byte-Code – weiter bearbeitet werden kann.
Listing 6.19 und Listing 6.29 zeigen allerdings, dass der generierte Java-Code in diesem
Fall nicht zur weiteren Verwendung zu gebrauchen ist.
Mit dem Java Native Interface, kurz JNI genannt, ergibt sich eine weitere Möglichkeit
COBOL und Java zu verknüpfen. Dabei handelt es sich um eine Schnittstelle, die
es Java-Programmen ermöglicht kompilierte Bibliotheken zu laden und Programme
aufzurufen, womit kompilierter COBOL-Code ausgeführt werden kann.
Auf »feingranularer Ebene« funktionieren diese Verbindungen, laut Herr Streit, nicht
sehr gut, da »die Aufrufe schlecht lesbar sind«, »mehr Boilerplate Code nötig ist als bei
einem Aufruf innerhalb der Sprache« und die Performanz weniger gut sei. Allerdings
eigne sich eine solche Technologie gut, um große Einheiten in verschiedenen Sprachen
zu verknüpfen. So lasse sich mit »klar definiert[en] und schmal[en]« Schnittstellen eine
gute Basis zur »schrittweisen Migration« schaffen.

9

Dieser Code ist Teil einer Beispieldatei (Zeile 51-56) des NACA-Projekts, das sich auf die
Übersetzung von COBOL nach Java spezialisiert hat.
https://github.com/charleso/naca/blob/master/NacaSamples/src/online/ONLINE1.java
(besucht am 19.05.2018)

110

Literaturverzeichnis

Literatur
[1] Franck Barbier. Cobol software modernization. Hoboken, NJ: ISTE Ltd/John
Wiley and Sons Inc, 2014. isbn: 978-1-84821-760-7.
[2] Beat Balzli. Cobol-Programmierer gesucht: Diese Unternehmen setzen auf ITRentner. 19. Apr. 2017. url: https : / / www . wiwo . de / unternehmen / banke
n / cobol - programmierer - gesucht - diese - unternehmen - setzen - auf - it rentner/19679936.html (besucht am 19. 05. 2018).
[3] Mo Budlong. Teach yourself Cobol in 21 days. 2nd ed. Indianapolis, IN: Sams
Pub, 1997. 1056 S. isbn: 978-0-672-31137-6.
[4] John C Byrne und Jim Cross. Java for COBOL programmers. Boston, MA:
Charles River Media, 2009. isbn: 978-1-58450-618-8. url: http://public.eblib.
com/choice/publicfullrecord.aspx?p=3136100.
[5] Scott Colvey. „Cobol hits 50 and keeps counting“. In: The Guardian. Technology
(8. Apr. 2009). issn: 0261-3077. url: http://www.theguardian.com/technolo
gy/2009/apr/09/cobol-internet-programming (besucht am 19. 05. 2018).
[6] Michael Coughlan. Beginning COBOL for programmers. The expert’s voice in
COBOL. Berkeley, California: Apress, 2014. 556 S. isbn: 978-1-4302-6253-4.
[7] Georg Disterer, Hrsg. Taschenbuch der Wirtschaftsinformatik: mit 71 Tabellen.
München: Fachbuchverl. Leipzig im Carl Hanser Verl, 2000. 663 S. isbn: 978-3446-21051-6.
[8] E. Reed Doke, Bill C Hardgrave, Richard A Johnson und E. Reed Doke. COBOL
programmers swing with Java. Cambridge; New York: Cambridge University Press,
2005. isbn: 978-0-511-08240-5.
[9] Edsger Wybe Dijkstra. How do we tell truths that might hurt? 18. Juni 1975. url:
https://www.cs.utexas.edu/users/EWD/transcriptions/EWD04xx/EWD498.
html (besucht am 19. 05. 2018).
[10] Florian Hamann. In Banken leben Dinosaurier: Cobol kaum totzukriegen. 31. Jan.
2017. url: https://news.efinancialcareers.com/de- de/272568 (besucht
am 19. 05. 2018).
[11] Erich Gamma, Richard Helm, Ralph Johnson und John Vlissides. Design Patterns:
Elements of Reusable Object-oriented Software. Boston, MA, USA: Addison-Wesley
Longman Publishing Co., Inc., 1995. isbn: 978-0-201-63361-0.
[12] IBM Corporation. Enterprise COBOL for z/OS Language Reference. 2013. url:
https://www.ibm.com/support/knowledgecenter/SSQ2R2_9.0.1/com.ibm.
ent.cbl.zos.doc/PGandLR/igy5lr10.pdf (besucht am 19. 05. 2018).
[13] Ist Cobol die Programmiersprache der Zukunft? 26. Jan. 1979. url: https :
/ / www . computerwoche . de / a / ist - cobol - die - programmiersprache - der zukunft,1191656 (besucht am 19. 05. 2018).
IX

Literaturverzeichnis
[14] Jia Walker. COBOL Programming Fundamental. Nov. 2004. url: http://yusman.
staff . gunadarma . ac . id / Downloads / files / 33460 / COBOL _ Programming _
Fundamental.pdf (besucht am 19. 05. 2018).
[15] Stephen Kelly. Cobol – still doing the business after 50 years. 10. Juli 2009. url:
https://www.ft.com/content/9c40ed12- 569c- 11de- 9a1c- 00144feabdc0
(besucht am 19. 05. 2018).
[16] Robert C. Martin. Clean Code: A Handbook of Agile Software Craftsmanship.
1. Aufl. Upper Saddle River, NJ, USA: Prentice Hall PTR, 2008. isbn: 978-0-13235088-4.
[17] Michael Löwe. Betriebliche Informationssysteme. url: http://ux-02.ha.bib.
de/daten/L%C3%B6we/Master/IIS/BetrieblicheInformationsSysteme.pdf
(besucht am 19. 05. 2018).
[18] Oracle. Reading, Writing, and Creating Files (The Java™ Tutorials > Essential
Classes > Basic I/O). url: https://docs.oracle.com/javase/tutorial/
essential/io/file.html (besucht am 19. 05. 2018).
[19] Christian Rehn. Tutorials schreiben oder: Wenn sich Programmierer in Prosa
versuchen. 29. Sep. 2009. url: http://www.christian-rehn.de/wp-content/
uploads/2009/09/tutorials2.pdf (besucht am 19. 05. 2018).
[20] R. M. Richards. „Enhancing Cobol program structure: sections vs. paragraphs“.
In: ACM SIGCSE Bulletin 16.2 (1. Juni 1984), S. 48–51. issn: 00978418. doi:
10.1145/989341.989353. url: http://portal.acm.org/citation.cfm?doid=
989341.989353 (besucht am 19. 05. 2018).
[21] Uwe Rozanski. Cobol 2002 ge-packt. 1. Aufl. Die ge-packte Referenz. Bonn: mitpVerl, 2004. 492 S. isbn: 978-3-8266-1363-0.
[22] Paul Rubens. Why it’s time to learn COBOL. 1. Apr. 2016. url: https://www.
cio.com/article/3050836/developer/why-its-time-to-learn-cobol.html
(besucht am 19. 05. 2018).
[23] Harry M. Sneed, Ellen Wolf und Heidi Heilmann. Softwaremigration in der Praxis:
Übertragung alter Softwaresysteme in eine moderne Umgebung. 1. Aufl. Heidelberg:
dpunkt.Verl, 2010. 318 S. isbn: 978-3-89864-564-5.
[24] Nancy B. Stern, Robert A. Stern und James P. Ley. COBOL for the 21st century.
11th ed. Hoboken, NJ: John Wiley & Sons, 2006. 1 S. isbn: 978-0-471-72261-8.
[25] Susanne Hackmack. Objekte, Typen, Typhierarchien, Instanzen, Klassen. 2018.
url: http://www.fb10.uni- bremen.de/homepages/hackmack/clst/pdf/
klassen.pdf (besucht am 19. 05. 2018).
[26] Patrick Thibodeau. Should Universities Offer Cobol Classes? 8. Apr. 2013. url:
https://www.cio.com/article/2386947/education/should-universitiesoffer-cobol-classes-.html (besucht am 19. 05. 2018).
[27] TIOBE Index | TIOBE - The Software Quality Company. url: https://www.
tiobe.com/tiobe-index/ (besucht am 19. 05. 2018).
[28] University of Limerick; Department of Computer Science & Information Systems.
COBOL programming - tutorials, lectures, exercises, examples. url: http://www.
csis.ul.ie/cobol/ (besucht am 19. 05. 2018).

X

